<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一条心猿意码的狗]]></title>
  <subtitle><![CDATA[My name is L.T.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leotse90.com/"/>
  <updated>2015-12-17T14:26:38.000Z</updated>
  <id>http://leotse90.com/</id>
  
  <author>
    <name><![CDATA[Leo Tse]]></name>
    <email><![CDATA[proleo@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[企业计算的终结]]></title>
    <link href="http://leotse90.com/2015/12/17/%E4%BC%81%E4%B8%9A%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%88%E7%BB%93/"/>
    <id>http://leotse90.com/2015/12/17/企业计算的终结/</id>
    <published>2015-12-17T14:25:21.000Z</published>
    <updated>2015-12-17T14:26:38.000Z</updated>
    <content type="html"><![CDATA[<p><em>author：尼古拉斯·卡尔</em><br><em>翻译：黄思路</em><br><em>文章来源：《斯隆管理评论》</em></p>
<blockquote>
<p>这是在36kr上看到的一篇文章，对于文中有关信息技术发展的理解感触颇深，于是kiang到了这里(<a href="http://36kr.com/p/5041175.html" target="_blank" rel="external">原文</a>)。</p>
</blockquote>
<p>花费数百万美元打造内部数据中心后，企业往往会发现面临着快速淘汰这些数据库的窘境。IT 正从一种企业资产转变为一种服务购买。<br>20 世纪早期，有一些之前的几十年里无法想象的事情陆续发生：制造厂商开始关闭、拆除水轮设备、蒸汽机和发电机。要知道，从工业时代开始，电力就是任何产业得以运作的必要前提，工厂作坊除了维持独立发电站来使运作机器以外别无选择。新世纪的到来带来了一种新的可能，许多新兴发电商开始通过建立中央电厂和使用电网给远距离外的客户输送电能。制造商本身不需要再维持独立发电站的运营，他们可以从这些新兴发电商那里购买需要的用电。</p>
<p>几乎过了整整一个世纪后，历史再次重演。过去 50年 中最重要的一项商业成就——信息技术——正在经历类似的转变。信息技术曾以电脑、软件和其他各式各样的形式作为公司的一种资产，而现在，它正在转化为一种从效用供应商那里购买的服务。商业界很少有公司真正意识到这个转变的重大意义和深远影响。至今，关于效应计算的讨论也仅仅是停留在信息技术供应商的市场标语里，如同那些含义模糊的各类名词，“自动系统”、“服务及虚拟化”、“服务型架构” 等等。其实这些充满官腔的言词不仅没有着向大众照亮这一转变的未来，更使人们对于它的理解变得非常模糊。<br><a id="more"></a><br>当下最盛行的一种观点也非常保守。这种观点认为现有的信息技术供应和应用模型会持续下去，并且企业数据中心仍然会是这种模型的核心。然而，这样的看法非常短浅，而且极具危险性。传统模型的经济基础已经动摇，并且在未来很难幸存。如同早期电力供应的转变警示的那样，信息技术从分散资产向集中效应服务的转变有着重大意义。这将颠覆战略、运营的早先设想，改变产业经济，扰乱市场，以及给每一位用户和供应商带来艰巨的挑战。信息技术的商业化应用历史总被描述为伴随惊人的飞跃，但是我们眼下的这场大变革是史上未见的——哪怕是个人电脑或是因特网的问世也无法与之相提并论。</p>
<h2 id="从资产到花费">从资产到花费</h2><p>信息技术如同之前的蒸汽和电力，被经济学家成为通用技术的一种。通用技术被大大小小的公司用来处理纷繁复杂的各类事务，给商业和社会带来深远的变化。在供应稳定的前提下，通用技术的广泛应用为规模经济的发展提供了巨大潜力。不过这类经济需要一段很长的时间才能被完全认识、全面开发。在通用技术发展的早期阶段，技术标准远未完善，配置网络也非常局限，很难得以集中发展。因此通用技术的供应根据不同需要相匹配，发展模式非常分散。个体公司必须采购各种使用这种技术需要的配置，组装、搭建好之后想办法使这套系统运转起来，并专门雇佣专家进行保养和维修。</p>
<p>这样的分散式供应其实非常的浪费资源：它对各家公司来说意味着大量的投资和高昂的成本，并在技术和劳动力方面导致沉重的多余开支和极高的产能过剩。这种状况对于技术配置提供商来说无疑是有利的，因为他们可以从这种过度投资中获益颇丰，然而这种模式最终还是不可持续的。随着通用技术的发展，集中输送也具备了可能，大型的公共服务供应商开始取代私人供应商。尽管公司可能需要数年的时间弃置他们专有的供应业务和这背后的沉没成本，与大型供应商合作所带来的成本节约还是更具吸引力，对那些大型企业来说也是无法拒绝的诱惑。放弃旧模式也就成为了一种打造竞争力的必然做法。</p>
<p>电力供应的演变就是印证这一过程的一个明确案例。19 世纪 80年 代，商业供电才刚开始，很多小型供电商在城市迅速发展，他们中的很多都是小规模个体运营，使用燃煤发电机生产容量非常有限的电力。由于他们的电力是直流电，不能被输送的很远，这个服务距离也就被限制在一英里之内。运营的高成本使得他们向客户征收高昂的费用，因此他们的客户大多都是财力雄厚的商场、写字楼、业主和市政机构，这些客户需要电力的目的主要是用以维持照明系统。</p>
<p>仅依靠这些小型发电站对于大型工业发展来说并非长久之计。为了满足大量的电力需求，大型工业企业必须建立自己的发电站。他们与电力提供商，比如通用电气和西屋电气签订协约，从他们那里获取发电设备和专业人员配备，雇佣电气工程师和相关专家操作、维护这一套复杂的系统，使之融入生产链的运作中。在电气化早期发展的阶段，私人发电商很快占据了主导地位。到 1902年，在美国境内大约有 50000 家私人发电厂。1907年，这些工厂已经在生产整个国家使用的电力中的 60%。</p>
<p>和这些大厂商的情况不同，像城市印刷厂这样的小型工业企业选取的是完全不同的路径。他们无法承担安装发电机和配备维修人员的费用，因而只能依靠附近的集中发电站，即使这意味着要付一笔不菲的费用，还要忍受频繁的电力中断。那时候，这些小厂商的感受就像是在电气化竞赛中被甩后一截而不得不采用看上去低人一等的供应模式，以此维持电力带来的生产率的提高。事实上，人们当时并没有想到这些小型企业其实是一种大趋势的先行者，很快的，他们强大的竞争对手也会意识到从外部供应商那里购买电力带来的明显优势，从而选择与他们一样的路。</p>
<p>这种转变的发生是以一系列的科技进步为背景的。第一，巨型热涡轮机的发展给规模经济提供了更大的潜力。第二，交变电流使电力输送的距离更远，扩大了中央电站可以服务的客户规模。第三，换流器的发明可以转换电流的不同形式，也就使得旧设备可以适应新系统的运作。最后，具备交流电下工作能力的电动机的发明使工厂可以利用新兴电网来运行机器。早在二十世纪初，所有技术元素就已经就位，向制造厂商提供集中化的电力供应，淘汰它们老化的、独立的发电机。</p>
<p>单有技术进步也是不够的。现状的彻底改变也需要商业视野。能够把握技术、市场和经济趋势的综合体的人可以领先创造全新的供应模式——这个人就是一位名为塞缪尔·英萨尔的英国会计。对电力深有研究的英萨尔在 1880年 移民纽约，很快成为托马斯·爱迪生最为信任的顾问，帮助这位发明家扩大商业帝国。不过英萨尔最伟大的成就是在他离开爱迪生之后，1892年 他辞去工作搬去了芝加哥，在那里担任一家拥有三个发电站和不超过 5000 名客户的小型独立发电公司的总裁。在不到 25年 的时间里，他将这家小公司打造成为世界上最大的企业之一——名为联邦爱迪生的大型垄断企业。</p>
<p>英萨尔最先意识到，通过新技术的资本化来巩固发电量，集中的公用事业可以满足任何大型工厂的电力需求。并且公用事业的规模经济加上用户群体中用电需求的扩散可以帮助他们获得更高的产能利用率，进而提供比私有的分量表发电便宜很多的电力。洞悉事态发展的英赛尔当机立断买下了芝加哥所有的小型发电公司，并且在自己的发电站中安置了 5000 千瓦的大型发电机。同样重要的行动还包括，英赛尔首先推出电能计量和可变定价，大幅削减对大客户的报价，以此稳固这些客源。最后，他详细制定了一套市场方案，使制造商确信，关闭原先的独立发电机转而从自己的公司购买电力才是明智之举。</p>
<p>随着芝加哥各大厂商朝自己的公司蜂拥而至，英赛尔的预见变成了现实。1908年 一位来自 Electrical World and Engieneer 的记者写道：“尽管在芝加哥还存在无数个体运作的发电厂，他们现在经历着的是前所未有的来自集中发电站的压迫…联邦爱迪生公司拥有的很多发电机以前都是属于芝加哥一些大型独立厂商的。” 质变的临界点已经到来。尽管很多厂商可能还是会在未来几年选择独立发电，私人发电向公共发电的转折已经开始。在 1907年 到 1920年 间公共发电占了全美总量的 40%-70%，到了 1930年，这个比例已经上升到 80.8%。</p>
<p>将电力由一项复杂资产转化为一种常规的可变开支，这种观点的转变帮助厂商节约成本，腾出资本用于更有价值的生产目标。同时，他们可以精简员工，减少技术过时和故障的风险，企业管理人员也因此可以避免对重大隐患的时刻担忧。曾经无法想象的公共电力的广泛使用已经不可逆转的发生，私人发电站也被时代淘汰。</p>
<h2 id="信息技术转型开始">信息技术转型开始</h2><p>当然，历史的类比总是有其局限性，信息技术和电力技术有太多重大区别。比如，信息技术所包涵的软件程序是人类智慧的产品，受到知识产权法的保护。不过，信息技术和电力技术之间也有很多相同之处——而当代的观察者很容易忽视这些相似点。今天，人们把电看做一种 “简易” 的效用，毫无新鲜感的电流会遵循安全的、设计好的途径通过埋在墙壁里的插座。已经见惯了无数和电有关的工具，从家用台灯到装配线上的机床，电已经变得如此平常，以至于我们不再把它看作为一种了不起的基础科技——它们经历了独特又熟悉的生命演变。不过，事实并非总是如此。</p>
<p>电气化刚开始时，电是一种极其复杂、不可预知并且还远未被完全掌控的力量，它可以改变任何它触碰到的东西。借用现代的术语，电的应用层当时只停留在发电机、电线和电流本身。人们需要研究清楚如何将电力应用到具体运营中，也就由此衍生出各种根本性的改变、长期实践、业务流程和组织架构。随着科技的进步，人们不得不经常与老化、过时的设备作斗争——所谓的 “遗产系统（传统系统）” 往往会阻碍进步的发展。</p>
<p>作为一种商业资源或输入的信息技术科技，今天看来与上世纪电力技术发展的开端颇为相似。公司企业从供应商那里购买各类设备，包括电脑、储存硬盘、网络交换机以及各种软件，然后将所有这些融合到一套复杂的、内部的信息处理系统或者数据库中。他们聘请专门的工作人员维护这套系统，还经常需要外部顾问来解决尤其棘手的问题。公司的执行层工作常常会因为这受到牵制，影响真正的业务表现——以汽车行业为例，为了维持公司的独立信息基础设施运行顺畅，汽车制造和销售都需要极尽所能最大化利润。</p>
<p>成千上万的独立数据中心使用的其实是基本类似的硬件系统和软件程序，而这些数据中心已经给很多个体公司带来了严重的危害，对整体经济来说也是如此。信息技术资产的过度建设导致极低程度的资本利用率。最近的一次对六家企业数据库的研究表明，超过 1000 台服务器仅仅发挥了 10%-35%的处理能力。台式电脑的表现就更加糟糕，以 IBM 为例，平均产能利用率只有 5%。总部位于康涅狄格州斯坦福德的 Gartner 公司通过研究发现，大约 50%-60%的公司数据存储容量处于被浪费的状态。产能过剩的状态也不仅限于硬件。由于软件程序具有极高的扩展性，也就是说，它们可以在极少甚至没有增量成本的前提下服务更多的用户，因而在数千个不同的网站安装完全一样或类似的软件会导致急剧的经营管理失当，不管是在前期支出还是在现行成本费用方面。各家公司对大同小异的 IT 部门的复制也会导致对劳动力的过度投资。2003年 的一项调查显示，美国各家公司 IT 部门平均预算的 60%都被用于常规支持和功能性维护。</p>
<h2 id="个人电脑">个人电脑</h2><p>如果说有什么可以代表现今企业 IT 状况的话，那无疑是个人电脑。个人电脑不仅占据了现代公司的每一张办公桌，更是典型的企业计算总体状况的缩影：零散、多余、并且越来越疏于利用。</p>
<p>个人电脑的发明是一个伟大的成就，是现近代商业史上一项最重要的发明。它使计算能力扩散到个人，激发创新，提高个人生产力，并且无疑加速了网络的发展，包括因特网和 World Wide Web。然而强大的、高容量的网络的发展也使台式电脑的必要性越来越低；计算资源可以不论距离、越来越多的被提供给用户。当个人电脑的容量达到最大时，用户的需求却并没有保持一致的扩张。人们仅仅使用计算马力中极小部分，现代电脑的多 GB 硬盘容量也往往要不是空的，要不就被塞满无价值的文件。</p>
<p>有人争论说个人电脑现在反正非常便宜，也就无所谓有没有被浪费了。然而这种说法并没有考虑到维护、更新大量个人电脑和相关软件所产生的庞大开支，也忽视了个人电脑常常是现代公司最大安全隐患这一事实——黑客入口和诉讼证据储存库。</p>
<p>上世纪 90年 代后期，Oracel 首席执行官拉里艾里森因为声称个人电脑会成为 “一种可笑的设备” 而广受批评，他认为个人电脑将瘦客户机所取代——连接中央主机的终端以及其他精简设备。艾里森的论断的时机也许并不正确，但并不代表这个论断也不正确。随着效用计算的发展，现代公司保留台式电脑的倾向将越来越弱。在家里，个人电脑也许是计算的引擎，但是在商业里，它却无足轻重，并且越来越不必要。</p>
<p>当产能过剩与冗余功能相结合，向集中供应的转变也就具备了成熟的条件。然而公司持续在维护甚至扩大个体数据中心上进行大量投资，这是为什么？就和 20 世纪早期制造厂商依旧安装个体发电机的原因一样：缺少可靠、大规模的效用模型。而这种模型现在正在产生和发展。效用计算的初级形态正在增值，很多公司也在加快对他们的投资。有些公司使用由像 IBM、惠普公司和数据信息系统等供应商所提供的紧急硬件支持来维护自己的大数据中心，有些则采用远程软件商提供的应用程序。包括采购、运输管理、财务、客户服务、销售团队管理以及其它各种功能在内的这些程序项目已经充分表明，即使是非常复杂的应用也可以通过服务提供的方式由因特网获取。</p>
<h2 id="开拓者">开拓者</h2><p>小型公司在转向公共电力提供这方面打了先头。由于缺少建立独立发电站的资金，他们除了从外部供应商那里购买电力之外并没有什么其他选择。早起采用效应计算的公司中最激进的也属于资本受限的一类组织：中小型企业，政府机构和非营利组织。</p>
<p>例如，宾夕法尼亚联邦早在十年前就开始向效用计算的方式转移。经过几年的策划，该州于 1999年 秋天开始关闭 17 个政府组织所运营的数据中心，并巩固由优利系统公司领衔的供应商联盟提供的硬件和软件设施。类似的，纽约的林肯艺术中心也采用了效应模式。他们不再维持原先售票系统的应用程序和服务器，而是使用 IBM 提供和维护的硬件，只需要每个月缴纳一笔资费。</p>
<p>一些大企业开始在更大规模上接纳效用计算的方式。澳洲航空公司从 2004年 开始卸载他们的数据中心，将数百个服务器和大型计算机迁移到新供应商提供的设备。现在该公司只需要根据实际的计算容量使用量来支付相应的资费。澳洲航空公司甚至将业务中最核心的预定和票务系统外包给总部位于西班牙马德里的技术提供商 Amadeus 全球旅游分销。据澳航首席信息官菲奥娜贝尔福称，公司数据中心预算中用于固定成本的百分比已经从 70%降到了 30%，正是因为向效用供给的转变。</p>
<p>很多其他的大公司正在建立内部的 “效用” 供给，提供整个公司的计算资源。他们巩固了以往的分散计算、数据储存和网络硬件，实施更严格的软件标准，并利用包括虚拟化、网络服务在内的新技术给业务部门和企业公司提供最量身定做的服务。DHL 近期整合了旗下八个北美数据中心，将它们融入位于亚利桑那的统一处理器中。从事化学和药物行业的拜耳美国将也将其信息技术运营加以集中，将 42 个数据中心整合为两处，并减半了服务器数量——这样做带来成本节约高达一亿美元。这也代表随着规模效用的出现，我们将向更广阔的信息技术资源整合又迈近一步。</p>
<p>早期的发展进程没有展示出的，是一个真正效用模型的充分程度和力量。当代很多零碎的效用服务以对传统数据中心重新打造的方式存在；个体公司必须将效用服务与他们过去的软件硬件联系起来。确实，很多公司不得不放弃极具吸引力的效用服务或是在外包过程中遇到很多问题，因为对传统系统的整合是非常困难的。只有在外包商满足公司所有的 IT 要求，包括数据处理、储存、应用时，真正的效用计算才能发生。效用模型要求的，是对传统上保留在零散内部数据中心的资产的所属权权被转移给效用提供商，并由他们加以巩固。</p>
<p>这个过程需要很多年才能完全展开，但是技术积木已经在开始累积搭建。三大进步——虚拟化、网格计算和 Web 服务尤为重要，尽管他们的重要性经常由于和他们联系在一起的晦涩术语被模糊化。这三大技术扮演的角色有点类似于早期的电流转换器，当然是以不同的表现形式呈现：他们使之前互不相容的部分构建、融合成一个大而紧密的系统。虚拟化技术消除了不同计算平台之间的差异，使应用程序可以在不同的操作系统中运行。网格计算允许大量的硬件部分，比如服务器和磁盘驱动有效的发挥作用，汇集它们的能力并自动分配去执行不同的任务。Web 服务将应用程序的互动标准化，将他们变成可轻易拆卸、组装的模块。</p>
<p>单个来看，每一种技术都非常有趣，但是将他们组合在一起是一件真正具有革命性的事情。利用高容量的光纤通信网络，人们可以将零散、笨重的一套硬、软件组件整合为一个单个、灵活性的基础设施，并且可以被无数家公司以不同的方式采用。随着某个系统服务的用户增多，这个系统的需求负荷也变得更平衡，它的产能利用率得以提高，规模经济也在扩大。考虑到技术的不断演变和进步也伴随着相关新兴技术的出现，将信息技术作为一种效用提供的能力只会不断提高，并且这么做所带来的经济刺激也会不断增长。</p>
<p>效用计算的最大障碍并不是技术，而是态度。如同向集中电力的模式转变，最大的障碍在于传统操作、过去的投资、和以这两者为基础建立的根深蒂固的管理预设。大公司只有在信息技术效用的可靠性、稳定性和好处明确建立起来之后，才敢对他们的数据中心下手改革。为了让这样的变革发生，当代的 “塞缪尔英萨尔” 需要具备如何运营信息技术效用的清晰视野，同时还必须有使其发生的经济实力和想象力。就像他的前辈那样，这样的视野会打造出高效的、大规模的信息技术工厂，与成熟的计量和计价系统相结合，为不同客户提供优越灵活的、量身定做的全套服务。同时，他也会用极具说服力的营销方案向企业高管证明，集中化管理之前零散的资源不仅可以节约成本、解放资本，更可以提高安全性，加强灵活性和减少风险。简而言之，这个人将会创造一个产业。</p>
<h2 id="新产业的形状">新产业的形状</h2><p>新产业具体会以什么样子呈现还未可知，但是我们可以大概预见其轮廓。它将会有主要的三部分，最中心的部分是信息技术效用本身——大型企业将在中央系统中维护核心计算资源，并将它们输送给终端用户。效用模型的运作需要大批不同的部件提供商——电脑、储存、网络设备、操作和效用软件、应用程序等。最后，大型网络运营商将负责超大容量的数据线路。并且，肯定会有有能力的公司同时负责这些门类中一种以上的供应项目。</p>
<p>这种效用模型最激动人心之处在于它的独特——也正是这些独特让信息技术非常适合向效用服务发展。如果是电力技术，只有基本的发电功能可以集中化，因为它的应用是通过发电机物理性传送到电灯泡等电力设备的，也就是说他们必须用于用户本地供应。然而信息技术的应用是以软件为主要形式，可以由提供商远程操作。就算是为客户定制的应用也可以被安置在供应商处。终端用户只需要维护各种输入和输出设备，比如监控器、打印机、键盘、扫描仪、移动设备、传感器等需要用来接收、传送和操作数据，以及重新配置服务的相关仪器。尽管有些客户会倾向于本地运行程序，效用提供商还是可以拥有和操作大部分硬件和软件，放大他们的规模优势。</p>
<p>哪些公司会成为新兴的效用供应商？目前至少有四类可能。首先是致力于企业计算硬件的传统大型制造商，比如 IBM, 惠普公司, 太阳微系统公司等。他们有非常丰富的设置、运营商业系统的经验，并且毫无意外的，他们已经开始非常积极的转向效用提供商的角色定位。太阳微系统公司不仅以单位计费出租处理储存容量，还在网上拍卖计算能力。第二类是专业性的托管运营商，比如休斯顿的 VeriCenter 和弗吉尼亚 MCI 的 Digex 服务，他们现在依然给中小型公司运营整体数据中心。这些在挣扎在网络泡沫崩溃后的专门性公司也开始模仿电气化早期原先作为中央发电站的运营商的做法。第三类是类似谷歌和亚马逊的因特网创新公司，他们建立的广泛成熟的计算网络理论上可以被调整以适应更多用途。最后一类是我们现在还不怎么了解的创业公司，他们有研发灵活策略的潜力。因为效用行业规模驱动和资本密集的特点，规模和重点对于成功来说非常关键。任何公司都难以做到保持领先的同时实现其他商业目标。</p>
<p>目前看来，效用计算系统似乎符合哈佛商学院克莱顿克里斯滕森定义的颠覆式创新模式：首先占领低端市场，然后脱颖而出，最终成为占据主导地位的供应模式。因此，它有可能对现在很多大型部件提供商构成极大地危险，包括微软、戴尔、甲骨文、SAP 等通过对企业的世界销售大获成功的公司。效用模型将供应商与终端客户隔离，迫使他们向、或是通过大型集中效用的方式销售产品和服务，这也会带来更大的议价能力。大部分被广泛使用的部件，从电脑、操作系统到复杂的自动化业务流程的 “企业应用”，在未来都会作为便宜常见的商品而被购买。</p>
<p>当然，当下领先的部件供应商拥有庞大的市场能力和管理技能，他们也有时间根据效用模型的发展调整策略，有些可能会向前融入这种有过成功先例的效用模式。当厂商开始从购买电力时，两家最大的提供商，包括提供发电机和相关部件的通用电气和西屋电气当即买下很多电力公司的股份，大力扩大业务规模。早在 1895年，通用电气就在全美和欧洲投资了超过五千九百万美元的电力设施。</p>
<p>不过这样的先例也向我们警示了整合买卖双方行为的风险。美国的电力业务越来越被集中在少数公司手里，政府顾忌到垄断公司对这种关键性资源的掌控，因而对行业设置了更严格的限制。信息技术行业的组成部分更多样化，但是少数公司对基础设施的独断控制的可能性也是存在的。垄断不仅会导致对终端用户的高额收费，也会减缓创新速度，带来其他各种危害。可见，保持一种提供商和效用商之间的良性竞争对于未来数年健康、繁荣的信息基础产业是至关重要的。</p>
<h2 id="从未来回望">从未来回望</h2><p>任何对于未来的预测，尤其是涉及到科技进步速度和方向的预测，都具有投机性，我们现在面对的状况也不例外。然而，如果说技术进步总是无法预测的，那么经济和市场能力总是以一种有规律且有一致性的方式引导商业发展。商业的历史告诉我们，重复投资和分散能力对集中供应提供了强有力的刺激。计算能力和网络进步也允许信息技术以一种愈发 “虚拟化” 的方式发展，而基础技术资产和用户获取、转译和处理信息点的距离也可以越来越远。考虑到这种发展趋势，信息技术企业激进的变革将不可避免。</p>
<p>有时，最大的产业变革似乎让人不可思议，即使它确确实实在发生。现在当我们回望过去的电力行业，我们看到的是一段以清晰、明确的逻辑所展开的演变过程。不难辨别，个体公司修建和维护专有发电厂的行为是一种过渡性现象，一种人为的必须，并没有太大经济意义。从当下的立场来看，电力的效用化是必然结果。现在看上去毫无疑问的事情对于当时的工厂厂主、管理人员来说都是非常牵强、甚至可笑荒唐的，因为对于他们来说，维护独立电能是已经延续了数十年的传统做法。</p>
<p>想象一下，未来的人在回望一百年之后、现在的我们，他们会看到什么？难道独立数据中心不也正是一种过渡性现象吗？——和当年的独立发电厂一样的一种权宜之计。难道信息技术效用的发展不正是一种自然、必然的趋势吗？并且，难道现在的企业计算方式本质上来说不正是毫无逻辑却又注定如此吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>author：尼古拉斯·卡尔</em><br><em>翻译：黄思路</em><br><em>文章来源：《斯隆管理评论》</em></p>
<blockquote>
<p>这是在36kr上看到的一篇文章，对于文中有关信息技术发展的理解感触颇深，于是kiang到了这里(<a href="http://36kr.com/p/5041175.html">原文</a>)。</p>
</blockquote>
<p>花费数百万美元打造内部数据中心后，企业往往会发现面临着快速淘汰这些数据库的窘境。IT 正从一种企业资产转变为一种服务购买。<br>20 世纪早期，有一些之前的几十年里无法想象的事情陆续发生：制造厂商开始关闭、拆除水轮设备、蒸汽机和发电机。要知道，从工业时代开始，电力就是任何产业得以运作的必要前提，工厂作坊除了维持独立发电站来使运作机器以外别无选择。新世纪的到来带来了一种新的可能，许多新兴发电商开始通过建立中央电厂和使用电网给远距离外的客户输送电能。制造商本身不需要再维持独立发电站的运营，他们可以从这些新兴发电商那里购买需要的用电。</p>
<p>几乎过了整整一个世纪后，历史再次重演。过去 50年 中最重要的一项商业成就——信息技术——正在经历类似的转变。信息技术曾以电脑、软件和其他各式各样的形式作为公司的一种资产，而现在，它正在转化为一种从效用供应商那里购买的服务。商业界很少有公司真正意识到这个转变的重大意义和深远影响。至今，关于效应计算的讨论也仅仅是停留在信息技术供应商的市场标语里，如同那些含义模糊的各类名词，“自动系统”、“服务及虚拟化”、“服务型架构” 等等。其实这些充满官腔的言词不仅没有着向大众照亮这一转变的未来，更使人们对于它的理解变得非常模糊。<br>]]>
    
    </summary>
    
      <category term="IT" scheme="http://leotse90.com/tags/IT/"/>
    
      <category term="互联网" scheme="http://leotse90.com/categories/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES之当你更新Document，你在更新些什么？]]></title>
    <link href="http://leotse90.com/2015/11/24/ES%E4%B9%8B%E5%BD%93%E4%BD%A0%E6%9B%B4%E6%96%B0Document%E4%BD%A0%E5%9C%A8%E6%9B%B4%E6%96%B0%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <id>http://leotse90.com/2015/11/24/ES之当你更新Document你在更新些什么/</id>
    <published>2015-11-24T14:59:13.000Z</published>
    <updated>2015-11-25T00:10:48.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="怎么更新ElasticSearch中的Document？">怎么更新ElasticSearch中的Document？</h2><p>在ES中更新数据的场景有很多，比如我们要修改一个用户的年龄、爱好，又或者我们需要实时同步MySQL中的数据到ES中。我们都有修改已经存在的Document的需求。ES本身提供了两种方法让我们修改一个Document的数据，我们假设我们想要修改的内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="built_in">test</span>/customer/<span class="number">1</span>/_<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想将yolovon女神的年龄修改到真实年龄18岁。我们可以进行以下两种方法：<br>1.使用PUT，就像我们插入数据时那样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/customer/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_index"</span>: <span class="string">"test"</span>,</span><br><span class="line">   <span class="string">"_type"</span>: <span class="string">"customer"</span>,</span><br><span class="line">   <span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这里需要注意的是，我们必须将所有的字段全部输入一次，如果你只在PUT的body里输入我们要更新的字段（比如在这里我们只传入age的值），那么新的Document的就会变成我们后面PUT进去的样子（即只有age一个字段）。<br>另外，我们可以看到这里的返回信息有用以标示该document唯一性的<code>_index</code>，<code>_type</code>，<code>_id</code>，以及<code>_version</code>表明该document的更新版本，<code>created</code>表明这个不是新建的而是已经存在的document。</p>
<p>2.使用POST，update模式更新Document：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test/customer/<span class="number">1</span>/_<span class="keyword">update</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"doc"</span>: &#123;</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会看到这样的结果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">   "<span class="attribute">_type</span>": <span class="value"><span class="string">"customer"</span></span>,</span><br><span class="line">   "<span class="attribute">_id</span>": <span class="value"><span class="string">"1"</span></span>,</span><br><span class="line">   "<span class="attribute">_version</span>": <span class="value"><span class="number">3</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候，我们的document也变为了：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">name</span>": <span class="value"><span class="string">"yolovon"</span></span>,</span><br><span class="line">   "<span class="attribute">age</span>": <span class="value"><span class="number">20</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>age</code>已经变成了20。而且在这里，我们只针对需要修改的<code>age</code>字段进行操作，而其他字段并不需要关心。</p>
<h2 id="更新操作都干了些什么？">更新操作都干了些什么？</h2><p>那么，在更新的时候到底发生了什么？上面的两种更新策略又有什么区别？  </p>
<p>我们知道，在Elasticsearch中，document是不可变的。  </p>
<blockquote>
<p>Documents in Elasticsearch are immutable; we cannot change them. Instead, if we need to update an existing document, we reindex or replace it.</p>
</blockquote>
<p>这样一来，我们在更新Document时到底是怎么实现的？  </p>
<p><strong>在ES中，不管我们用以上哪种方式进行更新document，它都不是真正地对原来的document进行操作。而是先将原来的document标记为删除状态，然后重新新增一个document（也就是我们看到的新的document），实际上，原来的document并没有立即消失，只是你已经不能访问它了，ES稍后会在后台真正地删除原来的document。</strong></p>
<p>不管我们用那种方式进行更新，ES都会按照以下的步骤进行更新：</p>
<blockquote>
<p>1.查询出旧的document；<br>2.修改document中的字段；<br>3.删除旧的document；<br>4.重新索引一个新的document。</p>
</blockquote>
<p>但是两者还是有区别的，当使用<code>PUT</code>一个完整的document时，它需要请求两次，一次<code>get</code>请求和一次<code>index</code>请求，而使用<code>POST</code>进行<code>_update</code>操作的时候只需要一次<code>_udpate</code>请求即可。</p>
<p>因此我们在使用的时候，尽量避免使用<code>PUT</code>进行document的更新，特别是当我们需要批量地修改ES数据时。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="怎么更新ElasticSearch中的Document？">怎么更新ElasticSearch中的Document？</h2><p>在ES中更新数据的场景有很多，比如我们要修改一个用户的年龄、爱好，又或者我们需要实时同步MySQL中的数据到ES中。我们都有修改已经存在的Document的需求。ES本身提供了两种方法让我们修改一个Document的数据，我们假设我们想要修改的内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="built_in">test</span>/customer/<span class="number">1</span>/_<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想将yolovon女神的年龄修改到真实年龄18岁。我们可以进行以下两种方法：<br>1.使用PUT，就像我们插入数据时那样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/customer/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_index"</span>: <span class="string">"test"</span>,</span><br><span class="line">   <span class="string">"_type"</span>: <span class="string">"customer"</span>,</span><br><span class="line">   <span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ElasticSearch与MySQL数据同步]]></title>
    <link href="http://leotse90.com/2015/11/11/ElasticSearch%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://leotse90.com/2015/11/11/ElasticSearch与MySQL数据同步以及修改表结构/</id>
    <published>2015-11-11T14:12:23.000Z</published>
    <updated>2015-11-12T00:31:38.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES与MySQL的数据同步">ES与MySQL的数据同步</h2><p>如果你需要进行ES与MySQL的数据同步，亦即将MySQL中的数据导入到ES中，并保持同步，一般来看，有以下几种方法：<br>1.自己动手写一个同步的模块。实时tail处理MySQL的binlog，将数据库的新增、修改或删除这些操作同步在ES上执行。这种方案可行，但是实现起来代价大；</p>
<p>2.<a href="https://github.com/siddontang/go-mysql-elasticsearch" target="_blank" rel="external">go-mysql-elasticsearch</a>。这是Git上的一个开源项目，差不多是第一种方案的一个实现版本。这个插件支持实时同步MySQL与ES的新增、修改以及删除操作。但是缺点是使用起来不够灵活，它的作者给出了它的以下缺点：</p>
<blockquote>
<p>-binlog row image must be full for MySQL, you may lost some field data if you update PK data in MySQL with minimal or noblob binlog row image. MariaDB only supports full row image.<br>-Can not alter table format at runtime.<br>-<code>mysqldump</code> must exist in the same node with go-mysql-elasticsearch, if not, go-mysql-elasticsearch will try to sync binlog only.  </p>
</blockquote>
<a id="more"></a>
<p>这三点比较重要的缺点影响我使用这种方案，特别是不能运行时修改表结构。对于很多在线业务来说是比较难以接受的。</p>
<p>3.<a href="https://github.com/jprante/elasticsearch-jdbc" target="_blank" rel="external">elasticsearch-river-jdbc</a>。这种方案是1、2的结合体。可以较为灵活地进行数据同步，比如可以在同步的时候指定需要同步的字段以及筛选条件。这也是比较流行的解决方案，但是它也有一个比较致命的缺点，那就是删除操作不能同步（物理删除）！</p>
<p>如果你的系统对删除操作频繁，而且都是物理删除，并且能接受不能运行时修改表结构等条件，那么使用go-mysql-elasticsearch将是非常不错的选择；如果你的表结构改变得相对频繁，而且不用对表进行物理删除（比如用逻辑删除取而代之），那么你可以选择elasticsearch-river-jdbc。如果你对这两者都不满意，而且觉得自己的编码能力还不错，那么完全可以自己定制一个满足自己需求的插件。</p>
<h2 id="elasticsearch-river-jdbc使用">elasticsearch-river-jdbc使用</h2><p>我们这里选择使用elasticsearch-river-jdbc作为我们同步ES与MySQL的插件。我们这里简单介绍一下elasticsearch-river-jdbc的安装与使用：<br>1.确保ES的集群的每个Node都能访问MySQL数据库；  </p>
<p>2.安装River：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;./bin/plugin --install river-jdbc --url  <span class="symbol">http:</span>/<span class="regexp">/xbib.org/repository</span><span class="regexp">/org/xbib</span><span class="regexp">/elasticsearch/plugin</span><span class="regexp">/elasticsearch-river-jdbc/</span><span class="number">1.5</span>.<span class="number">0.5</span>/elasticsearch-river-jdbc-<span class="number">1.5</span>.<span class="number">0.5</span>-plugin.zip</span><br></pre></td></tr></table></figure></p>
<p>3.下载mysql-connector-java-5.1.30-bin.jar并将其保存在{$ES_HOME}/plugins/jdbc/目录下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="symbol">http:</span>/<span class="regexp">/cdn.mysql.com/</span><span class="regexp">/Downloads/</span><span class="constant">Connector</span>-<span class="constant">J</span>/mysql-connector-java-<span class="number">5.1</span>.<span class="number">37</span>.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>如果是ES集群，你需要在每一个Node上执行这一步。</p>
<p>4.创建一个JDBC river<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;curl -XPUT <span class="string">'localhost:9200/_river/my_jdbc_river/_meta'</span> -d <span class="string">'&#123;</span><br><span class="line">     "</span>type<span class="string">" : "</span>jdbc<span class="string">",</span><br><span class="line">     "</span>jdbc<span class="string">" : &#123;</span><br><span class="line">         "</span>driver<span class="string">" : "</span><span class="transposed_variable">com.</span><span class="transposed_variable">mysql.</span><span class="transposed_variable">jdbc.</span>Driver<span class="string">",</span><br><span class="line">         "</span>url<span class="string">" : "</span>jdbc:mysql:<span class="comment">//localhost:3306/test",</span></span><br><span class="line">         <span class="string">"user"</span> : <span class="string">"root"</span>,</span><br><span class="line">         <span class="string">"password"</span> : <span class="string">"123456"</span>,</span><br><span class="line">         <span class="string">"sql"</span> : <span class="string">"select * from test.student;"</span>,</span><br><span class="line">         <span class="string">"interval"</span> : <span class="string">"30"</span>,</span><br><span class="line">         <span class="string">"index"</span> : <span class="string">"test"</span>,</span><br><span class="line">         <span class="string">"type"</span> : <span class="string">"student"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;’</span><br></pre></td></tr></table></figure></p>
<p> 5.你可以查看ES是否已经同步了这些数据：<br> <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -XGET <span class="comment">'localhost:9200/test/student/_search?pretty&amp;q=*'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改表结构后的数据同步">修改表结构后的数据同步</h2><p>如果你需要修改正在与ES进行数据同步的表的结构，你有以下三种方案（亲测可行）：<br><strong>方案一</strong>：创建JDBC river的时候使用sql语句：<code>select * from table_name;</code><br>乍一看，这种方法很坑。但是确实适合那些喜欢简单粗暴的coder。但是这种方案的场景比较苛刻：   </p>
<blockquote>
<p>MySQL中表在创建时id命名为_id，这是因为_id是ES中每一条document的唯一标识；如果不这样干，你会发现每一次同步ES的type中都会增加MySQL表中条目数个Document；<br>MySQL表所有的字段对ES都是有效的、必要的；</p>
</blockquote>
<p><strong>方案二</strong>.方案一的改进版，使用sql语句：<code>select *, id as _id from table_name;</code><br>这个方案在你需要在ES中存储MySQL中表所有字段的时候变得比较有效。</p>
<p><strong>方案三</strong>：使用elasticsearch的alias。具体的操作比较简单，可以参照<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html" target="_blank" rel="external">官网的介绍</a>。</p>
<p>前两种方案有点取巧，第三种方案才是正道。</p>
<p>如果你愿意，完全建议自己定制一套解决方案。由于业务需要，本人最近也在开始写这样的插件。我会在这个博客里保持更新。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES与MySQL的数据同步">ES与MySQL的数据同步</h2><p>如果你需要进行ES与MySQL的数据同步，亦即将MySQL中的数据导入到ES中，并保持同步，一般来看，有以下几种方法：<br>1.自己动手写一个同步的模块。实时tail处理MySQL的binlog，将数据库的新增、修改或删除这些操作同步在ES上执行。这种方案可行，但是实现起来代价大；</p>
<p>2.<a href="https://github.com/siddontang/go-mysql-elasticsearch">go-mysql-elasticsearch</a>。这是Git上的一个开源项目，差不多是第一种方案的一个实现版本。这个插件支持实时同步MySQL与ES的新增、修改以及删除操作。但是缺点是使用起来不够灵活，它的作者给出了它的以下缺点：</p>
<blockquote>
<p>-binlog row image must be full for MySQL, you may lost some field data if you update PK data in MySQL with minimal or noblob binlog row image. MariaDB only supports full row image.<br>-Can not alter table format at runtime.<br>-<code>mysqldump</code> must exist in the same node with go-mysql-elasticsearch, if not, go-mysql-elasticsearch will try to sync binlog only.  </p>
</blockquote>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="MySQL" scheme="http://leotse90.com/tags/MySQL/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES查询－match VS match_phrase]]></title>
    <link href="http://leotse90.com/2015/11/10/ElasticSearch-match-VS-match-phrase/"/>
    <id>http://leotse90.com/2015/11/10/ElasticSearch-match-VS-match-phrase/</id>
    <published>2015-11-09T16:05:35.000Z</published>
    <updated>2015-11-09T16:18:09.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="match_VS_match_phrase">match VS match_phrase</h2><p>我们以一个查询的示例开始，我们在student这个type中存储了一些学生的基本信息，我们分别使用match和match_phrase进行查询。<br>首先，使用match进行检索，关键字是“He is”：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"He is"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行这条查询，得到的结果如下：<a id="more"></a><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">took</span>": <span class="value"><span class="number">3</span></span>,</span><br><span class="line">   "<span class="attribute">timed_out</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">   "<span class="attribute">_shards</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">successful</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">failed</span>": <span class="value"><span class="number">0</span></span><br><span class="line">   </span>&#125;</span>,</span><br><span class="line">   "<span class="attribute">hits</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">4</span></span>,</span><br><span class="line">      "<span class="attribute">max_score</span>": <span class="value"><span class="number">0.2169777</span></span>,</span><br><span class="line">      "<span class="attribute">hits</span>": <span class="value">[</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"2"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.2169777</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"februus"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">24</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is passionate."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, programing"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"1"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.16273327</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"leotse"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">25</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is a big data engineer."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, swiming, hiking"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"4"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.01989093</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"pascal"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">25</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He works very hard because he wanna go to Canada."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"programing, reading"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"3"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.016878016</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"yolovon"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"female"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">24</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"She is so charming and beautiful."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, shopping"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;</span><br><span class="line">      ]</span><br><span class="line">   </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>而当你执行match_phrase时：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"He is"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">took</span>": <span class="value"><span class="number">3</span></span>,</span><br><span class="line">   "<span class="attribute">timed_out</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">   "<span class="attribute">_shards</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">successful</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">failed</span>": <span class="value"><span class="number">0</span></span><br><span class="line">   </span>&#125;</span>,</span><br><span class="line">   "<span class="attribute">hits</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">2</span></span>,</span><br><span class="line">      "<span class="attribute">max_score</span>": <span class="value"><span class="number">0.30685282</span></span>,</span><br><span class="line">      "<span class="attribute">hits</span>": <span class="value">[</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"2"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.30685282</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"februus"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">24</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is passionate."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, programing"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"1"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.23013961</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"leotse"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">25</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is a big data engineer."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, swiming, hiking"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;</span><br><span class="line">      ]</span><br><span class="line">   </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>占的篇幅有点长，但是如果能基于此看清这两者之间的区别，那也是值得的。</p>
<p>我们分析一下这两者结果的差别：  </p>
<blockquote>
<p>1.非常直观的一点，对于同一个数据集，两者检索出来的结果集数量不一样；<br>2.对于match的结果，我们可以可以看到，结果的Document中description这个field可以包含“He is”，“He”或者“is”；<br>3.match_phrased的结果中的description字段，必须包含“He is”这一个词组；<br>4.所有的检索结果都有一个_score字段，看起来是当前这个document在当前搜索条件下的评分，而检索结果也是按照这个得分从高到低进行排序。  </p>
</blockquote>
<p>我们要想弄清楚match和match_phrase的区别，要先回到他们的用途：match是全文搜索，也就是说这里的搜索条件是针对这个字段的全文，只要发现和搜索条件相关的Document，都会出现在最终的结果集中，事实上，ES会根据结果相关性评分来对结果集进行排序，这个相关性评分也就是我们看到的_score字段；总体上看，description中出现了“He is”的Document的相关性评分高于只出现“He”或“is”的Document。（至于怎么给每一个Document评分，我们会在以后介绍）。</p>
<blockquote>
<p>相关性(relevance)的概念在Elasticsearch中非常重要，而这个概念在传统关系型数据库中是不可想象的，因为传统数据库对记录的查询只有匹配或者不匹配。</p>
</blockquote>
<p>那么，如果我们不想将我们的查询条件拆分，应该怎么办呢？这时候我们就可以使用match_phrase：<br>match_phrase是短语搜索，亦即它会将给定的短语（phrase）当成一个完整的查询条件。当使用match_phrase进行搜索的时候，你的结果集中，所有的Document都必须包含你指定的查询词组，在这里是“He is”。这看起来有点像关系型数据库的like查询操作。</p>
<h2 id="相关性评分的相关知识">相关性评分的相关知识</h2><p>相信到这里，我们都能比较清楚的理解这两者的区别。但是我们还有一个问题没有弄清楚，那就是_score到底是怎么得出的？为什么同样包含了“He is”这个phrase，_id为2的Document得分为0.30685282，而_id为1的Document的得分为0.23013961？</p>
<p>查询语句会为每个Document计算一个相关性评分_score，评分的计算方式取决于不同的查询类型。ES的相似度算法为TF/IDF（检索词频率/反向文档频率）。我们在这里顺带介绍一下TF/IDF的几个相关概念：</p>
<p>1.<strong>字段长度准则</strong>：这个准则很简单，字段内容的长度越长，相关性越低。我们在上面的两个例子中都能看到，同样包含了“He is”这个关键字，但是”He is passionate.”的相关性评分高于”He is a big data engineer.”，这就是因为字段长度准则影响了它们的相关性评分；</p>
<p>2.<strong>检索词频率准则</strong>：检索关键字出现频率越高，相关性也越高。这个例子中没有比较明显的体现出来，你可以自己试验一下；</p>
<p>3.<strong>反向Document频率准则</strong>：每个检索关键字在Index中出现的频率越高，相关性越低。</p>
<p>一般的，我们理解了以上三个准则，就能了解ES的相关性评分的基本守则。以下是一些相关性评分的Tips：</p>
<blockquote>
<p>单个查询可以使用TF/IDF评分标准或其他方式。<br>如果多条查询子句被合并为一条复合查询语句，那么每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
</blockquote>
<p>因为“相关性评分”这个概念和这篇博文的“相关性评分”并不高，因此在此就不展开讨论，只是点到为止，如果想要了解更多有关ES相关性评分的内容，可以自行Google，也可以继续关注我的博客，以后会专门探讨这一块内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="match_VS_match_phrase">match VS match_phrase</h2><p>我们以一个查询的示例开始，我们在student这个type中存储了一些学生的基本信息，我们分别使用match和match_phrase进行查询。<br>首先，使用match进行检索，关键字是“He is”：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"He is"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行这条查询，得到的结果如下：]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】避免使用GroupByKey]]></title>
    <link href="http://leotse90.com/2015/11/04/%E3%80%90%E8%AF%91%E3%80%91%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8GroupByKey/"/>
    <id>http://leotse90.com/2015/11/04/【译】避免使用GroupByKey/</id>
    <published>2015-11-04T11:37:15.000Z</published>
    <updated>2015-11-04T11:42:25.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>原文：<a href="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/best_practices/prefer_reducebykey_over_groupbykey.html" target="_blank" rel="external">Avoid GroupByKey</a></p>
<h3 id="译文">译文</h3><p>让我们来看两个wordcount的例子，一个使用了<code>reduceByKey</code>，而另一个使用<code>groupByKey</code>:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">words</span> =</span> <span class="type">Array</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordPairsRDD</span> =</span> sc.parallelize(words).map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithReduce</span> =</span> wordPairsRDD</span><br><span class="line">                           .reduceByKey(_ + _)</span><br><span class="line">                           .collect()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithGroup</span> =</span> wordPairsRDD</span><br><span class="line">                          .groupByKey()</span><br><span class="line">                          .map(t =&gt; (t._1, t._2.sum))</span><br><span class="line">                          .collect()</span><br></pre></td></tr></table></figure></p>
<p>上面两个函数所得到的结果都是正确的，但是当数据集很大时，使用了<code>reduceByKey</code>的例子表现更佳。这是因为在shuffle输出的数据前，Spark会Combine每一个partition上具有相同key的输出结果。<br><a id="more"></a><br>看下图我们就能理解<code>reduceByKey</code>的工作流程。我们注意到同一台机器上数据shuffle之前，相同key的数据（通过调用传入<code>reduceByKey</code>的lambda函数）Combine在一起的，然后再一次调用这个lambda函数去reduce来自各个partition的全部值，从而得到最终的结果。  </p>
<p><img src="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/images/reduce_by.png" alt="ReduceByKey"></p>
<p>另一方面，当调用<code>groupByKey</code>的时候，所有的键值对都会进行shuffle，这将增加很多无谓的数据进行网络传输。</p>
<p>为了确定哪台机器将接受Shuffle后的键值对，Spark会针对该键值对数据的key调用一个分区函数。当某一台executor机器上的内存不足以保存过多的Shuffle后数据时，Spark就会溢写数据到磁盘上。然而，这种溢写磁盘会一次性将一个key的全部键值对数据写入磁盘，因此如果一个key拥有过多键值对数据——多到内存放不下时，将会抛出Out Of Memory异常。在之后发布的Spark中将会更加优雅地处理这种情况，使得这个job仍会继续运行，但是我们仍然需要避免（使用<code>groupByKey</code>）。<strong>当Spark需要溢写磁盘的时候，它的性能将受到严重影响</strong>。</p>
<p><img src="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/images/group_by.png" alt="GroupByKey"></p>
<p>如果你有一个非常大的数据集，那么<code>reduceByKey</code>和<code>groupByKey</code>进行shuffle的数据量之间的差异将会更加夸张。</p>
<p>下面是一些你可以用来替代<code>groupByKey</code>的函数：<br>1）当你在combine数据但是返回的数据类型因输入值的类型而异时，你可以使用<code>combineByKey</code>；<br>2）如果key使用到结合函数和“零值”，你可以用<code>foldByKey</code>函数合并value；</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>原文：<a href="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/best_practices/prefer_reducebykey_over_groupbykey.html">Avoid GroupByKey</a></p>
<h3 id="译文">译文</h3><p>让我们来看两个wordcount的例子，一个使用了<code>reduceByKey</code>，而另一个使用<code>groupByKey</code>:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">words</span> =</span> <span class="type">Array</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordPairsRDD</span> =</span> sc.parallelize(words).map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithReduce</span> =</span> wordPairsRDD</span><br><span class="line">                           .reduceByKey(_ + _)</span><br><span class="line">                           .collect()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithGroup</span> =</span> wordPairsRDD</span><br><span class="line">                          .groupByKey()</span><br><span class="line">                          .map(t =&gt; (t._1, t._2.sum))</span><br><span class="line">                          .collect()</span><br></pre></td></tr></table></figure></p>
<p>上面两个函数所得到的结果都是正确的，但是当数据集很大时，使用了<code>reduceByKey</code>的例子表现更佳。这是因为在shuffle输出的数据前，Spark会Combine每一个partition上具有相同key的输出结果。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="Spark" scheme="http://leotse90.com/tags/Spark/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ElasticSearch初探]]></title>
    <link href="http://leotse90.com/2015/11/01/ElasticSearch%E5%88%9D%E6%8E%A2/"/>
    <id>http://leotse90.com/2015/11/01/ElasticSearch初探/</id>
    <published>2015-11-01T14:05:15.000Z</published>
    <updated>2015-11-01T14:29:49.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES介绍">ES介绍</h2><p>我们首先来看<a href="https://www.elastic.co" target="_blank" rel="external">ES</a>（全称是Elastic Search）到底是什么，下面是Wikipedia给出的定义：</p>
<blockquote>
<p>Elasticsearch is a search server based on Lucene. It provides a distributed, multitenant-capable full-text search engine with a RESTful web interface and schema-free JSON documents. Elasticsearch is developed in Java and is released as open source under the terms of the Apache License. Elasticsearch is the second most popular enterprise search engine after Apache Solr.</p>
</blockquote>
<p>百度上给出了中文版定义：</p>
<blockquote>
<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是第二流行的企业搜索引擎。</p>
</blockquote>
<p>在这段定义之外，我们看看ES还有哪些吸引人的地方：<br><a id="more"></a><br>1）ES的搜索几乎是实时的，当你向一个ES服务器或者一个ES集群发出搜索请求后，你可以在非常短的延迟后获取到你想要的数据（不超过1s）；<br>2）ES的集群是去中心化的，也就是说，不像Hadoop这种分布式框架，ES集群不存在单点故障。ES集群中包含多个节点，节点可以通过选举选出它们的中心节点，因此，当集群中的一个节点出现故障时，集群马上会选取出下一个新的中心节点来管理集群；<br>3）ES的横向扩展性能非常好，集群维护者不用担心集群出现资源不够的情况，因为你只需要增加一台服务器，然后在其上安装ES然后简单进行配置，这台新的节点就能成为集群中的一员；<br>4）ES提供了分片机制（Shard），一个索引（Index）可以划分为多个Shard，这些Shard分布在集群中不同的节点上，能有效提升集群的处理效率；<br>5）ES为其中的数据提供了replica，确保数据的冗余存储，从而使得整个ES集群可用性大大增强，亦即当一个节点出现故障时，存储在其上的数据仍然可以在其他的节点上访问到；<br>6）ES简单易用，除了为开发者和使用者提供了RESTful接口外，ES本身非常易于学习和使用，这一点在应用中你可以感受到。它的社区也十分活跃，相关的文档资料也较健全。</p>
<p>这些点足以让我们拥有信心在需要的时候投入ES的怀抱，当然我们还需要考虑ES的一些不足，在本人的了解范围里以及结合本人的使用经验，ES集群可能存在以下问题：  </p>
<p><strong>脑裂问题</strong>：ES集群有可能在节点间网络通信故障时成为“裂脑人”。这是ES集群的去中心化带来的不足。我们假设这样一个场景，我们的ES集群有10个节点，它们分别在两个机房A和B，有一天机房的网络出现问题，A机房无法与B机房进行通信，这时候，ES的选举机制会被触发，A机房会选取出一个中心节点，B机房也会选取出一个中心节点，整个集群一分为二，虽然对外提供访问时仍然问题不大，但是这两个集群会出现数据不同步的问题；  </p>
<p><strong>权限管理机制不健全</strong>：迄今为止，ES集群没有比较健全的权限管理机制，如果你需要对ES的访问和使用权限进行管理，或者你需要为ES集群提供一个前端web服务，那么你需要在后台自行实现一个权限管理机制。</p>
<h2 id="ES相关概念">ES相关概念</h2><p>我们这里只介绍ES的一些相关的术语，在此之前，我们结合关系型数据库来简单介绍一下ES的结构：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Relational DB <span class="subst">-&gt; </span>Databases <span class="subst">-&gt; </span>Tables <span class="subst">-&gt; </span><span class="keyword">Rows</span> <span class="subst">-&gt; </span>Columns</span><br><span class="line">Elasticsearch <span class="subst">-&gt; </span>Indices   <span class="subst">-&gt; </span>Types  <span class="subst">-&gt; </span>Documents <span class="subst">-&gt; </span>Fields</span><br></pre></td></tr></table></figure></p>
<p>理解ES的结构本身不难，但是由于ES的这些术语在我们的圈子里已经有一些其他的受众较广的含义，所以这样一种与RDB的对比可以帮助我们理解ES的结构，ES本身可以想象成一个MySQL，ES中的Index就是数据库DB，而Type相当于数据库中的表，以此类推。</p>
<p><strong>索引Index</strong>:在ES中，Document中的所有字段都会建立索引（这里的索引是我们平常所理解的意思，如数据库的索引），这种设定使得ES中的每个文档的每个字段都是可以直接用来搜索的。事实上，我们的数据被存储和索引在分片中，索引只是一个把一个或多个分片分组在一起的逻辑空间。</p>
<p><strong>分片Shard</strong>:我们可以将ES中的分片Shard理解为HDFS中的文件块Block，一个完整的Index可以划分为多个Shard，然后分别存储在不同的节点上；</p>
<p><strong>类型Type</strong>:我们能够自己定义ES中的Type，Type是Index的一个逻辑分区，每个类型都有自己的映射或者结构定义，就像传统数据库表中的列一样；</p>
<p><strong>文档Document</strong>:如果你的Tool Kit中有OOP，那么你可以简单将Document理解为对象Object，它是ES中可被索引的基础信息单元；Type是序列化为JSON格式的数据。</p>
<p><strong>映射Mapping</strong>:ES中的映射相当于数据库中表的定义，映射定义了字段类型，每个字段的数据类型，以及字段被ES处理的方式。映射还用于设置关联到类型上的元数据。</p>
<p>这里只简单介绍了ES相关的基础信息，万里长征这才是第一步，但是希望这些信息可以让我们对ES有一个比较清晰的理解，至于如何使用ES进行存储数据、查询数据以及分析数据，我们需要在实践上不断学习和参悟。</p>
<p>最后推荐一本书，希望能帮助到各位学习和理解ES：<a href="http://es.xiaoleilu.com/index.html" target="_blank" rel="external">Elasticsearch 权威指南</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES介绍">ES介绍</h2><p>我们首先来看<a href="https://www.elastic.co">ES</a>（全称是Elastic Search）到底是什么，下面是Wikipedia给出的定义：</p>
<blockquote>
<p>Elasticsearch is a search server based on Lucene. It provides a distributed, multitenant-capable full-text search engine with a RESTful web interface and schema-free JSON documents. Elasticsearch is developed in Java and is released as open source under the terms of the Apache License. Elasticsearch is the second most popular enterprise search engine after Apache Solr.</p>
</blockquote>
<p>百度上给出了中文版定义：</p>
<blockquote>
<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是第二流行的企业搜索引擎。</p>
</blockquote>
<p>在这段定义之外，我们看看ES还有哪些吸引人的地方：<br>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之数组]]></title>
    <link href="http://leotse90.com/2015/10/26/Scala%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://leotse90.com/2015/10/26/Scala学习之数组/</id>
    <published>2015-10-26T13:10:22.000Z</published>
    <updated>2015-11-01T11:32:51.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>我们从这里开始接触Scala中的数据结构，我们首先来看最基础却非常有用的数据结构——数组。<br>这里会涉及两种数组：定长数组以及可变数组，顾名思义，定长数组就是数组在声明的时候就固定了大小，而可变数组可以根据我们使用的实际情况进行调整数组的长度。在Scala中，定长数组为Array，而可变数组为ArrayBuffer。</p>
<h2 id="定长数组">定长数组</h2><p>我们先来看定长数组。声明一个定长数组有以下两种方式：<br><strong>1.声明数组的类型与长度</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr1</span> =</span> <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">arr1: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们用<code>new</code>关键字来声明一个Array对象，用来存储4个Int类型的数值，而这4个Int类型的数值初始值都为0。想必这点大家都很容易理解，类似的，String类型的初始值为null，Double类型的初始值为0.0。<br><a id="more"></a><br><strong>2.声明数组时直接提供初始值</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr2</span> =</span> <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">arr2: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr3</span> =</span> <span class="type">Array</span>(<span class="number">2</span>, <span class="string">"hello"</span>)</span><br><span class="line">arr3: <span class="type">Array</span>[<span class="type">Any</span>] = <span class="type">Array</span>(<span class="number">2</span>, hello)</span><br></pre></td></tr></table></figure></p>
<p>我们在这种声明方式中，无需使用<code>new</code>关键字，Scala会根据初始值的类型来推断出数组的类型，当数组存在多种类型时，此时数组的类型为这多种类型的最近公共父类。</p>
<p>另外，我们在这里还可以注意到，我们在声明数组的时候使用了关键字<code>val</code>，即数组为常量，但是实际上，这里的数组元素都是可以改变值的。这时候，我们可以将<code>val</code>定义的数组理解为：我们用<code>val</code>来指定arr1这个容器只能用来存储4个Int类型的数字，多了不行，其他类型的也不行，但是这4个Int类型的数字究竟是什么，声明方表示并不关心。</p>
<p>我们用<code>(location)</code>来访问数组中的元素。并且可以直接赋值给数组中的元素：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; arr2(<span class="number">0</span>)</span><br><span class="line">res12: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; arr2(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scala&gt; arr2</span><br><span class="line">res14: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="可变数组">可变数组</h2><p>有时候，我们在一开始声明的时候只知道我们需要数组这种容器，但是具体要放多少数据我们暂且不知道，这时候我们需要用到可变数组（又称为数组缓冲）ArrayBuffer。ArrayBuffer的声明和Array并没有太大的差异。<br>不过，在实际使用ArrayBuffer前，需要导入相关的包依赖：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br></pre></td></tr></table></figure></p>
<p>下面我们来看ArrayBuffer的声明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arrbuf1</span> =</span> <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]</span><br><span class="line">arrbuf1: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>()</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arrbuf2</span> =</span> <span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">arrbuf2: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arrbuf3</span> =</span> <span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="string">"hello"</span>)</span><br><span class="line">arrbuf3: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Any</span>] = <span class="type">ArrayBuffer</span>(<span class="number">1</span>, hello)</span><br></pre></td></tr></table></figure></p>
<p>和数组Array一样，可变数组也使用<code>(location)</code>来访问数组的元素；并且，ArrayBuffer使用<code>+=</code>来添加元素，使用<code>++=</code>来实现对其他集合的扩展。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; arrbuf2(<span class="number">0</span>)</span><br><span class="line">res18: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2</span><br><span class="line">res20: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2 += <span class="number">5</span></span><br><span class="line">res21: arrbuf2.<span class="keyword">type</span> = <span class="type">ArrayBuffer</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2 ++= <span class="type">Array</span>(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">res22: arrbuf2.<span class="keyword">type</span> = <span class="type">ArrayBuffer</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>其他的一些有关Array以及ArrayBuffer的操作，可以去ScalaDoc上查阅，你可以点击<a href="http://www.scala-lang.org/api/current/#scala.Array" target="_blank" rel="external">Array</a>或者<a href="http://www.scala-lang.org/api/current/#scala.collection.mutable.ArrayBuffer" target="_blank" rel="external">ArrayBuffer</a>。</p>
<h2 id="总结">总结</h2><p>我们到此了解了数组的基本声明和使用方式，关于数组的具体使用需要根据实际需求进行选择。数组的有关知识也不是这几十行文字和代码所能表达得清楚的，以后的博文中会继续介绍Scala中其他的数据结构以及数组的其他的特性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>我们从这里开始接触Scala中的数据结构，我们首先来看最基础却非常有用的数据结构——数组。<br>这里会涉及两种数组：定长数组以及可变数组，顾名思义，定长数组就是数组在声明的时候就固定了大小，而可变数组可以根据我们使用的实际情况进行调整数组的长度。在Scala中，定长数组为Array，而可变数组为ArrayBuffer。</p>
<h2 id="定长数组">定长数组</h2><p>我们先来看定长数组。声明一个定长数组有以下两种方式：<br><strong>1.声明数组的类型与长度</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr1</span> =</span> <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">arr1: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们用<code>new</code>关键字来声明一个Array对象，用来存储4个Int类型的数值，而这4个Int类型的数值初始值都为0。想必这点大家都很容易理解，类似的，String类型的初始值为null，Double类型的初始值为0.0。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之函数]]></title>
    <link href="http://leotse90.com/2015/10/22/Scala%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://leotse90.com/2015/10/22/Scala之函数/</id>
    <published>2015-10-22T10:31:41.000Z</published>
    <updated>2015-11-06T10:40:14.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>今天我们来介绍Scala中的函数的一些基本概念以及用法。  </p>
<h2 id="函数是一等公民">函数是一等公民</h2><p>在Scala中，函数是一等公民。<br>首先来解释一下什么是<em>一等公民</em>，它指的是在程序中可无限使用的对象。<br>那么”函数是Scala的一等公民“这句话怎么理解呢？一言蔽之，就是函数能作为实参，还能作为返回值，它能作为一个普通变量进行使用。详细一点来说，Scala中函数作为一等公民的主要表现有：  </p>
<ul>
<li>可以传递和赋值</li>
<li>嵌套函数</li>
<li>匿名函数</li>
<li>高阶函数</li>
<li>闭包<a id="more"></a>
<h2 id="函数">函数</h2>我们来正式介绍Scala中的函数，先看函数的主要构成，和其他编程语言一样，函数主要由：<strong>函数名</strong>、<strong>参数</strong>以及<strong>函数体</strong>三部分组成。下面我们会从这三个方面介绍Scala中的函数。下面是一个函数的示例：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(</span>x: <span class="type">Int</span>) = println(x)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数名">函数名</h3><p>关于函数名，没有太多需要介绍的，和其他编程语言一样，支持数字、字母以及下划线，$符号，同样的，数字不能放在函数名第一位。一般建议，函数命名采用驼峰风格（小驼峰）。  </p>
<h3 id="参数">参数</h3><p>接下来是参数，在Scala中，所有的参数必须指定类型。在某些情况下，函数的参数可以有默认值，我们称之为默认参数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">func</span>(</span>x: <span class="type">Int</span>, y: <span class="type">Int</span> = <span class="number">3</span>) = x + y</span><br><span class="line">func: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; func(<span class="number">2</span>)</span><br><span class="line">res14: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">scala&gt; func(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">res15: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">scala&gt; func(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&lt;console&gt;:<span class="number">16</span>: error: too many arguments <span class="keyword">for</span> method func: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line">       func(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; func(y=<span class="number">2</span>, x=<span class="number">6</span>)</span><br><span class="line">res17: <span class="type">Int</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>我们需要注意，如果我们传入的参数数量和函数的参数数量不一致(不能多于函数的参数数量)，函数会从左到右依次将值传给参数。但是当你在传参时指定了参数名（带名参数），那么参数的顺序就不再重要。  </p>
<p>如果我们的参数长度未知，这时我们可以使用变长参数。变长参数实际上是一个类型为Seq的参数（Seq是一个有先后顺序的值的序列，比如数组或者列表）。但是你不能直接将值的序列当成参数传给函数（特指参数为变长参数的函数）。我们看下面的代码便能明白变长参数的使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">toStr</span>(</span>args: <span class="type">String</span> *) = args.mkString(<span class="string">","</span>)</span><br><span class="line">toStr: (args: <span class="type">String</span>*)<span class="type">String</span></span><br><span class="line"></span><br><span class="line">scala&gt; toStr(<span class="string">"leotse"</span>, <span class="string">"yolovon"</span>)</span><br><span class="line">res20: <span class="type">String</span> = leotse,yolovon</span><br><span class="line"></span><br><span class="line">scala&gt; toStr(<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>)</span><br><span class="line">res21: <span class="type">String</span> = <span class="type">One</span>,<span class="type">Two</span>,<span class="type">Three</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数体">函数体</h3><p>在上面的示例中，我们已经多次见过Scala中的函数，他们的函数体如果只有一个表达式或者语句，那么直接跟在函数名后即可（有等号=），如果函数体包含多条语句，那么我们可以使用我们以前介绍过的块表达式。</p>
<h3 id="返回值">返回值</h3><p>我们知道，块表达式的值为{…}中的最后一个表达式的值，那么在Scala的函数中，如果没有指定函数的返回值，块表达式的返回值就是块表达式的最后一个语句的值。<strong>一般情况下，我们都不需要显式指定Scala函数的返回值。</strong>当然我们也可以直接指定函数的返回值类型，如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(</span>v1: <span class="type">Int</span>, v2: <span class="type">String</span>): <span class="type">Double</span> = &#123;function body&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里再一次说明了函数是第一等公民，因为我们直接将函数func指定了一个类型Double。</p>
<h2 id="过程">过程</h2><p>在前面介绍函数的时候，我们看到Scala函数和其他编程语言函数定义不同的地方，那就是函数名后面加了一个等号＝。那么这个＝是不是必须的呢？答案是不。如果函数体在块表达式中而且返回值为Unit类型，那么就可以不要这里的＝，我们称这样的函数为<strong>过程</strong>。不过，有人建议我们一般情况下都加上＝号，并且指定函数的返回值类型，哪怕是Unit类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">func1</span> (</span>a: <span class="type">Int</span>, b: <span class="type">Int</span>) &#123;</span><br><span class="line">     |     println(a + b)</span><br><span class="line">     | &#125;</span><br><span class="line">func1: (a: <span class="type">Int</span>, b: <span class="type">Int</span>)<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">scala&gt; func1(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">func2</span> (</span>a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">     |     println(a + b)</span><br><span class="line">     | &#125;</span><br><span class="line">func2: (a: <span class="type">Int</span>, b: <span class="type">Int</span>)<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">scala&gt; func2(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>Scala的函数基础知识暂且告一段落，但是只有多动手试试才能对Scala的函数有更深层次的理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>今天我们来介绍Scala中的函数的一些基本概念以及用法。  </p>
<h2 id="函数是一等公民">函数是一等公民</h2><p>在Scala中，函数是一等公民。<br>首先来解释一下什么是<em>一等公民</em>，它指的是在程序中可无限使用的对象。<br>那么”函数是Scala的一等公民“这句话怎么理解呢？一言蔽之，就是函数能作为实参，还能作为返回值，它能作为一个普通变量进行使用。详细一点来说，Scala中函数作为一等公民的主要表现有：  </p>
<ul>
<li>可以传递和赋值</li>
<li>嵌套函数</li>
<li>匿名函数</li>
<li>高阶函数</li>
<li>闭包]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之控制结构]]></title>
    <link href="http://leotse90.com/2015/10/21/Scala%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://leotse90.com/2015/10/21/Scala控制结构/</id>
    <published>2015-10-21T09:48:25.000Z</published>
    <updated>2015-11-01T11:32:33.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="块表达式">块表达式</h3><p>首先，我们需要了解一下块表达式。我们这样定义块表达式：凡是用{}包含的语句都同属一个块表达式，在Scala中，块表达式的值等于块表达式最后一条语句的值（在Scala中，每一个表达式都有一个值）。我们看下面的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> v = &#123;<span class="keyword">var</span> a = <span class="number">2</span>; <span class="keyword">var</span> b = <span class="number">4</span>; a + b;&#125;</span><br><span class="line">v: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">v1</span> =</span> &#123;<span class="keyword">var</span> s1 = <span class="string">"hello"</span>; <span class="keyword">var</span> i = <span class="number">20</span>;&#125;</span><br><span class="line">v1: <span class="type">Unit</span> = ()</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以总结以下两点：1.块表达式的值由{…}中的最后一条语句的值决定，那么当我们在定义一个函数的时候，一般不需要定义返回值，因为最后一条语句的值就是这个块表达式的值；2.侧面反映了Scala中赋值语句的值为Unit类型（注：Scala中的Unit类型相当于Java中的void，其只有一个值()）。<br><a id="more"></a></p>
<h3 id="条件表达式">条件表达式</h3><p>条件表达式的作用就不赘述，我们直接来介绍Scala中的条件表达式。它的一般形式如下：<br><code>if (expression) block1 else block2</code><br>值得注意的是，Scala虽然和Java一样，判断条件expression需要为Boolean类型，但是和其他一些语言不一样的是，在Scala中，只有真正的Boolean类型：true或者false能作为判断的依据，而正整数、非空字符串等不能表示true，同理，整数0、空字符串等亦不能表示false。看下面的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">if</span> (<span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span>;</span></span><br><span class="line"> found   : <span class="type">Int</span>(<span class="number">1</span>)</span><br><span class="line"> required: <span class="type">Boolean</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">           ^</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">if</span> (<span class="string">""</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span>;</span></span><br><span class="line"> found   : <span class="type">String</span>(<span class="string">""</span>)</span><br><span class="line"> required: <span class="type">Boolean</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">""</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">           ^</span><br></pre></td></tr></table></figure></p>
<p>在Scala中，我们可以将条件表达式的值直接赋给一个变量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">r</span> =</span> <span class="keyword">if</span> (<span class="string">"hello"</span> &gt; <span class="string">"world"</span>) <span class="string">"hello"</span> <span class="keyword">else</span> <span class="string">"world"</span></span><br><span class="line">r: <span class="type">String</span> = world</span><br></pre></td></tr></table></figure></p>
<p>这种用法熟悉Python的coder可能会比较容易接受，Scala这种设计可能会使得代码在阅读起来并没有那么友善，但是确实可以使得我们的代码更简洁。</p>
<p>另外，Scala并不支持switch语句，因此如果我们有模式匹配上的需求，我们需要用到Scala提供的更强大的模式匹配机制，感兴趣的朋友可以先行了解一下。</p>
<h3 id="循环表达式">循环表达式</h3><p>和Java一样，Scala提供了两种循环表达式：while以及for。<br>通常，函数式语言会避开while循环，因为while实现的大多数操作都可以使用递归来完成。Scala中while循环和Java类似：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> x = <span class="number">3</span></span><br><span class="line">x: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     |     println(x)</span><br><span class="line">     |     x -= <span class="number">1</span></span><br><span class="line">     | &#125;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>Scala中的for循环却和Java中的不太一样，在形式上有较大的改变，有一种观点认为：“Scala 的for实际上是一条管道，它在将元素传递给循环主体之前处理元素组成的集合，每次一个。此管道其中的一部分负责将更多的元素添加到管道中（生成器），一部分负责编辑管道中的元素（过滤器），还有一些负责处理中间的操作（比如记录）。”：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">4</span>) print(i + <span class="string">" "</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">```  </span><br><span class="line">这段代码等同于：  </span><br><span class="line">```scala</span><br><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">4</span>) &#123;</span><br><span class="line">     |     print(i + <span class="string">" "</span>)</span><br><span class="line">     | &#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们看到<code>for (i &lt;- 1 to 4)</code>这种形式的表达式，这条表达式的意思是我们从1到4进行一个遍历，然后将这些值依次赋予变量i。更普遍的for定义是<code>for (v &lt;- expression)</code>，也就是将expression每次生成的值赋给变量v。我们看到<strong>在for循环的变量v之前并没有var或者val，此时，v的类型是集合的元素类型。</strong></p>
<p>这种循环便利非常方便，比如我们要遍历一个字符串：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (c &lt;- <span class="string">"hello, scala"</span>) print(c + <span class="string">"-"</span>)</span><br><span class="line">h-e-l-l-o-,- -s-c-a-l-a-</span><br></pre></td></tr></table></figure></p>
<p>我们还可以这样遍历其他诸如数组、集合之类。</p>
<p>for循环表达式还有更加先进的使用方法，我们称之为<em>for推导式</em>。还是先看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">2</span>; j &lt;- <span class="number">1</span> until <span class="number">3</span>) println((i, j))</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">2</span>; j &lt;- <span class="number">1</span> until <span class="number">3</span> <span class="keyword">if</span> i != j) println((i, j))</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们需要解释一下这段代码，首先额外解释一下to和until的区别，x to y表示从x到y的所有整数，包含y；而x until y表示从x到y的所有整数不包含y（y &gt; x）。我们在这段代码看到，for循环的循环控制语句中有多条表达式，并且以分号分割，每个表达式我们称之为<strong>生成器</strong>，生成器的作用是在每一次循环的时候生成变量的值，控制变量j的赋值语句后跟着<code>if i != j</code>，这是一个<strong>守卫</strong>，守卫用以过滤符合条件的控制变量。</p>
<p>到这里为止，我们已经对Scala的控制结构有一个大致的了解。在实际编码中，我们会看到更灵活、更强大的控制结构使用方法，但是万变不离其宗，它们都是基于这些基本的控制结构形式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="块表达式">块表达式</h3><p>首先，我们需要了解一下块表达式。我们这样定义块表达式：凡是用{}包含的语句都同属一个块表达式，在Scala中，块表达式的值等于块表达式最后一条语句的值（在Scala中，每一个表达式都有一个值）。我们看下面的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> v = &#123;<span class="keyword">var</span> a = <span class="number">2</span>; <span class="keyword">var</span> b = <span class="number">4</span>; a + b;&#125;</span><br><span class="line">v: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">v1</span> =</span> &#123;<span class="keyword">var</span> s1 = <span class="string">"hello"</span>; <span class="keyword">var</span> i = <span class="number">20</span>;&#125;</span><br><span class="line">v1: <span class="type">Unit</span> = ()</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以总结以下两点：1.块表达式的值由{…}中的最后一条语句的值决定，那么当我们在定义一个函数的时候，一般不需要定义返回值，因为最后一条语句的值就是这个块表达式的值；2.侧面反映了Scala中赋值语句的值为Unit类型（注：Scala中的Unit类型相当于Java中的void，其只有一个值()）。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之入门]]></title>
    <link href="http://leotse90.com/2015/10/20/Scala%E5%85%A5%E9%97%A8/"/>
    <id>http://leotse90.com/2015/10/20/Scala入门/</id>
    <published>2015-10-20T02:55:15.000Z</published>
    <updated>2015-11-01T11:31:54.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="为什么是Scala">为什么是Scala</h3><p>有人问Java之父James Gosling“除了Java语言以外，您现在还使用JVM平台上的哪种编程语言？”，他毫不犹豫的回答“Scala”。</p>
<blockquote>
<p>During a meeting in the Community Corner (java.net booth) with James Gosling, a participant asked an interesting question:”Which Programming Language would you use now on top of JVM, except Java?”. The answer was surprisingly fast and very clear: - Scala.</p>
</blockquote>
<p>可见，Scala是一门很受待见的编程语言，另一位大牛Horstmann指出，Scala试图将以下三组对立的思想融合在一门编程语言中:</p>
<blockquote>
<p>函数式编程 VS 面向对象编程<br>富有表达力的语法 VS 静态类型<br>高级的语言特性 VS 与Java高度集成</p>
</blockquote>
<p>这样看来，Scala就是想集各家所长，打造一种平衡的和谐，这看起来像是编程语言世界的乌邦托。<br><a id="more"></a><br>Scala和很多在Java基础上发展的语言一样，需要基于JVM，这一点使得Scala拥有强大的Java所拥有的特性，比如跨平台。但是成也JVM，败也JVM，JVM启动较慢的问题，需要编译等等这些也成为了Scala的瓶颈。只要还立足于JVM，Scala就一直会受到JVM的限制。<br>但是这些都无碍于Scala本身成为一门成功的语言，现在很多公司都已经逐渐投靠Scala阵营，比如twitter，特别是当使用Scala编写的Spark兴起之后，Scala更是成为很多公司大数据编程语言的首选。  </p>
<h3 id="REPL">REPL</h3><p>首先，我们需要认识一下REPL，全称为Read-Eval-Print-Loop，亦即读取－求值－打印－循环。如果是第一次接触这个概念，会觉得有点奇怪，我们可以将REPL称为<strong>交互式解释器</strong>。一般的，我们通过REPL可以快速学习和验证一门语言的特性（前提是这门语言支持REPL）。<br>但是并不是所有的语言都支持REPL，常见的编程语言支持REPL的有Ruby、Python、Lua，使用很广的Java、C++、C#、PHP以及JS等并不支持原生的REPL。当然，我们既然在这里讨论REPL，Scala是肯定支持REPL的。我们在学习Scala的时候可以直接在REPL coding。实际上，我们敲进去的代码首先被编译，然后JVM会执行编译后的字节码，然后返回执行的结果。</p>
<p>我们看一个示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="string">"Hello, Scala"</span></span><br><span class="line">res0: <span class="type">String</span> = <span class="type">Hello</span>, <span class="type">Scala</span></span><br></pre></td></tr></table></figure></p>
<p>从这个示例中，我们可以看到输入的是文本“Hello, Scala”，下面一行是输出，这里的res0是REPL为这个文本起的名字，后面的String表明这个文本是字符串类型。我们可以直接使用res0这个变量名去调用这个字符串文本。</p>
<h3 id="val和var">val和var</h3><p>在上一小节里面，我们已经见识到了Scala的变量声明，但是，我们一般情况下都希望将变量命名的权力牢牢控制在自己手上，因此我们可以使用以下方式声明变量。<br><strong>var</strong>：variable的缩写。用法如下：<br><code>var variable_name: [variable_type] = variable_value</code><br>变量的类型是可选的，因为如果没有指定变量的类型，Scala的编译器会根据变量的值推断出它的类型。我们看下面的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">1</span>  <span class="comment">// 指定x的类型为Int</span></span><br><span class="line">x: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; x = <span class="number">2</span>  <span class="comment">// 改变变量x的值</span></span><br><span class="line">x: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">var</span> y = <span class="number">3</span>  <span class="comment">// 没有指定y的类型</span></span><br><span class="line">y: <span class="type">Int</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p><strong>val</strong>：这里说变量其实不太准确，因为val声明的是不可变的常量。使用方法和var类似，只是不能修改它的值。在实际开发中，除非我们可以预知需要改变一个值的内容，否则我们一般用val声明。示例如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">z</span> =</span> <span class="number">3</span></span><br><span class="line">z: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt; z = <span class="number">2</span>  <span class="comment">// 不可以修改一个常量的值</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: reassignment to <span class="function"><span class="keyword">val</span></span></span><br></pre></td></tr></table></figure></p>
<p>一般的，我们不需要声明类型，除非必须。而且我们注意到Scala和Java等语言不一样，变量的类型声明在变量名后面。</p>
<p>我这里引用一段前辈说过的话，里面说明了使用val以及var的场景以及原因：  </p>
<blockquote>
<p><em>Scala 编程人员通常应该首选 val 结构，并在明确需要可变性的时候选择 var。原因很简单：除了使编程更容易之外，val 还能确保程序的线程安全性，Scala 中的一个内在主题是：几乎每次认为需要可变状态时，其实都不需要可变状态。 让我们从不可变字段和本地变量（val）开始，这是展示上述情况的一种方法，甚至对最坚定的 Java 怀疑论者也是如此。从 Java 中的 final 开始介绍可能不是很合理，或许是因为 Java 的非函数特性，尽管此原因不可取。一些好奇的 Java 开发人员可能想尝试一下。</em></p>
</blockquote>
<p>另外，我们在REPL中的示例中可以看到，解释器为我们没有命名的变量定义res0这个名字，凡是解释器定义的变量，如res0、res1等等，都是常量，不可修改:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res0</span><br><span class="line">res1: <span class="type">String</span> = <span class="type">Hello</span>, <span class="type">Scala</span></span><br><span class="line"></span><br><span class="line">scala&gt; res0 = <span class="number">1990</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: reassignment to <span class="function"><span class="keyword">val</span></span></span><br></pre></td></tr></table></figure></p>
<p>在Scala中，有8种类型，它们分别为Boolean、Byte、Char、Short、Int、Long、Float以及Double。在这里，我们和Java那样称它们为八大基本类型，因为Scala中并不会刻意去区分基本类型和引用类型，因为他们都是类。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="为什么是Scala">为什么是Scala</h3><p>有人问Java之父James Gosling“除了Java语言以外，您现在还使用JVM平台上的哪种编程语言？”，他毫不犹豫的回答“Scala”。</p>
<blockquote>
<p>During a meeting in the Community Corner (java.net booth) with James Gosling, a participant asked an interesting question:”Which Programming Language would you use now on top of JVM, except Java?”. The answer was surprisingly fast and very clear: - Scala.</p>
</blockquote>
<p>可见，Scala是一门很受待见的编程语言，另一位大牛Horstmann指出，Scala试图将以下三组对立的思想融合在一门编程语言中:</p>
<blockquote>
<p>函数式编程 VS 面向对象编程<br>富有表达力的语法 VS 静态类型<br>高级的语言特性 VS 与Java高度集成</p>
</blockquote>
<p>这样看来，Scala就是想集各家所长，打造一种平衡的和谐，这看起来像是编程语言世界的乌邦托。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive之JOIN操作]]></title>
    <link href="http://leotse90.com/2015/10/18/Hive%E4%B9%8BJOIN%E6%93%8D%E4%BD%9C/"/>
    <id>http://leotse90.com/2015/10/18/Hive之JOIN操作/</id>
    <published>2015-10-18T02:55:15.000Z</published>
    <updated>2015-10-21T06:41:59.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="Introduction">Introduction</h3><p>在MySQL等关系型数据库中，我们经常会用到联表查询，用以查询多张表的数据。<br>使用联表查询的场景一般是：我们需要对两张或多张表中的数据进行关联，从而得到我们所需要的数据集。  </p>
<p>在Hive中，也存在这样的场景，特别是进行数据分析的时候，但是，Hive虽然支持Hive JOIN语句，但是<strong>只限于等值连接</strong>，也就是说，只支持a.col=b.col而不支持a.col &gt;= b.col这类的条件，主要原因是通过MapReduce很难实现这种类型的联接。</p>
<p>接下来，我们将分析和介绍Hive中主要的JOIN操作。<br><a id="more"></a><br>我们假定我们有两张表：human和assets。它们分别记录了人口以及资产信息，它们的字段如下：<br><code>hive&gt; describe human;</code><br><code>OK</code><br><code>name                    string</code><br><code>age                     int</code><br><code>job                     string</code><br><code>addr                    string</code>  </p>
<p><code>hive&gt; describe assets;</code><br><code>OK</code><br><code>name                    string</code><br><code>bank                    string</code><br><code>fund                    int</code>  </p>
<p>在下面的例子中，将会用到这两张表。</p>
<h3 id="INNER_JOIN">INNER JOIN</h3><p>INNER JOIN，又称内连接。是较为常见的一种JOIN操作：<br><strong>Input</strong>: 表A、表B<br><strong>Condition</strong>: A.col = B.col<br><strong>Output</strong>: 表A和表B中满足Condition的所有数据记录<br><strong>Example</strong>:<br><code>SELECT a.col1, a.col2, b.col2, b.col3</code><br><code>FROM A a JOIN B b</code><br><code>ON a.col1 = b.col1</code><br><code>WHERE a.col3 = &#39;CONDITION&#39;;</code>  </p>
<p>我们来看一个具体的例子，我们想知道human表中每一个人在不同银行的存款记录，我们可以用以下SQL语句进行查询：<br><code>SELECT h.name, h.age, h.job, a.bank, a.fund FROM human h JOIN assets a ON h.name=a.name;</code><br>ON关键字指定了两种表联接的条件，<br>我们对输出结果进行了截取，只选取最终的数据查询记录，如下：<br><code>xiefeng    24    big data    CMB    15000000</code><br><code>leotse    25    programmer    CMB    200000000</code><br><code>leotse    25    programmer    CAB    10000000</code><br><code>yolovon    26    CEO    HB    5000000</code><br><code>yolovon    26    CEO    CCB    3200000</code>  </p>
<p>另外，我们需要注意的是，在Hive中，ON子句中尚不支持谓词OR。</p>
<p>如果我们对多表进行INNER JOIN操作，如:<br><code>SELECT a.col1, a.col2, b.col4, c.col5 FROM a</code><br><code>JOIN b ON a.col1 = b.col2</code><br><code>JOIN c ON a.col2 = c.col3</code><br><code>WHERE CLAUSE;</code><br>大多数情况下，Hive会对每次JOIN操作启动一个MR Job，（在Hive中，SQL的执行是从左至右的）这上面这个SQL语句的执行过程中，首先启动一个MR Job对表a和表b进行一次JOIN操作，然后再启动另一个新的MR Job对表a和表c进行一次JOIN操作。<br>上面说到是大多数情况下，那种小部分的情况是指只要我们使用的ON后的条件（即连接键）一致的话，那就只会产生一个MR Job。</p>
<p>Hive还假定最后一张JOIN的表最大，从而先将前面的表先缓存起来，直到最后一张表才进行计算，因此为了防止内存消耗过大，我们应该尽量保证JOIN操作的表从左到右表大小递增。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="Introduction">Introduction</h3><p>在MySQL等关系型数据库中，我们经常会用到联表查询，用以查询多张表的数据。<br>使用联表查询的场景一般是：我们需要对两张或多张表中的数据进行关联，从而得到我们所需要的数据集。  </p>
<p>在Hive中，也存在这样的场景，特别是进行数据分析的时候，但是，Hive虽然支持Hive JOIN语句，但是<strong>只限于等值连接</strong>，也就是说，只支持a.col=b.col而不支持a.col &gt;= b.col这类的条件，主要原因是通过MapReduce很难实现这种类型的联接。</p>
<p>接下来，我们将分析和介绍Hive中主要的JOIN操作。<br>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://leotse90.com/tags/Hive/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python多进程使用]]></title>
    <link href="http://leotse90.com/2015/10/17/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://leotse90.com/2015/10/17/Python多进程使用/</id>
    <published>2015-10-17T02:55:15.000Z</published>
    <updated>2015-10-23T02:35:40.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Intro">Intro</h2><p>我们知道，由于<a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="external">GIL</a>的关系，Python中多线程并不被看好。因此，Python我们常常使用模块subprocess模块和多进程multiprocessing模块来实现并发。而subprocess因为是调用外部程序而且只是通过管道进行文本交流，因此我们建议在Python并发编程中，尽量使用multiprocessing。  </p>
<p>multiprocessing模块和threading模块很像，该模块同时提供了本地和远程并发，你也不用担心GIL产生的副作用。并且multiprocessing可以在Unix和Windows下使用（区别于为shell而生的subprocess）。<br><a id="more"></a></p>
<h2 id="multiprocessing使用">multiprocessing使用</h2><p>在multiprocessing模块中，我们使用multiprocessing.Process()来创建一个新的进程对象。</p>
<p>一般情况下，我们需要在创建Process对象时指定进程执行的函数，以及该函数的参数：<br><code>process = multiprocessing.Process(target=worker, args=(param1, param2)</code><br>该对象的主要方法有：<br><strong>start()</strong>：启动进程；每个进程最多只能调用一次；<br><strong>run()</strong>：进程的执行逻辑在run()里。如果Process对象没有指定target，就会默认执行Process的run()方法；<br><strong>join([timeout])</strong>：阻塞当前进程，直到调用join方法的那个进程执行完，再继续执行当前进程；<br><strong>is_alive()</strong>：返回该进程是否存活；<br><strong>terminate()</strong>：终结一个进程。当调用这个函数的时候，运行逻辑中的exit和finally代码段将不会执行。而且这个进程的子进程不会被终结而是成为孤儿进程；  </p>
<p>下面我们给出一段多进程使用的示例代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocess</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controller</span><span class="params">()</span>:</span></span><br><span class="line">	processes = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">		process = multiprocessing.Process(target=worker, args=[i])</span><br><span class="line">		processes.append(process)</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.start()</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.join()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(param)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> param</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	controller()</span><br></pre></td></tr></table></figure></p>
<p>我们可以得到如下的输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="子进程通信">子进程通信</h2><p>multiprocessing支持两种类型的进程通信手段，分别是Queue和Pipe。  </p>
<h3 id="Queue">Queue</h3><p>Queue是一种多线程优先队列。它允许多个进程读和写，我们通过<code>mutiprocessing.Queue(maxsize)</code>创建一个Queue，maxsize表示队列中可以存放对象的最大数量。它的一些主要方法有：<br><strong>get()</strong>：删除并返回队列中的一个元素；<br><strong>put()</strong>: 添加元素到队列；<br><strong>qsize()</strong> : 返回队列中元素的个数；<br><strong>empty()</strong>: 队列为空返回True否则返回False；<br><strong>full()</strong>: 队列已满返回True，负责返回False；  </p>
<p>在下面的示例里，我们用Queue实现获取多进程执行时的输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controller</span><span class="params">()</span>:</span></span><br><span class="line">    processes = []</span><br><span class="line">    result_queue = multiprocessing.Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        process = multiprocessing.Process(target=worker, args=[i, result_queue])</span><br><span class="line">        processes.append(process)</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.join()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> result_queue.empty():</span><br><span class="line">        <span class="keyword">print</span> result_queue.get()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(param, result_queue)</span>:</span></span><br><span class="line">    result_queue.put(param + <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    controller()</span><br></pre></td></tr></table></figure></p>
<p>执行这段代码，输出为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">104</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Pipe">Pipe</h3><p>Pipe可以是单向，也可以是双向。我们通过mutiprocessing.Pipe(duplex=False)创建单向管道 (默认为双向)。它主要有send()和recv()两种方法，顾名思义，分别是发送消息和接受消息。<br>我们同样来看一段示例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controller</span><span class="params">()</span>:</span></span><br><span class="line">	processes = []</span><br><span class="line">	parent_conn, child_conn = multiprocessing.Pipe()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">		process = multiprocessing.Process(target=worker, args=[i, child_conn])</span><br><span class="line">		processes.append(process)</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.start()</span><br><span class="line">		<span class="keyword">print</span> parent_conn.recv()</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.join()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(param, child_conn)</span>:</span></span><br><span class="line">	child_conn.send(param + <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	controller()</span><br></pre></td></tr></table></figure></p>
<p>执行这段代码，输出为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">104</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Q&amp;A">Q&amp;A</h2><p>为什么要先依次调用start再调用join，而不是start完了就调用join呢？<br>答：假设我们有两个进程p1，p2，如果我们在p1执行后先join()然后再p2.start()，我们就会发现是先执行完p1，再执行主线程，最后才开始p2。这是因为join是用来阻塞当前线程的，p1.start()之后，p1就提示主线程，需要等待p1结束才向下执行，那主线程就乖乖的等着啦，自然没有执行p2.start()。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Intro">Intro</h2><p>我们知道，由于<a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a>的关系，Python中多线程并不被看好。因此，Python我们常常使用模块subprocess模块和多进程multiprocessing模块来实现并发。而subprocess因为是调用外部程序而且只是通过管道进行文本交流，因此我们建议在Python并发编程中，尽量使用multiprocessing。  </p>
<p>multiprocessing模块和threading模块很像，该模块同时提供了本地和远程并发，你也不用担心GIL产生的副作用。并且multiprocessing可以在Unix和Windows下使用（区别于为shell而生的subprocess）。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://leotse90.com/tags/Python/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】Python中yield关键字用法]]></title>
    <link href="http://leotse90.com/2015/10/15/%E3%80%90%E8%AF%91%E3%80%91Python%E4%B8%ADyield%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/"/>
    <id>http://leotse90.com/2015/10/15/【译】Python中yield关键字用法/</id>
    <published>2015-10-15T02:52:15.000Z</published>
    <updated>2015-10-23T06:29:41.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>本文译自stackoverflow <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="external">What does the yield keyword do in Python?</a></p>
<h2 id="引子">引子</h2><p>这一切始于一位童鞋在Stack Overflow上问的问题：</p>
<p>Python中的yield关键字是用来干嘛的？它都干了些什么？<br><a id="more"></a><br>例如，我试图理解下面这段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</span><br><span class="line">        <span class="keyword">yield</span> self._leftchild</span><br><span class="line">    <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</span><br><span class="line">        <span class="keyword">yield</span> self._rightchild</span><br></pre></td></tr></table></figure></p>
<p>下面是调用代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result, candidates = list(), [self]</span><br><span class="line"><span class="keyword">while</span> candidates:</span><br><span class="line">    node = candidates.pop()</span><br><span class="line">    distance = node._get_dist(obj)</span><br><span class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</span><br><span class="line">        result.extend(node._values)</span><br><span class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>当_get_child_candidates函数被调用时发生了什么？返回了一个list？返回了单个元素？还是它再次被调用了？后面的调用什么时候停止呢？</p>
<p>下面是这个问题的精华回复：</p>
<h2 id="yield关键字用法">yield关键字用法</h2><p>要想理解yield关键字，首先你得理解什么是<strong>生成器</strong>。而在这之前我们先得了解迭代。  </p>
<h3 id="迭代">迭代</h3><p>当你创建了一个list，你就可以逐个元素去读取这个list，这就叫做迭代：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="prompt">... </span>   print(i)</span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>mylist就是可迭代的。当你使用list表达式，你就创建了一个list，亦即创建了一个迭代器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="prompt">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>Python中所有你可以用到”for…in…”表达式的地方都是可迭代的：list，string，files等等。迭代器的优点是你可以读你所需，但是你需要在内存中存储（这些迭代器中的）所有的值，而当我们拥有大量数据时我们并不希望这样做。</p>
<h3 id="生成器">生成器</h3><p>生成器亦即迭代器，但是生成器只能迭代一次。因为它并不会将所有的数据存在内存中，而是实时生成我们所需的数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="prompt">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>这个和你用元组()取代列表[]道理一样。但是，你不能指望<code>for i in mygenerator</code>运行第二次，因为生成器只能被使用一次：它（首先）计算得到0，然后会遗忘0并计算得出1，最终得到4（并遗忘1），以此类推。</p>
<h3 id="yield关键字">yield关键字</h3><p>Yield关键字和return的用法一样，只是（用到yield的）函数将会返回一个生成器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></span><br><span class="line"><span class="prompt">... </span>   mylist = range(<span class="number">3</span>)</span><br><span class="line"><span class="prompt">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="prompt">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="prompt">... </span>    print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子不是太好。但是当你发现你的函数要返回大量只需读一次的数据时你会体会到它（yield）的好处。</p>
<p>要想掌握yield关键字，你必须知道：当你调用这个函数时，函数体里的代码并没有执行，它只是<strong>返回一个生成器对象</strong>，这看起来有点难以理解。</p>
<p>接着，每次你用到这个生成器的时候你的代码都会运行一次。</p>
<p>现在最难的部分来了：</p>
<p>当你第一次调用函数返回的生成器时，它将会运行函数中的代码直到执行到yield，然后它将返回这个循环产生的第一个值。接下来，每一次调用都将执行函数中的这个循环一次，并返回下一个值，直到没有值可以返回为止。</p>
<p>生成器会在函数执行但是没有遇到yield的情况下置空，这可能是因为循环结束了，或者是不再满足”if/else”条件。</p>
<h3 id="问题中的代码解释">问题中的代码解释</h3><p><strong>生成器</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在这里你创建了node对象的一个返回生成器的函数`  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span>`  </span><br><span class="line"> </span><br><span class="line">  <span class="comment"># 下面这段代码将会在每次你使用这个生成器时被调用:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果node对象仍然有一个左child</span></span><br><span class="line">  <span class="comment"># 而且distance满足条件，则返回下一个左child</span></span><br><span class="line">  <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</span><br><span class="line">      <span class="keyword">yield</span> self._leftchild</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果node对象仍然有一个右child</span></span><br><span class="line">  <span class="comment"># 而且distance满足条件，则返回下一个右child</span></span><br><span class="line">  <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</span><br><span class="line">      <span class="keyword">yield</span> self._rightchild</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果这个函数运行到这里了，意味着这个生成器可以看成空的了。</span></span><br><span class="line">  <span class="comment"># 亦即：再也没有符合条件的左右child</span></span><br></pre></td></tr></table></figure></p>
<p><strong>调用方</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空的list和一个包含当前对象引用的list</span></span><br><span class="line">result, candidates = list(), [self]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环处理candidates (最初只有一个元素)</span></span><br><span class="line"><span class="keyword">while</span> candidates:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取最后一个candidate将其移除</span></span><br><span class="line">    node = candidates.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取obj和candidate之间的距离</span></span><br><span class="line">    distance = node._get_dist(obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果距离合适，保存结果在result中</span></span><br><span class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</span><br><span class="line">        result.extend(node._values)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将candidate的子节点保存在candidates中</span></span><br><span class="line">    <span class="comment"># 该循环会一直循环直到遍历了所有的子节点。</span></span><br><span class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>这段代码包含了以下几个很有意思的地方：</p>
<p>1）这个循环在遍历一个list，而这个list会在遍历的过程中增大。虽然存在变成无限循环的风险，但是这仍不失为遍历嵌套数据的好方法。在这里，candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))方法获取了这个生成器的所有元素，但是<code>while</code>在产生新的生成器，它们就会继续生产新的元素，直到换了一个节点。</p>
<p>2）extend()方法是list的一个用于将迭代器的元素追加在list中。<br>一般地，我们传一个list给它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a.extend(b)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p>但是在你给出的代码里，它获取了一个生成器，它有如下几个好处：<br>a.你不需要两次读取这些元素；<br>b.如果你有很多子节点，你不需要把它们都保存在内存中；<br>这个方法很管用，因为Python不关心你传入的参数是不是一个list。Python只关心参数是否是可迭代的如字符串、list、元组以及生成器。这叫做<a href="http://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">鸭子类型</a>，这也是Python为何如此赞的一个原因。但是这些都不在我们的讨论范围内。</p>
<p>你可以到此结束，也可以接着看下面生成器的一些高级用法：</p>
<h3 id="控制生成器">控制生成器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span> <span class="comment"># let's create a bank, building ATMs</span></span><br><span class="line"><span class="prompt">... </span>   crisis = <span class="keyword">False</span></span><br><span class="line"><span class="prompt">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="prompt">... </span>       <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</span><br><span class="line"><span class="prompt">... </span>           <span class="keyword">yield</span> <span class="string">"$100"</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hsbc = Bank() <span class="comment"># when everything's ok the ATM gives you as much as you want</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line">[<span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">True</span> <span class="comment"># crisis is coming, no more money!</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class="comment"># it's even true for new ATMs</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(wall_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">False</span> <span class="comment"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class="comment"># build a new one to get back in business</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</span><br><span class="line"><span class="prompt">... </span>   <span class="keyword">print</span> cash</span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果想要控制对资源的访问，这将非常受用。</p>
<h3 id="itertools，你上佳的朋友">itertools，你上佳的朋友</h3><p>itertools模块包含了操纵迭代的一些特殊的函数。你是不是曾经想过复制一个生产器？串联两个生成器？抑或在线性时间内将嵌套list中的元素分组？或者不依赖创建新list的情况下map/zip？</p>
<p>那么，你只要导入itertools模块就行了。</p>
<p>想要看个例子？让我们看看四匹马到达终点的可能顺序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(races)</span><br><span class="line">&lt;itertools.permutations object at <span class="number">0xb754f1dc</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p>
<h3 id="理解迭代的内部机制">理解迭代的内部机制</h3><p>迭代是实现迭代（实现了__iter__()函数）和迭代器（实现了__next__()函数）的过程。你可以从可迭代对象上获取一个迭代器，而迭代器是你可以迭代的对象。</p>
<p>想要了解更多，你可以看看这篇<a href="http://effbot.org/zone/python-for-statement.htm" target="_blank" rel="external">文章</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>本文译自stackoverflow <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python">What does the yield keyword do in Python?</a></p>
<h2 id="引子">引子</h2><p>这一切始于一位童鞋在Stack Overflow上问的问题：</p>
<p>Python中的yield关键字是用来干嘛的？它都干了些什么？<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://leotse90.com/tags/Python/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python任务调度队列Celery]]></title>
    <link href="http://leotse90.com/2015/10/14/Python%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97Celery/"/>
    <id>http://leotse90.com/2015/10/14/Python任务调度队列Celery/</id>
    <published>2015-10-14T02:55:15.000Z</published>
    <updated>2015-10-23T02:44:03.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Introduction">Introduction</h2><p>在Python的使用过程中，我们常常会遇到执行一些多进程任务，或者一系列长时间的后台任务。比如，多进程下载视频并上传到某一个文件系统中。这时候，我们可以使用任务调度队列帮我们进行任务的分发与管理。</p>
<p>Celery就是这样一个任务队列，易于使用，入门简单。Celery常常需要第三方作为发送和接收消息的中间层，一般我们用到的有RabbitMQ、Redis、MongoDB等等，次等的选择也可以是数据库。</p>
<p>一般推荐使用RabbitMQ，但是我们这里用到Redis，因为Redis安装的时候依赖少，而且性能稳定，但是Redis也有缺点，那就是断电的时候会丢失数据。我们在这里，就以Redis作为Celery的第三方中间层。<br><a id="more"></a></p>
<h2 id="Installation">Installation</h2><p>我们这里使用Celery+redis套餐进行任务的调度。  </p>
<p>Celery的安装非常简单，在linux系统下直接执行：  </p>
<pre>
sudo pip install Celery
sudo pip install celery-with-redis
</pre>
如果上述安装失败，可以尝试：  
<pre>
sudo easy_install Celery
</pre>

<p>我们来验证一下Celery是否安装成功，进入python shell，输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br></pre></td></tr></table></figure></p>
<p>如果没有报错，则说明安装成功。</p>
<p>接着我们安装redis：  </p>
<pre>
sudo apt-get install redis-server
</pre>
安装完成后，redis会自动启动，我们也来验证一下redis是否安装成功：  
<pre>
ps -aux|grep redis
</pre>
如果看到以下输出，则说明安装ok：  
<pre>
redis      942  0.2  0.0  73852  1832 ?        Ssl  Apr13 302:26 /usr/bin/redis-server /etc/redis/redis.conf
</pre>

<p>它们的安装都比较简单。接下来我们看如何使用Celery进行任务调度。</p>
<h2 id="Usage">Usage</h2><p>我们应该都知道生产者-消费者模型，在使用Celery的时候，我们也需要一个生产者和一个消费者，生产者负责往队列里写入待处理的数据，消费者负责将数据从队列中取出并进行处理。我们在这里将redis作为存储这种“数据”的地方。</p>
<p>我们来看这样一个示例，我们假设要下载一批视频v1，v2，v3….，这批视频列表存在另一个文件系统中，我们假设通过get_video_list方法来获取这批视频列表，另一方面，我们可以通过download_video_worker(video)来下载视频。</p>
<p>那么，生产者的伪代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> download_video_worker</span><br><span class="line">video_list = get_video_list()</span><br><span class="line"><span class="keyword">for</span> video <span class="keyword">in</span> video_list: </span><br><span class="line">    download_video_worker.apply_async([video])</span><br></pre></td></tr></table></figure></p>
<p>消费者的伪代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">download_app=Celery(<span class="string">"download_videos"</span>, broker=<span class="string">"redis://localhost:6379/0"</span>)</span><br><span class="line"><span class="decorator">@download_app.task`  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_video_worker</span><span class="params">(video)</span>:</span></span><br><span class="line">    download_video_to_local(video)</span><br></pre></td></tr></table></figure></p>
<p>接着我们运行Celery：  </p>
<pre>
celery -A download_video_worker worker --loglevel=info
</pre>

<p>这样，当我们每次往队列中放入video信息时，celery就会执行download_video_woker中的逻辑处理video的下载过程。</p>
<h3 id="推荐阅读">推荐阅读</h3><p><a href="http://www.celeryproject.org/" target="_blank" rel="external">Homepage - Celery: Distributed Task Queue</a><br><a href="https://denibertovic.com/posts/celery-best-practices/" target="_blank" rel="external">CELERY - BEST PRACTICES</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Introduction">Introduction</h2><p>在Python的使用过程中，我们常常会遇到执行一些多进程任务，或者一系列长时间的后台任务。比如，多进程下载视频并上传到某一个文件系统中。这时候，我们可以使用任务调度队列帮我们进行任务的分发与管理。</p>
<p>Celery就是这样一个任务队列，易于使用，入门简单。Celery常常需要第三方作为发送和接收消息的中间层，一般我们用到的有RabbitMQ、Redis、MongoDB等等，次等的选择也可以是数据库。</p>
<p>一般推荐使用RabbitMQ，但是我们这里用到Redis，因为Redis安装的时候依赖少，而且性能稳定，但是Redis也有缺点，那就是断电的时候会丢失数据。我们在这里，就以Redis作为Celery的第三方中间层。<br>]]>
    
    </summary>
    
      <category term="Celery" scheme="http://leotse90.com/tags/Celery/"/>
    
      <category term="Python" scheme="http://leotse90.com/tags/Python/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive浮点数比较与计算]]></title>
    <link href="http://leotse90.com/2015/10/12/Hive%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <id>http://leotse90.com/2015/10/12/Hive浮点数比较与计算/</id>
    <published>2015-10-12T02:55:15.000Z</published>
    <updated>2015-10-21T06:42:33.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="Hive浮点数比较">Hive浮点数比较</h3><p>Hive的较早前版本（0.9.0）在比较浮点数时会出现问题，如下：<br><code>hive&gt; select * from float_compare where weight&gt;120.9;</code><br><code>OK</code><br><code>xiefeng 128.2</code><br><code>yolovon 121.8</code><br><code>leotse 120.9</code><br>我们可以看到，leotse乱入了，他的weight等于120.9，这一点与我们的预期不符合。设想一下，如果这些数据不是weight而是money，那么结果就会变成后果。这是Hive的一个BUG，我们在Hive的issues上可以看到<a href="https://issues.apache.org/jira/browse/HIVE-2586" target="_blank" rel="external">Float comparison doesn’t work</a>。这个问题已经解决了，但是我们仍然可以分析一下其他的原因。<br><a id="more"></a><br>在float_weight表中，weight以float类型保存。当我们在HiveQL语句输入120.9时，Hive会将其保存为double类型，这样我们看看120.9分别在这两种类型的表示：<br><code>float 120.9000001</code><br><code>double 120.900000000001</code><br>我们知道，在比较float和double类型数值时，float会强制转型为double。这样当float_compare表中数值120.9在和HQL中120.9比较时，前者会转型为120.900000100000。我们可以看到120.900000100000&gt;120.900000000001。这也就是为什么leotse会出现在查询结果的原因。</p>
<p>虽然这个问题已经解决，但是仍然给我们一些启示，当我们在进行浮点数比较的时候，需要警惕float和double的自动转型，特别需要避免从窄类型数值向宽类型数值的转型。</p>
<h3 id="Hive浮点数计算">Hive浮点数计算</h3><p>相比上面的问题，浮点数的计算也是一个BUG，而且现在还没有解决，<a href="https://issues.apache.org/jira/browse/HIVE-3715" target="_blank" rel="external">float and double calculation is inaccurate in Hive</a>。</p>
<p>为了方便对比，我们先展示出表float_compare中的全部数据：<br><code>hive&gt; select * from float_compare;</code><br><code>OK</code><br><code>dooley 110.0</code><br><code>xiefeng 128.2</code><br><code>leotse    120.9</code><br><code>februus 119.0</code><br><code>yolovon 121.8</code>  </p>
<p>接下来我们将表中的weight的字段除以10，得到如下结果：<br><code>hive&gt; select weight/10 from float_compare;</code><br><code>OK</code><br><code>11.0</code><br><code>12.819999694824219</code><br><code>12.09000015258789</code><br><code>11.9</code><br><code>12.180000305175781</code>  </p>
<p>我们可以看到，除了110.0和120.0这种小数点后为0的，其他浮点数计算的结果都是不符合我们预期的。实际上，这个问题在Hive和Java中都存在（Hive用Java实现），而且所有使用IEEE标准进行浮点数编码的系统都存在这个问题。目前这个没有被解决，在这里摆出来是希望以后在遇到类似的浮点数计算的时候，我们能够长一个心眼，以免出现了谬误还不知道为什么。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="Hive浮点数比较">Hive浮点数比较</h3><p>Hive的较早前版本（0.9.0）在比较浮点数时会出现问题，如下：<br><code>hive&gt; select * from float_compare where weight&gt;120.9;</code><br><code>OK</code><br><code>xiefeng 128.2</code><br><code>yolovon 121.8</code><br><code>leotse 120.9</code><br>我们可以看到，leotse乱入了，他的weight等于120.9，这一点与我们的预期不符合。设想一下，如果这些数据不是weight而是money，那么结果就会变成后果。这是Hive的一个BUG，我们在Hive的issues上可以看到<a href="https://issues.apache.org/jira/browse/HIVE-2586">Float comparison doesn’t work</a>。这个问题已经解决了，但是我们仍然可以分析一下其他的原因。<br>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://leotse90.com/tags/Hive/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive 本地模式]]></title>
    <link href="http://leotse90.com/2015/10/11/Hive%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://leotse90.com/2015/10/11/Hive本地模式/</id>
    <published>2015-10-11T02:55:15.000Z</published>
    <updated>2015-10-21T06:42:20.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>我们都知道，Hive是通过将HiveQL转化为MR job进行数据查询和处理。当然，不是全部的HQL语句都需要转为MR，比如我们常见的：<br><code>SELECT * FROM access_log;</code><br>这时候，Hive Shell能很快地返回给我们结果，这是因为这里用到的是Hive的<strong>本地模式</strong>。<br>Hive查询耗时太长，一直都是大家吐槽的对象，在数据量大的情况下，当然微不足道，但是当我们的查询量很小亦即查询数据很少的时候，Hive启动的耗时将会显得非常刺眼，因此在0.7版本以后，Hive开始支持本地模式。</p>
<p>除了上面的示例使用到了本地模式，如果WHERE语句中只是分区字段这种情况，也是无需使用MR job的：<br><code>SELECT * FROM access_log</code><br><code>WHERE dt=&#39;20150916&#39;</code><br><code>LIMIT 10;</code><br>这是因为分区字段在HDFS中保存实际上是目录结构，这些都是不用通过计算获取的（包含LIMIT）。<br><a id="more"></a><br>除此之外，我们还可以怎么利用本地模式帮助我们快速处理少量数据呢？我们可以通过设置下面变量打开本地模式：<br><code>set hive.exec.mode.local.auto=true;</code><br>默认情况下这个设置为false，也就是说，Hive使用MR来执行其他的所有操作（区别上面介绍的两种）。</p>
<p>我们来感受下，下面截图为没有使用本地模式时查询数据条目数：<br><img src="https://github.com/leotse90/SparkNotes/blob/master/images/hive_local_mode_false.png" alt="hive_local_mode_false"><br>我们看到这个简单的操作用了34.321s，一共也就192条数据，这个固然和机器有关，但是MR启动以及计算导致时间成本太高。我们在下面的示例里打开了本地模式：<br><img src="https://github.com/leotse90/SparkNotes/blob/master/images/hive_local_mode_true.png" alt="hive_local_mode_true"><br>1.322s!，我们看到耗时明显降低，这就是本地模式的威力。</p>
<p>当然，使用本地模式也有一些条件：<br>1.<strong>输入数据的size</strong>：我们用参数hive.exec.mode.local.auto.inputbytes.max来指定本地模式处理的最大输入数据，默认为128MB；<br>2.<strong>Mapper的数量</strong>：参数hive.exec.mode.local.auto.tasks.max指定了本地模式下Mapper的最大数量，默认为4；<br>3.<strong>Reducer的数量</strong>：Reducer数量必须是0或1；</p>
<p>我们在使用Hive时，最好在$HOME/.hiverc配置文件中加入<code>set hive.exec.mode.local.auto=true;</code>设置。特别是当我们常常处理的数据量不大的时候！</p>
<p>另：由于Hadoop运行的机器和Hive client运行的机器可能环境不一致，JVM版本的不同或者软件的libs不同会导致本地模式可能出现不可预期的错误。另外一点值得我们注意的是，本地模式运行在Hive Client上一个独立的子JVM上，如果你愿意，那么你可以通过<code>hive.mapred.local.mem</code>参数来设置该子JVM最大内存，默认情况下，这个参数的值为0，在这种情况下，Hive会让Hadoop决定子JVM的默认内存限制。</p>
<p>参考：<br><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted#GettingStarted-Hive,Map-ReduceandLocal-Mode" target="_blank" rel="external">Hive GettingStarted</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>我们都知道，Hive是通过将HiveQL转化为MR job进行数据查询和处理。当然，不是全部的HQL语句都需要转为MR，比如我们常见的：<br><code>SELECT * FROM access_log;</code><br>这时候，Hive Shell能很快地返回给我们结果，这是因为这里用到的是Hive的<strong>本地模式</strong>。<br>Hive查询耗时太长，一直都是大家吐槽的对象，在数据量大的情况下，当然微不足道，但是当我们的查询量很小亦即查询数据很少的时候，Hive启动的耗时将会显得非常刺眼，因此在0.7版本以后，Hive开始支持本地模式。</p>
<p>除了上面的示例使用到了本地模式，如果WHERE语句中只是分区字段这种情况，也是无需使用MR job的：<br><code>SELECT * FROM access_log</code><br><code>WHERE dt=&#39;20150916&#39;</code><br><code>LIMIT 10;</code><br>这是因为分区字段在HDFS中保存实际上是目录结构，这些都是不用通过计算获取的（包含LIMIT）。<br>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://leotse90.com/tags/Hive/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FastDFS概览]]></title>
    <link href="http://leotse90.com/2015/10/10/FastDFS%E6%A6%82%E8%A7%88/"/>
    <id>http://leotse90.com/2015/10/10/FastDFS概览/</id>
    <published>2015-10-10T02:55:15.000Z</published>
    <updated>2015-10-21T06:38:48.000Z</updated>
    <content type="html"><![CDATA[<p><em>by：leotse</em></p>
<h2 id="Definition">Definition</h2><p>FastDFS是C语言实现的、开源的、轻量级的<strong>应用级分布式文件系统</strong>，开发者为淘宝开发平台部资深架构师余庆。它提供了负载均衡、冗余备份机制，是一个可扩展、高可用、高性能的分布式文件系统。</p>
<h2 id="Architecture">Architecture</h2><p>FastDFS一共由三部分组成：<br><strong>TrackerServer</strong>：负责负载均衡和调度。是整个FastDFS的中心，它将StorageServer的分组信息以及状态信息保存在内存中；<br><strong>StorageServer</strong>：存储文件和文件meta信息。直接使用操作系统的文件系统管理DFS上的文件；<br><strong>Client</strong>：使用者与请求发起方。通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互；<br><a id="more"></a><br><img src="https://github.com/leotse90/blogs/blob/master/images/fdfs01.gif" alt="FastDFS架构"></p>
<p><strong>上传文件</strong>：<br><img src="https://github.com/leotse90/blogs/blob/master/images/fdfs02.gif" alt="FastDFS上传文件"></p>
<p><strong>下载文件</strong>：<br><img src="https://github.com/leotse90/blogs/blob/master/images/fdfs03.gif" alt="FastDFS下载文件"></p>
<h2 id="Applies">Applies</h2><p>适合大中型网站使用，用于视频、图片、音频等中小资源文件的存储。（建议范围：4KB&lt;file_size&lt;500MB）</p>
<h2 id="Features">Features</h2><h3 id="1-Advantages">1.Advantages</h3><p>1）支持Linux、FreeBSD、AIX等Unix系统；<br>2）支持Java、Python、PHP API；<br>3）轻量级：相比GFS简化了master角色，不再管理meta数据信息；代码量较小，总代码行数不到5.2w行；<br>4）对等结构：FastDFS集群中的TrackerServer也可以有多台，TrackerServer和StorageServer均<strong>不存在单点问题</strong>。TrackerServer之间是对等关系，组内的StoragServer之间也是对等关系。和MasterSlave结构相比，对等结构中所有结点的地位是相同的，每个结点都是Master，不存在单点问题；<br>5）分组：FastDFS采用了分组存储方式。集群由一个或多个组构成，集群存储总容量为集群中所有组的存储容量之和。一个组由一台或多台存储服务器组成，同组内的多台StorageServer之间是互备关系，同组存储服务器上的文件是完全一致的。文件上传、下载、删除等操作可以在组内任意一台StorageServer上进行。所有的存储服务器均是同时在线服务，极大的提高的服务器的使用率，分担了数据访问压力；<br>6）可以使用Apache、Nginx等WebServer访问和下载文件；<br>7）FastDFS不对文件进行分块存储，与支持文件分块存储的DFS相比，更加简洁高效，并且完全能满足绝大多数互联网应用的实际需要。<br>8）FastDFS的设计目标就是支持大容量和高访问量，因此对于大量的小文件，可以支持得很好；<br>9）FastDFS自v1.14开始支持相同文件内容只存储一份，但是需要安装FastDHT，如果已经存在上传的文件，则建立一个符号链接以节省磁盘空间；</p>
<h3 id="2-Disadvantages">2.Disadvantages</h3><p>1）FastDFS不支持POSIX接口方式，不是通用的文件系统，不支持FUSE，不能<a href="http://en.wikipedia.org/wiki/Mount_(Unix" target="_blank" rel="external">mount使用</a>)；<br>2）不适用于分布式计算环境；<br>3）Group容量受单机存储容量限制，同时，当Group内有机器坏掉，数据恢复只能从Group内其他机器复制，使得恢复时间较长；<br>4）FastDFS适合存储用户上传的文件，比如用户照片。如果只是存储网站的静态文件（如装饰图片、css、js等），那没有必要使用FastDFS；<br>5）文档不够完善。相较于GlusterFS等DFS，FastDFS的相关文档资料相对欠缺。当前比较活跃的是ChinaUnix上的<a href="http://bbs.chinaunix.net/forum-240-1.html" target="_blank" rel="external">FastDFS论坛</a>。  </p>
<h2 id="others">others</h2><p>来源于论坛原作者的话：<br>1.单台tracker的性能特别高。因为tracker处理查询时，直接访问内存中的索引数据，不存在任何性能瓶颈。单台服务器支持的QPS超过5000没有任何问题。  </p>
<p>2.出于性能等考虑，必须通过FastDFS的API来对文件进行存取，不能mount使用。 </p>
<p>3.上传文件成功后，文件ID由storage server返回给客户端。文件ID中包括了分组、文件路径和文件名等信息，需要由客户端来保存文件ID。因此FastDFS 服务器端是不需要保存文件ID或索引等信息的。不再使用的文件（比如用户删除了自己的照片文件），应该由client调用delete file接口删除该文件。  </p>
<p>4.FastDFS存储文件采用的是256 * 256的两级目录；  </p>
<p>5.tracker不耗内存，有1GB内存足矣；   </p>
<p>6.FastDFS如何做整体迁移？如换机房更换IP?  </p>
<pre><code>如果新旧<span class="type">IP</span>地址一一对应，而且是一样的，那非常简单，直接将<span class="typedef"><span class="keyword">data</span>目录拷贝过去即可。</span>

<span class="type">IP</span>不一样的话，会比较麻烦一些。
如果使用了<span class="type">V4</span>的自定义server <span class="type">ID</span>特性，那么比较容易，直接将tracker上的<span class="type">IP</span>和<span class="type">ID</span>映射文件storage_ids.conf修改好即可。

如果是用<span class="type">IP</span>地址作为服务器标识，那么需要修改tracker和storage的<span class="typedef"><span class="keyword">data</span>目录下的几个数据文件，将旧<span class="type">IP</span>调整为新<span class="type">IP</span>。</span>
注意storage的<span class="typedef"><span class="keyword">data</span>目录下有一个.打头的隐藏文件也需要修改。</span>
另外，需要将后缀为mark的<span class="type">IP</span>地址和端口命名的同步位置记录文件名改名。
文件全部调整完成后才能启动集群服务。

<span class="title">tracker</span> server上需要调整的文件列表：
<span class="typedef"><span class="keyword">data</span>/storage_groups_new.dat</span>
<span class="typedef"><span class="keyword">data</span>/storage_servers_new.dat</span>
<span class="typedef"><span class="keyword">data</span>/storage_sync_timestamp.dat</span>

<span class="title">storage</span> server需要调整的文件列表：
<span class="typedef"><span class="keyword">data</span>/.data_init_flag</span>
<span class="typedef"><span class="keyword">data</span>/sync/$<span class="container">{<span class="title">ip_addr</span>}</span>_$<span class="container">{<span class="title">port</span>}</span>.mark：此类文件，需要将文件名中的<span class="type">IP</span>地址调整过来。</span>
</code></pre><p>7./etc/fdfs/mod_fastdfs.conf中的url_have_group_name项为true,否则会使用fdfs_test上传测试文件而后进行测试时，会报400错误。</p>
<p>8.<a href="http://bbs.chinaunix.net/thread-3772130-1-4.html" target="_blank" rel="external">FastDFS监控系统</a></p>
<p>9.<a href="http://bbs.chinaunix.net/thread-4164253-1-5.html" target="_blank" rel="external">FastDFS原理分析系列文章</a></p>
<p>10.部署方式和存储方式：作者推荐采用多个storage服务器(多个group)，各自分别挂载几个单盘的方式，以期提高总的磁盘IO性能。</p>
<p>11.相同内容的文件在系统里只保存一份文件实体，每次上传同一个文件，返回给client的文件ID是不同的，返回的文件ID通过链接的方式指向该实体文件，以unix的符号链接来理解：目标文件为实体文件，每次上传产生的文件为符号链接，指向对应的实体文件。</p>
<p>12.Storage的状态：<br>    FDFS_STORAGE_STATUS：INIT      :初始化，尚未得到同步已有数据的源服务器<br>    FDFS_STORAGE_STATUS：WAIT_SYNC :等待同步，已得到同步已有数据的源服务器<br>    FDFS_STORAGE_STATUS：SYNCING   :同步中<br>    FDFS_STORAGE_STATUS：DELETED   :已删除，该服务器从本组中摘除<br>    FDFS_STORAGE_STATUS：OFFLINE   :离线<br>    FDFS_STORAGE_STATUS：ONLINE    :在线，尚不能提供服务<br>    FDFS_STORAGE_STATUS：ACTIVE    :在线，可以提供服务  </p>
<p>13.安装pcre时，出现<br>configure: error: You need a C++ compiler for C++ support.<br>解决方案：yum install -y gcc gcc-c++</p>
<p>14.上传文件时：<br>errno: 113, error info: No route to host<br>解决方案：有可能是防火墙问题。iptables -F</p>
<p>15.启动nginx，permission denied，这时一般是权限问题。<br>解决方案：修改nginx配置，将#user  nobody;修改为user  root;（注意：可能有安全隐患），重启nginx即可。</p>
<h2 id="Conclusion">Conclusion</h2><p>FastDFS，按照作者本人的说法，它把简洁和高效做到了极致，非常节约资源，中小网站完全用得起。<br>作为国人在mogileFS的基础上进行改进的key-value型文件系统，一方面，它是我们国人的骄傲，另一方面，也希望FastDFS发展越来越好，相关的文档也越来越完善。</p>
<p><strong>备注</strong>：<br>该文档整理自网络，用于个人备忘与学习。如有侵权，衷心表示抱歉，并请联系本人及时删除相关内容。</p>
<p><strong>参考</strong>：<br><a href="http://tech.uc.cn/?p=221" target="_blank" rel="external">分布式文件系统FastDFS原理介绍</a><br><a href="http://www.oschina.net/question/12_13316" target="_blank" rel="external">分布式文件系统FastDFS架构剖析</a><br><a href="http://blog.irebit.com/fastdfs-%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" target="_blank" rel="external">FastDFS 配置教程</a><br><a href="http://blog.csdn.net/monkey_d_meng/article/details/6038995" target="_blank" rel="external">轻量级分布式文件系统FastDFS使用安装说明手册</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by：leotse</em></p>
<h2 id="Definition">Definition</h2><p>FastDFS是C语言实现的、开源的、轻量级的<strong>应用级分布式文件系统</strong>，开发者为淘宝开发平台部资深架构师余庆。它提供了负载均衡、冗余备份机制，是一个可扩展、高可用、高性能的分布式文件系统。</p>
<h2 id="Architecture">Architecture</h2><p>FastDFS一共由三部分组成：<br><strong>TrackerServer</strong>：负责负载均衡和调度。是整个FastDFS的中心，它将StorageServer的分组信息以及状态信息保存在内存中；<br><strong>StorageServer</strong>：存储文件和文件meta信息。直接使用操作系统的文件系统管理DFS上的文件；<br><strong>Client</strong>：使用者与请求发起方。通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互；<br>]]>
    
    </summary>
    
      <category term="FastDFS" scheme="http://leotse90.com/tags/FastDFS/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDFS文件系统命名空间]]></title>
    <link href="http://leotse90.com/2015/10/01/HDFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>http://leotse90.com/2015/10/01/HDFS文件系统命名空间/</id>
    <published>2015-10-01T02:55:15.000Z</published>
    <updated>2015-11-11T14:28:06.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="HDFS_Namespace">HDFS Namespace</h3><p>在HDFS中，我们知道NameNode负责管理文件系统的命名空间，那么NameNode到底怎么管理HDFS的命名空间，又有哪些内容需要管理呢？我们接下来将讨论到这两个问题。</p>
<p>作为HDFS的Master，NameNode掌握着整个HDFS的文件目录树及其目录与文件，这些信息会以文件的形式永久地存储在本地磁盘。我们可以在$HADOOP_HOME/tmp/dfs/name/current下找到这些文件：fsimage以及edits。</p>
<p><strong>fsimage</strong>：保存了最新的元数据检查点；<br><strong>edits</strong>：保存了HDFS中自最新的元数据检查点后的命名空间变化记录；</p>
<p>为了防止edits中保存的最新变更记录过大，HDFS会定期合并fsimage和edits文件形成新的fsimage文件，然后重新记录edits文件。由于NameNode存在单点问题（Hadoop2.0以前版本），因此为了减少NameNode的压力，HDFS把fsimage和edits的合并的工作放到SecondaryNameNode上，然后将合并后的文件返回给NameNode。但是，这也会造成一个新的问题，当NameNode宕机，那么NameNode中edits的记录就会丢失。也就是说，NameNode中的命名空间信息有可能发生丢失。<br><a id="more"></a></p>
<h3 id="FsImage">FsImage</h3><p>Fsimage是一个二进制文件，它记录了HDFS中所有文件和目录的元数据信息。关于fsimage的内部结构我们可以参看下图：<br><img src="/img/fsimage.jpg" alt="fsimage"><br>乍看之下，这张图有点晦涩难懂，这张图是fsimage的内部结构，第一行是文件系统元数据，第二行是目录的元数据信息，第三行是文件的元数据信息，下面将逐个解析图中的字段：<br><strong>imgVersion</strong>：当前fsiamge文件的版本号；<br><strong>namespaceID</strong>：当前命名空间的ID，在NameNode的生命周期内保持不变，DataNode注册时，返回该ID作为其registrationID，每次和NameNode通信时都要检查，不认识的namespaceID拒绝连接；<br><strong>numFiles</strong>：文件系统中的文件数；<br><strong>genStamp</strong>：生成该fsimage文件的时间戳；<br><strong>path</strong>：文件或者目录路径；<br><strong>replicas</strong>：文件的副本数，目录的replicas为0；<br><strong>mtime</strong>：修改时间；<br><strong>atime</strong>：访问时间；<br><strong>blocksiz</strong>：文件的块size，目录的size为0；<br><strong>numBlock</strong>：文件包含的数据块数量，目录的为－1；<br><strong>nsQuota</strong>：目录的命名空间大小配额，默认为－1；<br><strong>dsQuota</strong>：目录的磁盘大小配额，默认为－1；<br><strong>username</strong>：文件或者目录所属的用户名；<br><strong>group</strong>：用户所属的组名；<br><strong>perm</strong>：即permission，访问权限；<br><strong>blockid</strong>：文件的文件块id；<br><strong>numBytes</strong>：该文件块的bytes数，即文件块的大小；<br><strong>genStamp</strong>：该文件块的时间戳。</p>
<p>那么怎么在fsimage中保存根目录呢？path的length为0，即表示这个目录为根目录。</p>
<p>NameNode将这些信息读入内存之后，构造一个文件目录结构树，将表示文件或目录的节点填入到结构中。</p>
<h3 id="BlocksMap">BlocksMap</h3><p>我们知道，NameNode将文件命名空间的文件树结构等信息固化在本地文件中，同时还将文件块与DataNode的映射关系存储在内存中。NameNode是通过DataNode的blockreport获取文件块与DataNode的映射关系的。</p>
<p>BlocksMap中保存了文件块block与DataNodes的映射信息以及DataNode与文件块blocks的信息，这里用到三元组进行表示，每个文件块block有几个副本，就有几个三元组：<br><code>(DataNodeID, PreBlock, NextBlock)</code><br>第一个元素DataNodeID表示当前文件块block存储在哪个DataNode上；第二个元素PreBlock指向前一个文件块block；第三个元素NextBlock指向下一个文件块block；</p>
<p>借助这个三元组可以找到一个文件块block所属的所有DataNode，也可以通过三元组的后两个元素信息找到一个DataNode上所有的文件块blocks。 </p>
<h3 id="Conclusion">Conclusion</h3><p>通过fsimage与blocksmap两种数据结构，NameNode就能建立起完整的命名空间信息以及文件块映射信息。在NameNode加载fsimage之后，BlocksMap中只有每个block到其所属的DataNode列表的对应关系信息还没建立，这个需要通过DataNode的blockReport来收集构建，当所有的DataNode上报给NameNode的blockReport处理完毕后，BlocksMap整个结构也就构建完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="HDFS_Namespace">HDFS Namespace</h3><p>在HDFS中，我们知道NameNode负责管理文件系统的命名空间，那么NameNode到底怎么管理HDFS的命名空间，又有哪些内容需要管理呢？我们接下来将讨论到这两个问题。</p>
<p>作为HDFS的Master，NameNode掌握着整个HDFS的文件目录树及其目录与文件，这些信息会以文件的形式永久地存储在本地磁盘。我们可以在$HADOOP_HOME/tmp/dfs/name/current下找到这些文件：fsimage以及edits。</p>
<p><strong>fsimage</strong>：保存了最新的元数据检查点；<br><strong>edits</strong>：保存了HDFS中自最新的元数据检查点后的命名空间变化记录；</p>
<p>为了防止edits中保存的最新变更记录过大，HDFS会定期合并fsimage和edits文件形成新的fsimage文件，然后重新记录edits文件。由于NameNode存在单点问题（Hadoop2.0以前版本），因此为了减少NameNode的压力，HDFS把fsimage和edits的合并的工作放到SecondaryNameNode上，然后将合并后的文件返回给NameNode。但是，这也会造成一个新的问题，当NameNode宕机，那么NameNode中edits的记录就会丢失。也就是说，NameNode中的命名空间信息有可能发生丢失。<br>]]>
    
    </summary>
    
      <category term="HDFS" scheme="http://leotse90.com/tags/HDFS/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你真的懂单链表吗]]></title>
    <link href="http://leotse90.com/2015/09/21/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%97/"/>
    <id>http://leotse90.com/2015/09/21/你真的懂单链表吗/</id>
    <published>2015-09-21T02:55:15.000Z</published>
    <updated>2015-10-21T06:44:44.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="引子">引子</h2><p><strong>首先，上一道开胃菜：怎么判断两个单链表是否相交？</strong>  </p>
<p>我们假设两个单链表分别是A（有m个结点）和B（有n个结点），当然，最容易想到的肯定是两层循环，遍历A中的元素，然后分别与B中的元素进行比较，但是这样做的时间复杂度达到了O(m*n)，那么有没有更简单的办法呢？肯定有！  </p>
<p>我们来看看单链表的性质：每个结点只通过一个指针指向后继结点。那么是不是意味着两个单链表如若相交，它们就只能是Y形相交，而不可能是X形相交，亦即从第一个相同的结点开始，后面的结点全部一样。如果能想到这个，后面的就简单明了了：只要A链表和B链表的最后一个结点值相等，则证明A链表和B链表相交。该算法的时间复杂度也下降到O(m+n)。</p>
<p>我们进一步来思考：<strong>怎么找到第一个相交的元素呢？</strong><br><a id="more"></a><br>这里就当然不能像刚才那样，但是出发点还是一样，我们同样可以保证只要两次遍历。我们假设m &gt; n，那么如果我们将两个链表的末尾对齐，是不是从最后一个往前看（当然单链表不能往前遍历，我们先这样看）的时候，A链表会比B链表多m-n个元素，而A链表中的前m-n个元素可以忽略，直接从第m-n个元素开始和B链表一起向前遍历，比较A链表上第m-n+i个元素和B链表第i个元素（i&lt;n）即可。第一个相同的元素即为所求。  </p>
<p>下面来看看其它的几个单链表相关的典型问题（贴代码太占空间，这里就只谈谈思路，大家可以动手试试）： </p>
<h3 id="单链表的反转">单链表的反转</h3><p>如题，怎么实现一个单链表A（有m个元素）的反转呢？<br><strong>方案一</strong>：如果不能破坏原单链表，我们需要重新新建一个链表C，然后遍历原来的A链表，对C链表实行头插法建表（头插法即将新加入的结点作为链表的头结点，对应的还有尾插法，即直接在链表末尾添加元素）；<br><strong>方案二</strong>：如果可以破坏原单链表呢？暴力一点的办法是不断地交换相邻的两个元素，即首先将第一个元素通过m-1次交换使其变成链表的最后一个元素，然后又是同样的方法将现任的第一个元素通过m-2次交换使其成为链表的倒数第二个元素，以此类推。  </p>
<h3 id="单链表的排序">单链表的排序</h3><p>就排序原理而言，个人觉得其实不用过多考虑存储结构的问题，即不管是顺序存储还是链式存储，都不影响排序的基本原理，只是不同的存储结构会影响不同排序方法的效率而已。因为我们完全可以夸张地将顺序存储也想象为不连续的存储只是它们相邻两者的间隙极端的小。即我们将货物分别存在美国和中国的仓库里和都存放在一个仓库里是一样的，只是运费问题而已。<br>明白了这一点，那么单链表的排序就和普通的数组排序没有什么太大的区别。我们现在要做的事就是针对性地选择一个时间性能相对较好的排序算法。<br>我们知道的排序方法有很多：插入排序、冒泡排序、快速排序、归并排序、堆排序以及基数排序等等，那么这其中哪些对顺序结构和链式结构不那么感冒呢？熟悉这些排序的童鞋肯定知道，是插入排序和冒泡排序。其他的几种常见排序方法就比较偏袒顺序存储结构了。所以，如果要对链表进行排序，我会选择插入排序或者冒泡排序。（不太清楚这些基本排序原理的click here：<a href="http://wlh0706-163-com.iteye.com/blog/1465570" target="_blank" rel="external">5种基本排序 娱乐版开脑解析</a>）  </p>
<h3 id="删除单链表中的最小元素">删除单链表中的最小元素</h3><p>我能想到的办法就是遍历两次：第一次找到单链表中最小的元素，第二次遍历删除该元素。第一次遍历的时候需要借助两个变量，一个保存当前的最小元素的值，另一个保存当前最小值的位序。第二次遍历的时候当然就是删除第一次遍历得到的最小元素的位序上的元素了。 </p>
<h3 id="删除所有重复结点">删除所有重复结点</h3><p>这个一般得借助其他的数据结构了。基本思路应该是：遍历链表，用一个数据结构保存当前已经遍历的元素，若下一个访问的链表里的元素已经存在于已经访问的元素集合中，则删除单链表中的该元素，否则继续，直至到达链表的末尾。保存已经访问过的元素可以用数组，也可以用其他的。 </p>
<h3 id="判断一个链表是否包含另一个链表">判断一个链表是否包含另一个链表</h3><p>这个问题其实和开篇的问题一样，只是换了一种说法而已。因此只要找到第一个相同的元素就可以了。 </p>
<h3 id="找出单链表中的倒数第K个元素">找出单链表中的倒数第K个元素</h3><p>我们首先要确保的就是单链表的元素个数大于K。<br>这里的实现思路也很巧妙：我们定义两个指针a和b，全部指向链表的头结点，然后a指针开始向后遍历，但a遍历到第K个元素的时候，b指针也开始从头开始遍历，接下来的事你应该知道了，当a指针到达链表的末尾时，b指针恰好指着链表的倒数第K个元素。这样的时间复杂度是O(n)。 </p>
<p>那么，<strong>怎么找单链表中间的那个元素呢？</strong>  </p>
<p>PS：这些问题肯定还有更好地解法和方案，希望您不吝赐教。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="引子">引子</h2><p><strong>首先，上一道开胃菜：怎么判断两个单链表是否相交？</strong>  </p>
<p>我们假设两个单链表分别是A（有m个结点）和B（有n个结点），当然，最容易想到的肯定是两层循环，遍历A中的元素，然后分别与B中的元素进行比较，但是这样做的时间复杂度达到了O(m*n)，那么有没有更简单的办法呢？肯定有！  </p>
<p>我们来看看单链表的性质：每个结点只通过一个指针指向后继结点。那么是不是意味着两个单链表如若相交，它们就只能是Y形相交，而不可能是X形相交，亦即从第一个相同的结点开始，后面的结点全部一样。如果能想到这个，后面的就简单明了了：只要A链表和B链表的最后一个结点值相等，则证明A链表和B链表相交。该算法的时间复杂度也下降到O(m+n)。</p>
<p>我们进一步来思考：<strong>怎么找到第一个相交的元素呢？</strong><br>]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://leotse90.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop集群部署（RedHat）]]></title>
    <link href="http://leotse90.com/2015/09/20/Hadoop%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2(RedHat)/"/>
    <id>http://leotse90.com/2015/09/20/Hadoop集群部署(RedHat)/</id>
    <published>2015-09-20T02:55:15.000Z</published>
    <updated>2015-10-21T07:21:34.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>安装环境：Red Hat 4.8.3-9<br>Hadoop版本：Apache Hadoop 2.6.0<br>Java版本：1.8.0<br>Master：172.16.10.136<br>Slave1：172.16.10.137<br>用户：xiefeng<br>安装目录：/home/xiefeng/dependencies</p>
<p>主要部署步骤：<br>1.SSH免密码登录设置；<br>2.环境变量设置（Java以及Hadoop）;<br>3.Master部署；<br>4.Slave部署；<br>5.启动集群；  </p>
<p>接下来我们对每一步进行详细介绍。<br><a id="more"></a></p>
<h2 id="SSH免密码登录设置">SSH免密码登录设置</h2><p>进行SSH免密码登录设置是为了避免在集群内部机器交互的时候频繁输入登录密码，我们在这里为集群内的每个机器都执行SSH免密码登录设置。在这里不具体介绍SSH免密码登录的具体步骤，可以参见<a href="https://github.com/leotse90/blogs/blob/master/SSH免密码登录设置.md" target="_blank" rel="external">SSH免密码登录设置</a></p>
<h2 id="环境变量设置">环境变量设置</h2><p>修改hosts文件：<br><code>vi /etc/hosts</code><br>新增：<br><code>172.16.10.136   Master</code><br><code>172.16.10.137   Slave1</code>  </p>
<p>一般，Java都已经安装好。如果没有，需要先行安装Java并配置JAVA_HOME。然后修改~/.bashrc文件，在文件的末尾增加JAVA和HADOOP的配置：  </p>
<p><code>### set java home</code><br><code>export JAVA_HOME=/work/p/jdk/default</code>  </p>
<p><code>### set hadoop env</code><br><code>export HADOOP_HOME=/home/xiefeng/dependecies/hadoop-2.6.0</code><br><code>export HADOOP_COMMON_HOME=$HADOOP_HOME</code><br><code>export HADOOP_HDFS_HOME=$HADOOP_HOME</code><br><code>export HADOOP_MAPRED_HOME=$HADOOP_HOME</code><br><code>export HADOOP_YARN_HOME=$HADOOP_HOME</code><br><code>export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</code><br><code>export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/lib</code><br><code>export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</code><br><code>export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib&quot;</code>  </p>
<p>然后：<br><code>source ~/.bashrc</code>  </p>
<p>检查是否配置成功，可以<code>echo $HADOOP_HOME</code>看是否是配置中的路径。  </p>
<h2 id="Master部署">Master部署</h2><p>1.解压Hadoop 2.6安装包到安装目录，在这个示例里是/home/xiefeng/dependecies/目录：<br><code>tar xvf hadoop-2.6.0.tar</code>  </p>
<p>2.进入Hadoop目录，修改slaves文件，增加Slave1到slaves文件中：<br><code>cd hadoop-2.6.0</code><br><code>vi etc/hadoop/slaves</code><br>添加：<br><code>Slave1</code>  </p>
<p>3.修改core-site.xml配置文件：<br><code>vi etc/hadoop/core-site.xml</code><br>修改为：<br><code>&lt;configuration&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;fs.defaultFS&lt;/name&gt;</code><br><code>&lt;value&gt;hdfs://Master:9000&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</code><br><code>&lt;value&gt;file:/home/xiefeng/dependecies/hadoop-2.6.0/tmp&lt;/value&gt;</code><br><code>&lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;/configuration&gt;</code>  </p>
<p>4.修改hdfs-site.xml配置文件为：<br><code>&lt;configuration&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</code><br><code>&lt;value&gt;Master:50090&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</code><br><code>&lt;value&gt;file:/home/xiefeng/dependecies/hadoop-2.6.0/tmp/dfs/name&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</code><br><code>&lt;value&gt;file:/home/xiefeng/dependecies/hadoop-2.6.0/tmp/dfs/data&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;dfs.replication&lt;/name&gt;</code><br><code>&lt;value&gt;1&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;/configuration&gt;</code>  </p>
<p>5.复制mapred-site.xml.template得到mapred-site.xml文件：<br><code>cp mapred-site.xml.template mapred-site.xml</code><br>修改mapred-site.xml配置文件为：<br><code>&lt;configuration&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</code><br><code>&lt;value&gt;yarn&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;/configuration&gt;</code>  </p>
<p>6.修改yarn-site.xml配置文件为：<br><code>&lt;configuration&gt;</code><br><code>&lt;!-- Site specific YARN configuration properties --&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</code><br><code>&lt;value&gt;Master&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;property&gt;</code><br><code>&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</code><br><code>&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</code><br><code>&lt;/property&gt;</code><br><code>&lt;/configuration&gt;</code>  </p>
<p>7.一般的，我们还需要修改一下hadoop-env.sh，将其JAVA_HOME修改为当前机器的JAVA_HOME：<br><code># The java implementation to use.</code><br><code># export JAVA_HOME=${JAVA_HOME}</code><br><code>export JAVA_HOME=/work/p/jdk/default</code>  </p>
<h2 id="Slave部署">Slave部署</h2><p>1.将 Master 上的 Hadoop 文件先打包然后复制到各个节点上：<br><code>sudo tar -zcf hadoop－2.6.0.tar.gz hadoop－2.6.0/</code><br><code>scp hadoop－2.6.0.tar.gz Slave1:/home/xiefeng/dependecies</code>  </p>
<p>2.解压到Slave1的安装目录：<br><code>sudo tar -zxf hadoop－2.6.0.tar.gz</code><br><code>sudo chown -R xiefeng:xiefeng /home/xiefeng/dependecies/hadoop-2.6.0</code>  </p>
<h2 id="集群启动">集群启动</h2><p>我们回到Master，进入hadoop安装目录：<br><code>cd /home/xiefeng/dependecies/hadoop-2.6.0</code><br>第一次执行，初始化：<br><code>bin/hdfs namenode -format</code>  </p>
<p>启动dfs：<br><code>sbin/start-dfs.sh</code><br>启动yarn：<br><code>sbin/start-yarn.sh</code>  </p>
<p>分别在Master和Slave1输入jps，看看是否有以下输出，有则表明安装ok：<br><code>[xiefeng@Master hadoop-2.6.0]$ jps</code><br><code>8498 NameNode</code><br><code>8837 ResourceManager</code><br><code>8680 SecondaryNameNode</code><br><code>9817 Jps</code>  </p>
<p><code>[xiefeng@Slave1 logs]$ jps</code><br><code>20208 NodeManager</code><br><code>20344 Jps</code><br><code>20107 DataNode</code>  </p>
<p>在浏览器输入：<a href="http://master：8088就可以查看集群All" target="_blank" rel="external">http://master：8088就可以查看集群All</a> Applications信息；输入<a href="http://master:50070可以查看namenode信息。" target="_blank" rel="external">http://master:50070可以查看namenode信息。</a></p>
<p>停止dfs：<br><code>sbin/stop-dfs.sh</code><br>停止yarn：<br><code>sbin/stop-yarn.sh</code>  </p>
<p>另外，还可以使用以下脚本进行集群的启动和停止：<br><code>sbin/start-all.sh</code><br><code>sbin/stop-all.sh</code></p>
<p>至此，Hadoop集群搭建完毕！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>安装环境：Red Hat 4.8.3-9<br>Hadoop版本：Apache Hadoop 2.6.0<br>Java版本：1.8.0<br>Master：172.16.10.136<br>Slave1：172.16.10.137<br>用户：xiefeng<br>安装目录：/home/xiefeng/dependencies</p>
<p>主要部署步骤：<br>1.SSH免密码登录设置；<br>2.环境变量设置（Java以及Hadoop）;<br>3.Master部署；<br>4.Slave部署；<br>5.启动集群；  </p>
<p>接下来我们对每一步进行详细介绍。<br>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://leotse90.com/tags/Hadoop/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
