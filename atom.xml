<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一条互联网广告狗]]></title>
  <subtitle><![CDATA[My name is L.T.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leotse90.com/"/>
  <updated>2017-09-24T15:45:52.000Z</updated>
  <id>http://leotse90.com/</id>
  
  <author>
    <name><![CDATA[Leo Tse]]></name>
    <email><![CDATA[proleo@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[OOP设计原则之依赖倒置原则（DIP）]]></title>
    <link href="http://leotse90.com/2017/09/24/OOP-design-principles-DIP/"/>
    <id>http://leotse90.com/2017/09/24/OOP-design-principles-DIP/</id>
    <published>2017-09-24T15:18:01.000Z</published>
    <updated>2017-09-24T15:45:52.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<blockquote>
<p>Program to an interface, not an implementation. </p>
</blockquote>
<p>先不管DIP的定义，我们看一个例子，我们的APP需要使用Facebook Audience Network的广告实现应用内变现，一般的实现方式是（这里用Java实现）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdController</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		FacebookAdManager fbAdManager = <span class="keyword">new</span> FacebookAdManager();</span><br><span class="line">		fbAdManager.displayFbAd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacebookAdManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayFbAd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的实现方式比较常见。这里我们抽象出两个模块，控制模块（AdController）以及广告加载模块（FacebookAdManager），两个模块之间的关系是处于高层的控制模块直接依赖于低层的广告加载模块，这也是我们在传统的应用架构中见得比较多的一种代码依赖关系，就像楼房的高层需要基于低层一样。<br><a id="more"></a><br>我们能发现，这样的依赖关系使得这两个相对比较独立的模块紧紧耦合在一起，如果我们我们需要修改任一模块的逻辑，那么很有可能会影响另一模块的业务代码，比如：我们由于广告策略调整，还想借助于Google家的Admob平台实现广告变现，这时候，原来的业务逻辑就会变成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdController</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		FacebookAdManager fbAdManager = <span class="keyword">new</span> FacebookAdManager();</span><br><span class="line">		fbAdManager.displayFbAd();</span><br><span class="line">		AdmobAdManager amAdManager = <span class="keyword">new</span> AdmobAdManager();</span><br><span class="line">		amAdManager.displayAmAd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacebookAdManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayFbAd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdmobAdManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAmAd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的代码就会显得比较笨拙，广告加载模块（FacebookAdManager和AdmobAdManager）的每一次调整，或者控制模块的每一次策略调整，都有可能影响另一个模块的业务。那么我们怎么更加优雅地实现呢？我们在两个模块之间抽象出一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAdManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将Admob和Facebook广告共同的方法抽象出来，这样所有的广告源的实现变为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacebookAdManager</span> <span class="keyword">implements</span> <span class="title">IAdManager</span></span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdmobAdManager</span> <span class="keyword">implements</span> <span class="title">IAdManager</span></span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此以来，控制模块的调用逻辑就会变得比之前的方式更加灵活：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdController</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		displayController(<span class="keyword">new</span> AdmobAdManager());</span><br><span class="line">		displayController(<span class="keyword">new</span> FacebookAdManager());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayController</span><span class="params">(IAdManager adManager)</span></span>&#123;</span><br><span class="line">		adManager.displayAd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下上面的示例，高层模块（AdController）本来需要直接依赖于低层模块（FacebookAdManager和AdmobAdManager），但是我们为了<strong>提高可扩展性以及降低模块之间的耦合</strong>，我们加入了抽象接口层（IAdManager），使得<strong>高层模块不直接依赖于低层模块，而是两者都依赖于该接口层，这种设计原则我们称之为依赖倒置原则（Dependence Invesion Principle，DIP）</strong>。（这里的倒置并不是说低层模块反过来依赖于高层模块）   </p>
<p>一般介绍DIP都会提到这样两个关键点：<br><strong>1）高层模块不应该直接依赖于低层模块，他们都应该依赖于抽象</strong><br>高层模块和低层模块都应该通过抽象来进行解耦。<br><strong>2）抽象不应该依赖于细节，而细节应该依赖于抽象</strong><br>这里的抽象指的是接口或者抽象类，而细节指的是这些接口或者抽象类的具体实现。这个不难理解，抽象就相当于两个模块之间的规则，实现就是遵照这些规则的具体操作，很显然具体操作是需要依赖于既定规则的。   </p>
<p>对于DIP，我们可以这样总结：<br><strong>细节是多变的，抽象是稳定的。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<blockquote>
<p>Program to an interface, not an implementation. </p>
</blockquote>
<p>先不管DIP的定义，我们看一个例子，我们的APP需要使用Facebook Audience Network的广告实现应用内变现，一般的实现方式是（这里用Java实现）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdController</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		FacebookAdManager fbAdManager = <span class="keyword">new</span> FacebookAdManager();</span><br><span class="line">		fbAdManager.displayFbAd();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacebookAdManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayFbAd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的实现方式比较常见。这里我们抽象出两个模块，控制模块（AdController）以及广告加载模块（FacebookAdManager），两个模块之间的关系是处于高层的控制模块直接依赖于低层的广告加载模块，这也是我们在传统的应用架构中见得比较多的一种代码依赖关系，就像楼房的高层需要基于低层一样。<br>]]>
    
    </summary>
    
      <category term="OOP" scheme="http://leotse90.com/tags/OOP/"/>
    
      <category term="设计原则" scheme="http://leotse90.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android获取全局Context]]></title>
    <link href="http://leotse90.com/2017/06/07/Android%E8%8E%B7%E5%8F%96%E5%85%A8%E5%B1%80Context/"/>
    <id>http://leotse90.com/2017/06/07/Android获取全局Context/</id>
    <published>2017-06-07T15:33:21.000Z</published>
    <updated>2017-06-07T15:47:35.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>在Android的开发中，我们经常需要在不同的场景中使用Context对象。比如，弹出一个Toast，启动一个Service或者一个Activity等等。</p>
<p>每个开发者都有自己的方法去获取Context，比较常见的是将Context作为一个参数传递到需要使用的方法，这种方法虽然可以实现这个目的，但是也存在着弊端，Context作为参数传递固然ok，但是需要我们在需要使用到Context的方法里都加上一个参数，这种做法并不优雅。</p>
<p>这时候我们有另一种办法去实现我们的目的，那就是在Application中定义一个静态方法，用以获取Context：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context cxt;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        cxt = getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这样我们就可以在project的任意地方通过调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyApplication.getContext();</span><br></pre></td></tr></table></figure></p>
<p>来获取Context对象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>在Android的开发中，我们经常需要在不同的场景中使用Context对象。比如，弹出一个Toast，启动一个Service或者一个Activity等等。</p>
<p>每个开发者都有自己的方法去获取Context，比较常见的是将Context作为一个参数传递到需要使用的方法，这种方法虽然可以实现这个目的，但是也存在着弊端，Context作为参数传递固然ok，但是需要我们在需要使用到Context的方法里都加上一个参数，这种做法并不优雅。</p>
<p>这时候我们有另一种办法去实现我们的目的，那就是在Application中定义一个静态方法，用以获取Context：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context cxt;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        cxt = getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Android" scheme="http://leotse90.com/tags/Android/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Top 5 Secrets of Mobile Ad Network Payout]]></title>
    <link href="http://leotse90.com/2016/09/12/Top-5-Secrets-of-Mobile-Ad-Network-Payout/"/>
    <id>http://leotse90.com/2016/09/12/Top-5-Secrets-of-Mobile-Ad-Network-Payout/</id>
    <published>2016-09-12T14:06:35.000Z</published>
    <updated>2016-09-12T14:27:46.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:YANIV NIZAN</em><br><em>source:<a href="http://blog.soom.la/2016/04/top-5-secrets-mobile-ad-network-payout.html" target="_blank" rel="external">Top 5 Secrets of Mobile Ad Network Payout</a></em></p>
<p><center><br><img src="/img/net_secret.jpg" alt="net_secret"><br></center><br><a id="more"></a><br>This is a topic I’m sitting on for quite a while. For about 8 years I was part of the Ad-tech industry so I know a lot of the secrets of how it operates. I’m always amazed by how little publishers know about what’s going on behind the scenes of the ad-networks that drive most of their revenues. I believe knowledge is power so I hope this will serve as a resource for app publishers to know more about what drives their top line. If you also want to learn the the specific information about each ad-network you can check the <a href="http://blog.soom.la/2016/05/mobile-ad-networks-comparison-spreadsheet.html" target="_blank" rel="external">Mobile Ad Network Comparison Spreadsheet</a></p>
<h2 id="eCPM_and_CPM_are_not_the_same">eCPM and CPM are not the same</h2><p>CPM stands for cost per mile but in advertising terminology this mostly refers to the cost of 1,000 impressions. When publishers get paid based on the CPM model, there is a fixed rate for every 1,000 impressions. For example, a CPM of 5 dollars means that for every 1,000 ad impressions the publisher should receive five dollars. eCPM on the other hand is very different. It means that the publisher is paid a variable rate for every 1,000 impressions (<a href="http://blog.soom.la/2016/04/ecpm-fluctuating.html" target="_blank" rel="external">the eCPM fluctuates</a>). It could be 0 dollar or 5 dollars and the publisher doesn’t have any revenue guarantee. In fact, eCPM is the opposite of CPM from an advertiser commitment point of view.</p>
<h2 id="Rev-share_in_most_mobile_ad_networks_is_driven_by_app_installs">Rev-share in most mobile ad networks is driven by app installs</h2><p>The reality of most mobile advertising today is that publishers get paid based on a rev-share. The ad networks might call it eCPM but the impressions are not the driver of the revenue. The ad-network’s only commitment is that it pays the publisher a percentage of what it’s making. 90% of the time, this is driven by app installs and 10% of the time the revenue is generated by clicks. The reason for that is that most of the ad network revenue today comes from performance campaigns with a goal of app installs. For example, a user that watched 500 ad impressions and never clicked could be generating 0 dollar while a user that watched a single ad but actually installed the app could have generated 3 dollars of revenue. This is a critical distinction especially when optimizing your app revenue. It means that that the more data you have about what happens after the impressions, the easier it will be for you to identify the best user segments.</p>
<h2 id="Payout_threshold_defers_your_revenue">Payout threshold defers your revenue</h2><p>When you read carefully through the terms of the publisher agreement you realize that most ad networks have payout thresholds. It means that you can only get paid after you’ve earned 75 dollars or 100 dollars of revenue. For indie developers it’s recommended to take that into consideration when choosing their monetization partners. It also might be wise for smaller app developers to leverage mediation platforms with a payment aggregation option. Doing so would allow you to get paid faster.</p>
<h2 id="Multiple_hops_means_each_middle-man_takes_a_cut">Multiple hops means each middle-man takes a cut</h2><p>Another misconception is that there is only one ad network between the publisher and the advertiser. This is wrong in many cases. As a publisher, you should try to understand how many hops (ad networks) are between you and the end advertiser on the other side. The math is simple, every hop means another mouth to feed, another company that needs to take a cut and less revenue for you.</p>
<h2 id="Net_Revenue_and_Revenue_are_not_the_same">Net Revenue and Revenue are not the same</h2><p>When reading carefully into the terms and conditions of the ad-networks you will realize that the promised revenue sharing is not from the ad-network revenue but from a slightly different figure called Net Revenue. If you are not familiar with this term, you should pay attention. The ad-network gets revenue from the advertiser and then deducts certain costs from that revenue to get the Net Revenue which is then shared with you. For example – if the network promised that you will get 70% of the Net Revenue, it means that if they get 1 dollar from the advertiser, they might deduct 0.3 dollars to cover certain costs. The net revenue will then be 0.7 dollars and your 70% is actually 49 cents from that 1 dollar. 49% rev-share in fact. The Net Revenue can also be adjusted by the ad-network from time to time. Which means that potentially it could be used to boost your revenue during your test period to influence your partner selection but then it could be dialed back to maximize the ad-network profits.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:YANIV NIZAN</em><br><em>source:<a href="http://blog.soom.la/2016/04/top-5-secrets-mobile-ad-network-payout.html">Top 5 Secrets of Mobile Ad Network Payout</a></em></p>
<p><center><br><img src="/img/net_secret.jpg" alt="net_secret"><br></center><br>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无端]]></title>
    <link href="http://leotse90.com/2016/08/30/%E6%97%A0%E7%AB%AF/"/>
    <id>http://leotse90.com/2016/08/30/无端/</id>
    <published>2016-08-30T15:01:02.000Z</published>
    <updated>2016-08-30T15:07:27.000Z</updated>
    <content type="html"><![CDATA[<p><em>From:L.T.</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=26508242&auto=0&height=66"></iframe>

<center><br><img src="/img/mask.jpeg" alt="mask"><br></center><br><a id="more"></a><br><center><br>北京<br>一半贪婪<br>一半恐惧<br></center>]]></content>
    <summary type="html">
    <![CDATA[<p><em>From:L.T.</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=26508242&auto=0&height=66"></iframe>

<center><br><img src="/img/mask.jpeg" alt="mask"><br></center><br>]]>
    
    </summary>
    
      <category term="远方与诗" scheme="http://leotse90.com/tags/%E8%BF%9C%E6%96%B9%E4%B8%8E%E8%AF%97/"/>
    
      <category term="随笔" scheme="http://leotse90.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMaps, ArrayMaps and SparseArrays in Android]]></title>
    <link href="http://leotse90.com/2016/08/21/HashMaps_ArrayMaps_and_SparseArrays_in_Android/"/>
    <id>http://leotse90.com/2016/08/21/HashMaps_ArrayMaps_and_SparseArrays_in_Android/</id>
    <published>2016-08-21T11:39:08.000Z</published>
    <updated>2016-08-21T11:45:40.000Z</updated>
    <content type="html"><![CDATA[<p><em>Posted by <a href="http://deepakmishra.me/blog/index.php/2015/10/19/hashmaps-arraymaps-and-sparsearrays-in-android/" target="_blank" rel="external">deepak in Android</a></em></p>
<center><br><img src="/img/hashmap.png" alt="hashmap"><br></center>

<p>Android developers must be observing Lint warnings recently to replace some of their HashMaps with SparseArrays with a promise of memory optimization. Good for us ! There are few classes we should learn to use, like ArrayMap  and SimpleArrayMap. There are also multiple variants of SparseArrays. This post will describe these classes along with their internals.<br><a id="more"></a><br>Let’s start with some code showing how to use these classes:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> java.util.HashMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">hashMap.put(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">hashMap.get(<span class="string">"key"</span>);</span><br><span class="line">hashMap.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">android.util.ArrayMap&lt;String, String&gt; arrayMap = <span class="keyword">new</span> android.util.ArrayMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">arrayMap.put(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">arrayMap.get(<span class="string">"key"</span>);</span><br><span class="line">arrayMap.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">android.support.v4.util.ArrayMap&lt;String, String&gt; supportArrayMap =</span><br><span class="line">        <span class="keyword">new</span> android.support.v4.util.ArrayMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">supportArrayMap.put(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">supportArrayMap.get(<span class="string">"key"</span>);</span><br><span class="line">supportArrayMap.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">android.support.v4.util.SimpleArrayMap&lt;String, String&gt; simpleArrayMap =</span><br><span class="line">        <span class="keyword">new</span> android.support.v4.util.SimpleArrayMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">simpleArrayMap.put(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">simpleArrayMap.get(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment">//simpleArrayMap.entrySet().iterator();      &lt;- will not compile</span></span><br><span class="line"></span><br><span class="line">android.util.SparseArray&lt;String&gt; sparseArray = <span class="keyword">new</span> android.util.SparseArray&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line">sparseArray.put(<span class="number">10</span>, <span class="string">"value"</span>);</span><br><span class="line">sparseArray.get(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">android.util.LongSparseArray&lt;String&gt; longSparseArray = <span class="keyword">new</span> android.util.LongSparseArray&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line">longSparseArray.put(<span class="number">10L</span>, <span class="string">"value"</span>);</span><br><span class="line">longSparseArray.get(<span class="number">10L</span>);</span><br><span class="line"></span><br><span class="line">android.util.SparseLongArray sparseLongArray = <span class="keyword">new</span> android.util.SparseLongArray(<span class="number">16</span>);</span><br><span class="line">sparseLongArray.put(<span class="number">10</span>, <span class="number">100L</span>);</span><br><span class="line">sparseLongArray.get(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>Let’s discuss these classes one by one. All Java collections are primarily based on Arrays. We need to understand how HashMaps work before we look into alternatives.</p>
<h2 id="java-util-HashMap">java.util.HashMap</h2><p>HashMap is basically an Array of HashMap.Entry objects (Entry is an inner class of HashMap). On a high-level, the instance variables in Entry class are :</p>
<blockquote>
<p>A non-primitive key<br>A non-primitive value<br>Hashcode of the object<br>A pointer to next Entry  </p>
</blockquote>
<p>Note that keys and values are all non-primitives. This is a design decision made by Java engineers, and we have to live with it. Inserting a primitive comes at a cost of autoboxing.</p>
<p>When an object is inserted in the HashMap :</p>
<blockquote>
<p>Hashcode of the key is calculated and Entry class’ hashCode variable is populated.<br>Another method, java.util.HashMap.indexFor() is applied on the hashCode which you can think of as a modulo function using the size of Entry[ ], and determines the index of this Entry in the Entry[ ]. This index is called ‘bucket’.<br>If there is a pre-existing element in this bucket, the new element is inserted with the last element pointing to new one – essentially making the bucket a LinkedList.</p>
</blockquote>
<p>Queries can now be done with O(1) complexity :</p>
<blockquote>
<p>Input key’s hashCode is calculated<br>java.util.HashMap.indexFor() is applied on this hashCode and we get the bucket/index of the Entry object like querying an array.</p>
</blockquote>
<p>O(1) time is a magic all developers want. But space is another constraint. Especially on mobile. Drawbacks of HashMaps are :</p>
<p>1.Autoboxing means extra objects created with each insertion. This will impact memory usage as well as Garbage Collection.<br>2.The HashMap.Entry objects themselves are an extra layer of objects to be created and garbage collected.<br>3.Buckets are rearranged each time HashMap is compacted or expanded. This is an expensive operation which grows with number of objects.<br>4.Hashing is cool, but if implemented poorly will take us back to O(N).<br>5.A related disadvantage of hashing which most people ignore is that we still need to store both the key and the hashcode. This redundancy helps with tackling collision. Non-hash solutions can help in this regard too.</p>
<h2 id="android-util-ArrayMap">android.util.ArrayMap</h2><p>ArrayMap uses 2 arrays. The instance variables used internally are Object[ ] mArray to store the objects and the int[] mHashes to store hashCodes. When an key/value is inserted :</p>
<blockquote>
<p>Key/Value is autoboxed.<br>Key object is inserted at the next available position in mArray[ ].<br>Value object is also inserted in the position next to key’s position in mArray[ ].<br>The hashCode of key is calculated and placed in mHashes[ ] at the next available position.  </p>
</blockquote>
<p>For searching a key :</p>
<blockquote>
<p>Key’s hashCode is calculated<br>Binary search is done for this hashCode in the mHashes array. This implies time complexity increases  to O(logN).<br>Once we get the index of hash, we know that key is at 2*index position in mArray and value is at keyIndex+1 position.  </p>
</blockquote>
<p>This still does not solve the problem of autoboxing, as put() still takes an Object as input. But it does create one less object (HashMap.Entry). Is it worth trading off O(1) search complexity ? Metrics say yes for most apps.  </p>
<h2 id="android-support-v4-util-ArrayMap">android.support.v4.util.ArrayMap</h2><p>android.util.ArrayMap works only on API level 19 (Kitkat) onwards. Support library brings the same functionality to older platforms.</p>
<h2 id="android-support-v4-util-SimpleArrayMap">android.support.v4.util.SimpleArrayMap</h2><p>As you would have noticed in the code snippet posted earlier (line#21), this class does not offer entrySet() method to iterate. If you go through it’s documentation, it trims off many other methods from standard Java Collections API. So why use SimpleArrayMap ? Use it to trim down your APK size at the cost of losing interoperability with other Java containers. This way, Proguard (code optimization and obfuscation tool, which is likely to be a part of your build generation) can trim off most of those unused Collections API code – and hence making your APK size smaller. The internal working of this class is same as android.util.ArrayMap.</p>
<h2 id="android-util-SparseArray">android.util.SparseArray</h2><p>Like ArrayMaps, SparseArrays also use 2 arrays at their core. One is int[ ] called mKeys and the second is Object[ ] called mValues. As the names suggest, one is for keys and another for values :)</p>
<p>When a key/value is inserted :</p>
<blockquote>
<p>The int key (and not it’s hash) is stored in the next available position in mKeys[ ]. So no autoboxing of the key anymore.<br>The value Object is stored in the next available position in mValues[ ]. Value is still autoboxed.</p>
</blockquote>
<p>For a query :</p>
<blockquote>
<p>The key is searched using binary search (refer to android.util.ContainerHelpers.binarySearch() method) in the mKeys array. This means, search complexity is still O(log N).<br>The key index is used to retrieve the value from the mValues array.  </p>
</blockquote>
<p>Compared to HashMap, we got rid of Entry object and the key object. We have given up hashing, and are relying on binary search. On compaction/expansion, there is a lighter overhead now.  </p>
<p>Pre-Kitkat (API level &gt;= 19) use android.support.v4.util.SparseArrayCompat</p>
<h2 id="android-util-LongSparseArray">android.util.LongSparseArray</h2><p>SparseArray accepts only int primitives as keys. With LongSparseArray, we can use long as keys too. Implementation is same as SparseArray.  </p>
<p>Pre-Kitkat (API level &gt;= 19) use android.support.v4.util.LongSparseArray</p>
<h2 id="android-util-SparseIntArray,_android-util-SparseLongArray_and_android-util-SparseBooleanArray">android.util.SparseIntArray, android.util.SparseLongArray and android.util.SparseBooleanArray</h2><p>For cases where keys are integer primitives and values are either integer, long or boolean primitives; use SparseIntArray, SparseLongArray and SparseBooleanArray respectively. Their implementation is same as SparseArrays, the advantage being the mValues array is a primitive array. Which means neither key, nor value is boxed, and we save 3 objects (Entry, Key and Value) compared to HashMap implementation, while losing search complexity from O(1) to O(log N).</p>
<p>Using the SpareArray and ArrayMap implementations will certainly reduce the number of objects creation. Performance difference should not be significant (less than 50%) for collections with hundreds of items. In summary, it’s good to migrate to ArrayMap and SparseArray implementations for new code; and back-porting should be easy as API signatures match.</p>
<p>N.B : Though they sound like arrays, SparseArrays and ArrayMaps do not guarantee preserving the order of insertion. Be mindful while iterating.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>Posted by <a href="http://deepakmishra.me/blog/index.php/2015/10/19/hashmaps-arraymaps-and-sparsearrays-in-android/">deepak in Android</a></em></p>
<center><br><img src="/img/hashmap.png" alt="hashmap"><br></center>

<p>Android developers must be observing Lint warnings recently to replace some of their HashMaps with SparseArrays with a promise of memory optimization. Good for us ! There are few classes we should learn to use, like ArrayMap  and SimpleArrayMap. There are also multiple variants of SparseArrays. This post will describe these classes along with their internals.<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://leotse90.com/tags/Android/"/>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SharedPreferences.Editor的commit VS apply]]></title>
    <link href="http://leotse90.com/2016/08/15/android_sharedPreferenced_editor/"/>
    <id>http://leotse90.com/2016/08/15/android_sharedPreferenced_editor/</id>
    <published>2016-08-15T03:33:56.000Z</published>
    <updated>2016-08-15T15:41:12.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=17177324&auto=0&height=66"></iframe>

<p>在Android开发中，我们经常会使用SharedPreferences对一些指定数据类型的数据进行持久化存储。</p>
<p>当我们需要写入数据时，我们需要借助于SharedPreferences.Editor进行数据的写操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"test"</span>, MODE_PRIVATE).edit();</span><br><span class="line">editor.putString(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure></p>
<p>执行完这段代码，我们就能将key－value这组数据存储在/data/data/your_package_name/shared_prefs/目录下。  </p>
<p>我们注意到，在这里我们使用commit()进行数据的提交，实际上，SharedPreferences还提供了另一个方法apply()来提交需要保存的数据，那么这两者有什么区别呢？<br><a id="more"></a></p>
<p><strong>1.commit()方法是同步的，也就是它会马上执行数据的保存操作，而apply()方法是异步的，它首先将数据保存在内存里，然后再写入文件。如果我们使用SharedPreferences的场景需要频繁进行文件的保存，那么我们建议使用apply()方法，这样可以提高程序的性能；<br>2.当然commit()也不是一无是处的，commit()会及时反馈给调用方数据保存的结果。如果你需要确保数据的保存成功或者做一些容错处理，commit()就会是你的优选。</strong></p>
<p>如果两个editor同时修改，那么只有后面的修改才会生效；如果程序在使用commit()进行提交的时候，同时程序另一处使用apply()进行提交还没有完成，那么commit()将会阻塞直到所有的异步操作完成。</p>
<p>对于每一个进程，SharedPreferences都是单例的，因此我们直接使用异步的apply()进行提交也是安全的。同时你也大可不必担心Android组件状态的改变导致的apply()提交失败，因为Android会保证每一次状态的改变前都会完成apply()操作。</p>
<blockquote>
<p>如果你对于提交操作的返回值没有要求，出于性能考虑，建议你使用apply()。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=17177324&auto=0&height=66"></iframe>

<p>在Android开发中，我们经常会使用SharedPreferences对一些指定数据类型的数据进行持久化存储。</p>
<p>当我们需要写入数据时，我们需要借助于SharedPreferences.Editor进行数据的写操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"test"</span>, MODE_PRIVATE).edit();</span><br><span class="line">editor.putString(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure></p>
<p>执行完这段代码，我们就能将key－value这组数据存储在/data/data/your_package_name/shared_prefs/目录下。  </p>
<p>我们注意到，在这里我们使用commit()进行数据的提交，实际上，SharedPreferences还提供了另一个方法apply()来提交需要保存的数据，那么这两者有什么区别呢？<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://leotse90.com/tags/Android/"/>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一切为了适配－Android的单位和尺寸]]></title>
    <link href="http://leotse90.com/2016/08/04/size-in-Android/"/>
    <id>http://leotse90.com/2016/08/04/size-in-Android/</id>
    <published>2016-08-03T16:33:56.000Z</published>
    <updated>2016-08-03T16:38:19.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/adapter.jpg" alt="adapter"><br></center>

<a id="more"></a>
<h2 id="适配，适配，适配">适配，适配，适配</h2><p>我们都知道，支持Android系统的设备品类繁多，从移动手机到平板，从车载设备到穿戴设备，到处都能看到Android系统的身影。这些设备的应用场景，搭配硬件各异，因此它们所使用的屏幕也不同。  </p>
<p>就拿我们平常看到的移动电话来说，也分低端机、中端机还有高端机，它们的屏幕分辨率也会有很大的差异。这就需要我们Android开发者针对不同分辨率的手机、设备进行适配。  </p>
<p>Android中主要有两块尺寸需要我们注意，一个是控件宽高，一个是字体大小。这两块在Android系统中都有相应的单位，接下来详细介绍它们。</p>
<h2 id="px_VS_dp">px VS dp</h2><p>px：pixels的简写，指的是屏幕像素，我们知道，像素是屏幕上可以显示的最小单位。我们看到的图像都是由一个个的像素构成。因此，顺理成章，我们可以用px来作为控件的尺寸单位。比如：我们可以指定一个按钮的宽为160px，高为50px，初看一下并没有不妥，但是该按钮在不同的分辨率的屏幕上表现就会大相径庭，在分辨率为320x480像素的设备上，这个按钮就会占屏幕宽度的一半，但是如果换到分辨率为640x960像素的设备上，那么按钮就会只占屏幕到1/4。因此我们看到使用px在指定控件的时候的局限性，这时候我们就会提到另一个单位dp。  </p>
<p>dp：要想了解dp，就首先得知道一个概念：屏幕密度。屏幕密度，单位为dpi（density per inch），直接理解就是每英寸的像素数。拿分辨率为320x480像素的设备来说，如果它的设备屏幕宽为2英寸，高为3英寸，那么它的屏幕密度就是160dpi。对于同样的尺寸，如果分辨率为640x960像素，那么它的屏幕密度就是320dpi。由此我们可以得出结论：屏幕密度越高，屏幕的效果越好。<br>dp，全称为dip（device independent pixels，设备无关像素），也就是说这是一个和设备无关的尺寸单位，无论是WVGA还是HVGA或者是QVGA，它都是适用的。在Android系统中，如果屏幕密度为160dpi，那么1px＝1dp。</p>
<blockquote>
<p>当屏幕density为240时，使用hdpi的资源；<br>当屏幕density为160时，使用mdpi的资源；<br>当屏幕density为120时，使用ldpi的资源。</p>
</blockquote>
<p>要想获取Android设备的屏幕密度，可以使用下面的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> xdpi = getResources().getDisplayMetrics().xdpi;</span><br><span class="line"><span class="keyword">float</span> ydpi = getResources().getDisplayMetrics().ydpi;</span><br><span class="line"><span class="keyword">float</span> density = getResources().getDisplayMetrics().density;</span><br></pre></td></tr></table></figure></p>
<h2 id="pt_VS_sp">pt VS sp</h2><p>同理，字体的尺寸也会有对应有pt和sp。<br>pt：point，字体的单位，磅数，1pt＝1/72英寸。<br>sp：可伸缩像素，它的理念和dp一样，都是和设备无关，很好的解决了文字的适配问题。</p>
<p>在Android规范中，如果要指定控件或者布局的固定大小，建议使用dp作为单位，如果要指定文字大小，则建议使用sp作为单位。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/adapter.jpg" alt="adapter"><br></center>]]>
    
    </summary>
    
      <category term="Android" scheme="http://leotse90.com/tags/Android/"/>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告之由ROI分解看市场形态]]></title>
    <link href="http://leotse90.com/2016/07/04/Mobile-AD-ROI/"/>
    <id>http://leotse90.com/2016/07/04/Mobile-AD-ROI/</id>
    <published>2016-07-04T15:06:11.000Z</published>
    <updated>2016-07-09T04:18:52.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/ROI-banner.jpg" alt="ROI"><br></center>

<a id="more"></a>
<h2 id="概述">概述</h2><p>我们常常拿广告和推荐系统做对比，特别是展示类广告，但是推荐和广告的一个本质区别是他们的首要准则不同。</p>
<blockquote>
<p>推荐系统的首要准则是<strong>用户兴趣</strong>；<br>在线广告的首要准则是<strong>投资回报比（ROI）</strong>；</p>
</blockquote>
<p>推荐系统主要是为用户推荐同质化的物品，比如你在淘宝上购物的时候侧栏的推荐位都是同类的商品；<br>而广告则不同，它的目的是为了收益最大化，它会在用户兴趣与收益之间权衡后，展示最有可能得到最大收益的广告内容。</p>
<h2 id="在线广告系统的ROI">在线广告系统的ROI</h2><p>在ROI模型中，我们主要关心的是R（Return），因为I（Investment）有各种各样的方法和途径。</p>
<p>下面是Return的公式：</p>
<center><br><img src="/img/ROI.png" alt="ROI"><br></center>

<p>这其中，u代表着点击率（CTR），也就是对于特定的用户u来说，在特定场景c下他或她点击广告a的概率；v（Click value）代表着这次点击的价值，由于这时候用户已经离开了广告所在的场景来到了广告的着陆页（可以是应用商店，也可以是网站），因此我们计算v的时候并不需要考虑广告投放的场景c，也就是说v很大程度上取决于这个用户u和广告a本身的内容。而等号右边的e代表eCPM，即预期收益。</p>
<h2 id="根据ROI分解的市场形态">根据ROI分解的市场形态</h2><p>根据ROI的公式，我们可以将整个在线广告市场进行细分：</p>
<h3 id="CPM市场">CPM市场</h3><p>我们如果只看等号的右边，也就是eCPM固定。这意味着广告每次展示的收益都是确定的，比如eCPM为$10，那么该广告展示1000次你获得的收益就是10美元。这种广告形式当然最大的受益者就是publisher，因为只要用户看到广告就能获益。这种广告比较适合于短期效果不明显的品牌广告，比如可口可乐的品牌广告，它不寄希望于你能马上购买它的产品或服务，而是希望你能记住它的品牌。<br>CPM的定价往往是由需求方来制定的。在国内比较常见的是包量，也就是常见的按天收费等。  </p>
<h3 id="CPC市场">CPC市场</h3><p>在CPC市场中，CTR是动态变化的，但是点击价值v是相对固定的。一般的，广告网络来估算广告的CTR，因为他们面向用户，可能有比较丰富的用户数据以及广告行为数据，可以比较准确的估计用户点击广告的概率，但是这次点击能给广告主带来多大的收益广告网络方并不清楚，因此这里的点击价值v由需求方来估算。</p>
<h3 id="CPA/CPS/ROI市场">CPA/CPS/ROI市场</h3><p>如果CTR和点击价值v都是动态变化的，那么这种类型的广告市场我们就称之为CPA或CPS市场。这种市场走到另一个极端，广告市场本身揽下了所有的风险，需求方按照效果付费，比如游戏应用APP，用户通过广告进入下载页下载APP后，游戏开发者就根据定价给媒体付费。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/ROI-banner.jpg" alt="ROI"><br></center>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[［转］互联网思维到底是什么？]]></title>
    <link href="http://leotse90.com/2016/05/15/internet_thinking/"/>
    <id>http://leotse90.com/2016/05/15/internet_thinking/</id>
    <published>2016-05-15T15:46:11.000Z</published>
    <updated>2016-05-16T00:24:29.000Z</updated>
    <content type="html"><![CDATA[<center><br><img src="/img/1.png" alt="internet_thinking_1"><br></center><br><a id="more"></a><br><center><br><img src="/img/2.png" alt="internet_thinking_2"><br></center>

<center><br><img src="/img/3.png" alt="internet_thinking_3"><br></center>

<center><br><img src="/img/4.png" alt="internet_thinking_4"><br></center>

<center><br><img src="/img/5.png" alt="internet_thinking_5"><br></center>

<center><br><img src="/img/6.png" alt="internet_thinking_6"><br></center>

<center><br><img src="/img/7.png" alt="internet_thinking_7"><br></center>

<center><br><img src="/img/8.png" alt="internet_thinking_8"><br></center>

<center><br><img src="/img/9.png" alt="internet_thinking_9"><br></center>

<center><br><img src="/img/10.png" alt="internet_thinking_10"><br></center>

<center><br><img src="/img/11.png" alt="internet_thinking_11"><br></center>

<center><br><img src="/img/12.png" alt="internet_thinking_12"><br></center>

<center><br><img src="/img/13.png" alt="internet_thinking_13"><br></center>

<center><br><img src="/img/14.png" alt="internet_thinking_14"><br></center>

<center><br><img src="/img/15.png" alt="internet_thinking_15"><br></center>

<center><br><img src="/img/16.png" alt="internet_thinking_16"><br></center>

<center><br><img src="/img/17.png" alt="internet_thinking_17"><br></center>

<center><br><img src="/img/18.png" alt="internet_thinking_18"><br></center>

<center><br><img src="/img/19.png" alt="internet_thinking_19"><br></center>

<center><br><img src="/img/20.png" alt="internet_thinking_20"><br></center>

<center><br><img src="/img/21.png" alt="internet_thinking_21"><br></center>

<center><br><img src="/img/22.png" alt="internet_thinking_22"><br></center>

<center><br><img src="/img/23.png" alt="internet_thinking_23"><br></center>

<center><br><img src="/img/24.png" alt="internet_thinking_24"><br></center>

<center><br><img src="/img/25.png" alt="internet_thinking_25"><br></center>

<center><br><img src="/img/26.png" alt="internet_thinking_26"><br></center>

<center><br><img src="/img/27.png" alt="internet_thinking_27"><br></center>

<center><br><img src="/img/28.png" alt="internet_thinking_28"><br></center>

<p>转自 鸟哥笔记<a href="http://mp.weixin.qq.com/s?__biz=MjM5MzIxNTQ2MA==&amp;mid=2650658054&amp;idx=1&amp;sn=e7496c65b57f6b34a5b9cb86bf64d644&amp;scene=0#wechat_redirect" target="_blank" rel="external">天天都在说的“互联网思维”，这28张图总算把它彻底讲清楚了</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="/img/1.png" alt="internet_thinking_1"><br></center><br>]]>
    
    </summary>
    
      <category term="IT" scheme="http://leotse90.com/tags/IT/"/>
    
      <category term="互联网" scheme="http://leotse90.com/categories/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告之互联网广告产业链]]></title>
    <link href="http://leotse90.com/2016/05/14/Mobile-AD-industry-chain/"/>
    <id>http://leotse90.com/2016/05/14/Mobile-AD-industry-chain/</id>
    <published>2016-05-14T13:21:32.000Z</published>
    <updated>2016-05-14T13:44:32.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/cn_chain.png" alt="cn_chain"><br></center>

<a id="more"></a>
<p>这张图估计大多数接触互联网广告的人都接触过。但是这里还是要放这张图，窃以为理解这张图已经可以算是理解了这个行业。本人对于广告这个行业来说也只能说是刚入门，这里面的门道太多，只能说路漫漫其修远兮了。</p>
<blockquote>
<p>1.Advertiser：广告主<br>2.Agency：广告代理<br>3.DSP：需求方平台<br>4.ADX：广告交易平台<br>5.Ad network：广告网络／广告平台<br>6.SSP：供应方平台<br>7.Publisher：媒体</p>
</blockquote>
<p>这次我只打算简单描述一下这个互联网广告产业链。因为每一个环节展开都需要花很长的篇幅。接下来会针对Ad Network，Adx，RTB，SSP&amp;DSP分别详细介绍。</p>
<p>下面附赠一张CPM广告的：  </p>
<center><br><img src="/img/chain.jpg" alt="chain"><br></center>]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/cn_chain.png" alt="cn_chain"><br></center>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[［转］浅谈APP运营推广：该如何的精准投放广告？]]></title>
    <link href="http://leotse90.com/2016/05/04/how-to-delivery-ad/"/>
    <id>http://leotse90.com/2016/05/04/how-to-delivery-ad/</id>
    <published>2016-05-04T15:36:19.000Z</published>
    <updated>2016-05-04T15:40:34.000Z</updated>
    <content type="html"><![CDATA[<p><center><br><img src="/img/apptuiguang.jpg" alt="apptuiguang"><br></center><br><a id="more"></a></p>
<h2 id="前言">前言</h2><p>截至今年3月底，据工信部的数据，我国的智能手机用户总数已达12.9亿，同比增长3.6%，其中4G用户一季度增加6千万户，我国4G用户已达1.6亿户。伴随着移动互联网的快速发展，衔接有软件和硬件升级，人们已经习惯了用手机做任何事情，移动互联网已经渗透到我们生活中的方方面面，包括衣食住行。</p>
<p>那么作为一个移动互联网行业的从业者，特别是APP运营推广圈的朋友们，该如何在海量的手机用户中精准的获取到用户呢？身处这样一个移动互联网的大时代背景下，做app推广就应该站在不一样的高度去纵观全局，不能只为了推广而去推广，值得深思的问题是我们该如何做好运营？如何做好用户？一切都是为了用户，为了用户的一切。推广也是如此。</p>
<p>那么，今天我想要讲的就是我们在选择渠道的时候，怎样利用最低的成本找到精准用户 获取一手流量？</p>
<h2 id="一-该考虑：如何选择有效的渠道？">一.该考虑：如何选择有效的渠道？</h2><p>APP推广渠道主要分为付费和免费合作两种方式。流量为王的时代，免费推广基本上已经失去了它原本的意义。我想说的是在移动互联网的行业里，时间其实比钱更重要，免费的渠道虽然不花钱，但是花时间，时间和人力换算成成本，依然很高昂。</p>
<p>所以对于免费渠道推广我就不一一举例说明，今天主要讲讲付费的渠道推广。</p>
<p>现在市场上主流的APP从开发环境和搭载系统上来区分主要分为三种类型，分别是ios版本、android版本和WP8系统。</p>
<p>所以，针对于这个不同系统的因素，我们在选择渠道的时候也要考虑进去，以免你花钱买来的流量白白浪费，并且在对于推广数据分析的时候影响你对渠道</p>
<p>首先，目前可供选择的app推广渠道都有哪些？</p>
<h3 id="1-应用市场下载渠道">1.应用市场下载渠道</h3><p>（主要介绍安卓，因为ios渠道相对单一）</p>
<p>根据艾瑞咨询的统计数据分析显示，目前安卓应用日均下载量约为1.3亿，这也是由于应用市场和PC端各大软件管家以及下载站起步较早，已经培养了用户的下载习惯，所以针对于app，各个软件下载平台已成为首选的应用下载道。</p>
<p>一般情况，用户初次的下载，都是来自推荐以及曝光性搜索。一些推广人员研究某些市场的排名规则，进行关键词、评论、星级，下载量等的优化，更牛的推广人员是直接占据大量热门APP名称，使用户在搜索关键词的时候命中这些热门APP名称    使自己的搜索结果排序靠前，以及优化排行榜排名（刷榜），提升曝光。</p>
<p>为满足推广人员对于当下热门的第三方应用市场渠道的推广需求，有代理公司提供这种专业的推广服务，当然不花钱你自己也能做，耗人耗力。不明白为什么这样子的话，可以回过头看前言部分。</p>
<p>应用市场下载渠道的推广成本与费用，若按cpc计算大致为0.5元~1.5元不等；若按CPD大概为2~5元；至于CPT根据位置不同从几千到几万一天不等，不过我不推荐CPT这种方式。当然有钱你可以做，</p>
<p>渠道优势：用户质量相对来说高，量大，可快速获取用户</p>
<p>渠道劣势：留存转化低，做精准用户的应用那就更难了，市场多达200家以上，主流市场十几家左右，选择一个靠谱的难，框架合作随可降价但是维护成本高。</p>
<h3 id="2-广告联盟以及wap流量渠道">2.广告联盟以及wap流量渠道</h3><p>广告联盟是很常见的一种推广方式，我也一直向圈子里面的朋友推荐这种渠道，因为我在联盟里做过一段时间，深谙其道。虽然很多人对这种渠道提出来很多质疑，比如，难以把控真假效果，量太小，占用资源太多，但是，我想说，你如果把研究如何做aso的这种精力放到研究这种小渠道的身上，我想大家也会开辟一个新渠道出来，众多的质疑以及广告联盟依然能活的这么潇洒，自然有它存在的道理。</p>
<p>接下来就我个人的一点小见解和各位看官分享一下。</p>
<p>目前比较大的几家联盟如:友盟（别以为友盟就是一个数据统计后台，其实他是做联盟的）、亿邦动力、微云 、有米、admod 、力美等，其他的一些小联盟那就更多了，市场上目前我知道的不下于100家。这么多的联盟，这么多流量，我们该怎么样的好好利用一下呢？</p>
<p>渠道推广说白了就是曝光，想尽一切办法把自己的产品展示在用户的面前，那么最好的曝光有哪些？视频最直观，其次是图片加文字，用到最多的就是图片文字，根据自己的产品不同选择投放的广告联盟的不同选择投放的网站以及位置的不同，适配相应的文字图片内容，不断试错优化。试错上两三个渠道，效果以及量级稳定后，可以选在十来家一起投放。</p>
<p>在选择类似这种小渠道的时候，千万注意多找几家，因为这种渠道骗子还挺多，一般靠谱的优质渠道，你可以提出自己想要的要求（量级、留存、活跃度、约定结算日期等），然后定价、签订合同，后付款。我们的权限比较自由，这种渠道其实也是缺一手产品，我们就像一个中介，把有量的网站主聚合在一起，再去找产品。依赖于这种圈子过活的人真的不在少数。有些大联盟用户行为数据分析很专业，比我们做的要精确得多的多。</p>
<p>费用成本，按cpc 0.3元~0.8元，cps(激活成本1.5~3元）</p>
<p>渠道优势：起量快，成本比较低廉，换量的人比较喜欢这种渠道，一般性合作后附款</p>
<p>渠道劣势：存在作弊行为，媒体维护成本高，用户质量一般。沟通监控成本高，这种方式需要监控订单来保证用户质量，操作比较复杂</p>
<h3 id="3．社会化营销渠道">3．社会化营销渠道</h3><p>除了以上提到的传统渠道，近几年来利用微博微信社交新闻媒体等社会化营销渠道推广APP也成为很热门的选择。我圈子内的朋友基本上每天都在围绕着这些渠道讨论推广方案。渠道量确实很可观，而且初期做这种渠道的许多产品夸张地说真是“一夜暴富”，因为我们产品所需有的用户基本上都在这些渠道里面，任何产品，不管你需要多么精准的用户他都隐藏在这些渠道里。说到此，那我们在此类渠道的时候，该如何有效利用?该如何规避一些问题？</p>
<p>由此，社会化渠道面临一个最常见的问题，就是无法衡量在口碑传播过中产生的真正下载量。另外，口碑营销的传播其实与产品本身有密切效果。产品是否真正有价值，能够刺激用户去使用也是很重要的一部分。但营销的价值在于放大产品某一方面的优点，或者包装一个噱头，需要产品和运营人员精心策划，有步骤有节奏的去进行营销，才能收到良好效果。        </p>
<p>渠道类别：腾讯系（广点通、智慧推）百度系（百度贴吧、百度百通、百度直通车）新浪（粉丝通、扶翼、九宫格）今日头条信息流 陌陌信息流、网易、搜狐等  </p>
<p>费用成本：每个渠道推广方式是不一样的，竞价模式，按曝光 展示 点击 下载等都有，但是基本核算成一个下载的话跨度比较大3-15元/下载。</p>
<p>渠道优势：精准化获取定向用户，用户质量比较高，品牌曝光比较好，效果可控</p>
<p>渠道劣势：在目前未能全面有效的一个统计后台分析成本，只针对于当天的数据来判断成本的话显得比较高，以至于让我们无法判别这种渠道到底是什么样的效果。</p>
<h3 id="4．厂商预装以及刷机">4．厂商预装以及刷机</h3><p>对很多有实力的大公司来说是个不错的选择，拉卡拉被联想控股，预装联想手机属于内部资源置换，如果要拓展外部厂商资源，资金不充足的话不是首选渠道。</p>
<p>费用成本：按照预装量付费价格在0.5元~1元之间，cpa按照激活付费1.5元~4元不等。</p>
<p>渠道优势：量大，平均成本不算高。</p>
<p>渠道劣势：跟进成本高，用户类型广，精准用户比例相比其他渠道偏低。</p>
<h2 id="二．怎么样投放广告？">二．怎么样投放广告？</h2><p>有一句话做渠道的人都清楚，这句话，让所有的老板无奈，甚至成为一些人的借口，这句话是：我们知道有一半广告费是在浪费，但是没人知道是哪一半。</p>
<p>那么我们如何才能让广告的效果达到最大化呢？</p>
<p>确定产品目标人群的时间以及分布，现在都在讲精准化营销，这个说法是对的，但是没有人做得到，因为你再有本事，你也不可能时刻知道每个人的行为，更何况那么多用户，所以在选择产品投放渠道的时候，我们首先要分析你的目标用户的行为喜好兴趣等等这些因素，找到他们都隐藏在哪里，做到这点以后，我们再去找到所选渠道对应的栏目位置配合相关素材文字去做精准投放。其次，最简单的才是最有效的，所投放的广告如果偏离的目标用户群体的浏览习惯，那也是失败的，更重要的是渠道推广是需要媒体传播配合的，但同时需要避免轰炸式烂广告，这样同样会玩坏用户。</p>
<p>下面我为各位分析一下，渠道推广时需要怎么样去判断一个渠道成功与否。</p>
<h3 id="1-品牌曝光">1.品牌曝光</h3><p>曝光量是广告主品牌在受众面前出现次数的体现，是产生点击、反馈的前提。大量的品牌曝光有利于加深受众对品牌产品的认识，进而提升品牌影响力。</p>
<h3 id="2-下载激活(冲榜和留存)">2.下载激活(冲榜和留存)</h3><p>下载激活主要针对专业和游戏客户，他们推广的主要需求在于其产品的冲榜以及获取更多的真实用户。利用各种推广方式使客户产品名列榜单前列,通常情况下，榜单排名决定了自然真实下载的用户。</p>
<h3 id="3-订单销量">3.订单销量</h3><p>主要针对于电商类客户，客户转化率是电商界人士最关心的一个指标，真金白银的广告费究竟起了多大效果?带来了多少订单?为达到提高订单销量的效果，广告的展示方式和展示内容需要与用户的使用习惯深度契合。</p>
<h3 id="4-促销活动">4.促销活动</h3><p>诸如教育类、汽车类客户，为提升品牌影响力，经常以培训、试驾等促销活动的形式进行推广。</p>
<p>通常情况下，广告主在冲榜的预算最多，达到50%，一般新产品上架都要先做冲榜，据运营高手透露，新品App下载量达到10万以上才能进到榜单前100，如果不做冲榜新产品很难被用户看到。</p>
<h2 id="三．总结">三．总结</h2><p>以上是柴哥介绍的app推广如何选择渠道和怎么投放渠道的两个问题，在后面我还会讲到如何做到不是很精准的精准化渠道营销，在渠道推广的行业里，不要指望着读几篇文章就去照猫画虎的去尝试，每个产品都有自己不一样的推广思维，在互联网发展瞬息万变的今天，随时都会出现新的可能，在这些可能中找到适合自己的推广方案才是最关键的，任何一款好的产品都有一个核心，所以，我认为互联网成功的秘诀是能够拿到有粘性的低成本的推广方案。</p>
<p>最后我想说一款真正好的产品，即使在没有推广的情况下活跃用户也会持续增加，更优秀的甚至暴增。尤其互联网产品更是主要以产品用户体验为导向，而不是营销为导向的。当然我不否认好的营销推广会使好的产品更快的为大众所接受。所以，好的产品是前提，推广只是为了让更多不知道却有需求的用户知道它。</p>
<p>本文为作者 @喵哆啦柴哥 投稿发布，转载请注明来源于人人都是产品经理并附带<a href="http://www.woshipm.com/operate/245479.html" target="_blank" rel="external">本文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><center><br><img src="/img/apptuiguang.jpg" alt="apptuiguang"><br></center><br>]]>
    
    </summary>
    
      <category term="广告杂谈" scheme="http://leotse90.com/tags/%E5%B9%BF%E5%91%8A%E6%9D%82%E8%B0%88/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[See You Again]]></title>
    <link href="http://leotse90.com/2016/04/14/see-you-again/"/>
    <id>http://leotse90.com/2016/04/14/see-you-again/</id>
    <published>2016-04-14T15:50:50.000Z</published>
    <updated>2016-05-04T16:31:22.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=31607266&auto=0&height=66"></iframe>

<center><br><img src="/img/kobe0.jpeg" alt="kobe0"><br><strong>Legend! Forever!</strong><br></center><br><a id="more"></a><br><br><center><br><img src="/img/kobe1.jpg" alt="kobe1"><br><strong>远去的黄金一代，远去的青春岁月。</strong><br></center>


<center><br><img src="/img/kobe2.jpg" alt="kobe2"><br><strong>我转身，全世界已经在我脚下。</strong><br></center>


<center><br><img src="/img/kobe3.jpg" alt="kobe3"><br><strong>黑曼巴，再见！</strong><br></center>]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=31607266&auto=0&height=66"></iframe>

<center><br><img src="/img/kobe0.jpeg" alt="kobe0"><br><strong>Legend! Forever!</strong><br></center><br>]]>
    
    </summary>
    
      <category term="远方与诗" scheme="http://leotse90.com/tags/%E8%BF%9C%E6%96%B9%E4%B8%8E%E8%AF%97/"/>
    
      <category term="随笔" scheme="http://leotse90.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告主要转化归因方式]]></title>
    <link href="http://leotse90.com/2016/04/09/mobile-advertising-attribution/"/>
    <id>http://leotse90.com/2016/04/09/mobile-advertising-attribution/</id>
    <published>2016-04-09T13:48:03.000Z</published>
    <updated>2016-04-12T16:01:56.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/creative_ad.jpg" alt="creative_ad"><br></center>

<a id="more"></a>
<h2 id="概述">概述</h2><p>在移动互联网广告圈子里，无论你是Publisher，或者Ad Network，还是Ad Tracker，你都有必要了解移动广告的转化归因方式。</p>
<p>了解移动归因方式，可以帮助你窥探移动广告从投放到转化中很重要的一环，那就是如何甄别广告转化的归属。我们知道主要的移动互联网广告种类有CPM、CPC、CPA，这些不同的广告类型在转化归因上大同小异，所以在介绍具体的归因方式的时候再行说明。</p>
<p>首先，一般有下面四种归因方式：  </p>
<blockquote>
<p>1.Google Install Referrer（Google 安装引荐网址）<br>2.Identifier Matching（标识符匹配）<br>3.Fingerprint Matching（指纹匹配）<br>4.Open URL with Click ID（带clickid的打开链接）</p>
</blockquote>
<p>Open URL with ClickID主要用于点击归因，并不适合于安装归因，因此不在我们的讨论范围内。接下来，我们详细讨论这几种归因方式的原理以及适用范围。</p>
<h2 id="Google_Install_Referrer">Google Install Referrer</h2><p>Google Install Referrer，我们在<a href="http://leotse90.com/2016/03/21/Mobile-Ad-GooglePlay/">移动广告之GooglePlay推广流程</a>有过介绍，这里简单说明一下，用户点击Google Play的推广URL安装的应用，GP会在该应用启动的时候发送一个Install Referrer广播告知其推广的来源，被推广的应用会上报该referrer到广告主后台，从而确定该转化的来源。</p>
<p>Google Install Referrer可以用来唯一标识广告商或者广告合作伙伴，这就是它可以用来确定转化的原因，有兴趣的话，你可以使用<a href="https://developers.google.com/analytics/devguides/collection/android/v3/campaigns#google-play-url-builder" target="_blank" rel="external">Google Play URL Builder</a>生成一个带referrer的推广URL，你可以了解一下其中每一个字段的用途（前提是你能翻墙）。下面是一个referrer的示例：<br><code>https://play.google.com/store/apps/details?id=com.test.appname&amp;referrer=af_tranid=com.test.appname_324a78c1-c345-5cba-7a76-bc88-aacb2318a101&amp;pid=clicksmob_int&amp;c=US-Android-01&amp;click_id=cA_12487526aa_278973188a866872ac981007bc8_zl&amp;af_siteid=1111&amp;advertising_id=yourgaid&amp;app-id=com.test.appname</code></p>
<p>Google Install Referrer主要适用于Google Play应用商店推广的APP，它不适用于Android上除GP以外的应用商店（这点不难理解），而且它也仅仅在APP安装的时候才有意义。</p>
<h2 id="Identifier_Matching">Identifier Matching</h2><p>Android平台上常见的广告标识符有GAID（Google广告ID，可以唯一标识一台Android设备，可重置）；GAID是一种由Google Play服务提供的唯一、用户特定可重置广告ID，它会以类似于38400000-8cf0-11bd-b23e-10b96e40000d的通用唯一标识符 (UUID) 格式公开用于访问字符串形式用户广告ID的API。如：<br><code>https://12345.api-01.com/serve?action=click&amp;publisher_id=100&amp;site_id=3000&amp;google_aid=38400000-8cf0-11bd-b23e-10b96e40000d</code><br>尽管我们最依赖广告标识符进行归因，但在某些情况下无法使用广告标识符。例如，不支持广告标识符以及用户从非 Google Android 应用商店下载的旧有版本。如果广告标识符不可用，我们还可以依赖以下设备标识符进行归因：Android ID（适用于Android设备的ANDROID ID是一个64位数字（十六进制字符串形式），在设备首次启动时随机生成，通常在设备生命周期内保持不变）、设备 ID（适用于Android设备的设备 ID 是一种采用小写格式值的唯一设备ID）、MAC地址（联网设备的MAC地址是一个网络地址，用于对设备的无线网络适配器进行唯一标识，采用以冒号分隔的大写形式，例如，“AA:BB:CC:DD:EE:FF”）。</p>
<p>iOS平台上的标识符主要就是IFA（可唯一标识一台iOS设备，但是也可以通过刷机重置）。Apple从iOS6开始引入了广告商标识符 (IFA)，它为应用提供用于为广告服务的标识符的访问权，并提供用以指示用户是否启用了Limit Ad Tracking（限制广告追踪）功能的标志。IFA 值是每台设备唯一的字母数字字符串，使用带连字符的大写形式。如：“AAAAAAAAA-BBBB-CCCC-1111-222222220000”。尽管我们最依赖广告标识符进行归因，但在某些情况下无法使用广告标识符。例如，不支持广告标识符的旧有版本。如果广告标识符不可用，我们依赖开放UDID进行归因，“开放 UDID”是iOS系统 UIDevice 类遭弃用的唯一标识符属性（又名 UDID）的简易替代者。它是一个长 40 个字符（20 个字节）的十六进制值。</p>
<p>标识符匹配的归因流程如下：<br>1.用户点击应用上的广告。一方面，用户设备会跳转到应用市场，另一方面，设备会向Tracker发送带有包含用户设备标识符的Ad Click URL；<br>2.用户点击安装广告上的应用后，应用会上报该用户设备标识符给Tracker；<br>3.Tracker对比点击时上传的用户设备标识符以及用户安装后上传的设备标识符，如果一致，就可以确定这个转化的来源。</p>
<p>Identifier Matching不仅适用于转化的归因，同样适用于点击事件、浏览事件等，它是适用范围最广的转化归因方式。</p>
<h2 id="Fingerprint_Matching">Fingerprint Matching</h2><p>要理解Fingerprint Matching转化归因，首先你得理解什么是Fingerprint，我们可以把Fingerprint理解为可以唯一标识一个用户的基本信息（尽管很多时候并不能真正唯一映射到一个确定的用户），它可以是用户的IP地址，也可以是用户设备的可用的HTTP头，这些基本信息可以用于归因分析中创建用户的点击事件的指纹。</p>
<p><strong>当一个用户安装了一个移动应用，植入在该应用的归因分析SDK就会收集该设备的指纹信息，然后上报到归因分析平台，平台会生成一个设备指纹并有序地在匹配的指纹中查找，归因分析平台会将转化算在匹配的所有指纹中最后一次带来点击上。</strong></p>
<p>默认情况下，匹配设备指纹的归因时间窗口是24小时，因此为了找到匹配，归因分析只会考虑24小时内发生的点击事件。当然也有一些广告网络和广告伙伴、媒体声称他们能将归因窗口扩展至48小时甚至72小时，但是实际上一旦超过24小时指纹匹配的统计的精度就会下降。</p>
<p>当一个用户点击一个广告跳转URL，归因分析SDK会设置其HTTP cookie，用于区分唯一点击数与Gross点击（理解为毛点击数），该cookie会在24小时后失效。<br>如果设备上没有设置cookie，归因分析SDK就会认定这个设备是一个从未记录在案的新设备，并记录这次点击为唯一点击和Gross点击；<br>如果设备上已经设置了cookie，归因分析SDK就会认为这是一个已经存在的用户（24小时内），于是只记录这次点击为一次Gross点击，而并不会记录其为唯一点击。</p>
<p>归因分析中会根据Gross点击和唯一点击去判断一个用户是新增还是已经存在。如果归因分析平台认定该用户是过去24小时已经存在的用户，那么平台就不会重新创建该用户的指纹，相反的，平台将会更新指纹的更新时间为最后一次点击的时间戳。因此，用户点击多次并不会创建额外的设备指纹，从而可以降低错误匹配数。</p>
<blockquote>
<p>关于Gross点击与唯一点击，举一个简单的例子：<br>用户A点击：广告1、广告2、广告1<br>用户B点击：广告1、广告3<br>那么：<br>广告1：2次唯一点击以及3次Gross点击；<br>广告2：1次唯一点击以及1次Gross点击；<br>广告3：1次唯一点击以及1次Gross点击。</p>
</blockquote>
<p>指纹匹配在移动应用后台中异步运行，此方法可强制打开浏览器，不会妨碍用户体验。由于使用另外的几种归因可提供1:1的准确性，而指纹匹配取决于统计概率（大约86%的统计概率），因此另外两种归因方法始终胜过指纹匹配。</p>
<h2 id="总结">总结</h2><p>以上三种转化归因方式都可以用于安装的归因，但是它们又各有差异，下图（来自网络）很好地展现了它们的适用场景以及差异：  </p>
<center><br><img src="/img/attributions_method.png" alt="attributions_method"><br></center>

<p>了解这些这三种转化归因的差异以及适用范围，可以帮助我们在实际中选取合适的转化归因方式进行归因确认。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/creative_ad.jpg" alt="creative_ad"><br></center>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何监测出Android推广渠道作弊？]]></title>
    <link href="http://leotse90.com/2016/03/31/How-to-detect-the-cheat-in-android-campaign/"/>
    <id>http://leotse90.com/2016/03/31/How-to-detect-the-cheat-in-android-campaign/</id>
    <published>2016-03-30T16:07:07.000Z</published>
    <updated>2016-03-31T01:14:13.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p><em><strong>本文整理自知乎，<a href="https://www.zhihu.com/question/22958167/answer/81144971" target="_blank" rel="external">如何监测出安卓推广渠道作弊？</a></strong></em>。<br><em><strong>文章比较系统地介绍了三个境界的防作弊手段，对于APP运营者有一定价值，同时对于广告渠道来说也有一定的意义。</strong></em></p>
<p>如何判断渠道的质量和狡猾程度,如何判断用户是否真实、是否来自墙、是否机刷or肉刷而来,是运营人员乃至整个公司最为头疼的事情,因为事关成本,而寒冬将至,成本则事关生死,不可谓不大。</p>
<p>那么我们如何识别真假用户,从而有效的管理渠道呢?从运营的角度,要是能根据上量的用户的综合价值来给渠道付费,那当然就是最佳策略。什么叫用户的综合价值,那就是该用户为公司创造出来的综合价值,价值包括但不限于:</p>
<blockquote>
<p>1) 直接利润价值:比如购买行为,产生收入和潜在的利润;<br>2) 内容价值:比如产生了积极的、优质内容,间接的创造价值等;<br>3) 传播价值:比如因为ta的传播,引发了其他用户的使用等等;<br>4) 衍生价值:停留时长或关注时长,所带来的广告收益等;</p>
</blockquote>
<p>每个App的行业不同,这四种价值侧重不同。<br>因为按照激活这个时间作为结算的时间节点对我们来说,这个时间窗口太短,对甄别用户的真假带来巨大的挑战。<br>在这个巨大的挑战面前,就分化出作弊防护的不同境界。<br><a id="more"></a></p>
<h3 id="第一个境界——事后诸葛亮,事前猪一样">第一个境界——事后诸葛亮,事前猪一样</h3><p>稍微量化一下这个境界,发现作弊的时间需要7天以上,能感知到40%左右的假量用户,其他超过半数的作假不能确保;通俗的讲,知道自己被骗了,但不知道骗了多少。他们的手段一般是这样的:</p>
<p>(一) 看留存率<br>根据长期的斗争经验,他们发现渠道刷量会选择在次日、7日、30日这些重要时间点上导入用户数据。然后发现App在次日、7日、30日这些关键时间点上的数据明显高于其他时间点。而真实的用户的留存曲线是一条平滑的指数衰减曲线,如果他们发现留存曲线存在陡升陡降的异常波动,基本上就是渠道干预了数据。</p>
<p>(二) 看用户终端信息<br>1) 低价设备排名<br>根据经验分析渠道的新增用户或者启动用户的设备排名。如果发现某款低价设备排名异常靠前,他们就视其为异常,开始报警。</p>
<p>2) 新版本操作系统的占比<br>经过渠道多年蹂躏,运营人员终于发现,很多渠道刷量工作室在操作系统版本的适配上会有延时。查看渠道用户的操作系统时,可以和全体手机网民的操作系统的分布做比较。</p>
<p>3) wifi 网络的使用情况<br>比如说2G、3G、4G的使用比例分布是否正常等等。</p>
<p>(三)看延伸信息<br>1) 注册昵称的分布和规律,很多低端的刷假量的注册昵称有很强的规律性,各位运营看官肯定遇到这样的情况;<br>2) 注册手机号码的归属地分布,这点相比各位看官也遇到过,某个渠道上来的用户手机号码不但来自某运营商的某个地市,甚至都是连号手机号码。</p>
<p>小结:该境界中的运营者严重依赖于个人经验,工具手段不专业化,操作效率低下,耗费人力物力,但发现问题时间滞后,而且稍微高级一点的作弊行为不能被发现。</p>
<h3 id="第二个境界——亡羊补牢,损失在所难免">第二个境界——亡羊补牢,损失在所难免</h3><p>在这个段位的选手,甄别出真假的时间周期大概是2-7天之间,识别出来的假量大概在40%-70%之间,通俗的讲,他们可以比较确定性的识别出很大一部分假量用户,如果商务条件比较给力的话,是可以控制损失范围的。之所以有这样的效果是因为他们采用了一些专业的手段:</p>
<p>(一) 单个指标<br>1) IP:是否为黑名单IP、是否为代理IP,跟一个巨大的黑名单库进行比对;<br>2) IMEI:是否为黑名单IP;<br>3) 手机号码:号码是否非法,是否在黑名单;</p>
<p>(二) 群体指标<br>1) IP:用户IP的地域分布是否符合先验数据的分布,地域包括国内的省份分布和海外市场的分布;<br>2) IMEI:用户IMEI号的地域分布是否符合先验数据的分布,IMEI所代表的制造商的分布是否随机;<br>3) OS:该渠道操作系统版本的分布情况是否符合一定的随机性和统计性,并与之前的先验数据进行对比判断;<br>4) 机型:机型分布是否符合先验数据,以及最新智能手机出货量的比例;<br>5) 位置信息:位置信息打开的比例,以及获取到位置信息的地域分布比例是否符合先验数据的分布,是否符合渠道承诺的地域情况,是否符合应用的实际分布情况;<br>6) 运营商:运营商的数据分布是否随机,是否符合国内运营商的正常分布,以及海外运营商的随机分布;<br>7) 网络接入方式:wifi、2G、3G、4G的分布比例是否与先验数据保持同样的趋势和数据特征;</p>
<p>(三) 信息一致性:<br>设备一致性的验证,包括:CPU、制造商、Mac地址、IMEI、机型、操作系统的一致性验证。<br>一般而言,通用的统计分析工具是实现不了上述的分布,这就需要用专业的作弊防护软件或安全软件来。<br>这个境界的运营者已经摆脱了手工处理,依赖个人经验的阶段,而是走上了算法和数据的专业化路线,但问题是每家的算法能力和数据积累参差不齐,因此在效果上各家能力差异很大,而渠道反过来猜测各个运营者的能力的强弱,来给他们掺不同比例的假量。</p>
<h3 id="第三个境界——当下即断,零损失可以期待">第三个境界——当下即断,零损失可以期待</h3><p>在这个段位的选手,甄别用户的真假所需时间从15分钟到30分钟,如果是时间窗口延伸到24小时,那么他们的把握将更大。那么他们是如何做到的呢?总结一句话就是:软硬兼施,进攻是最好的防守!</p>
<p>(一) 硬手段:<br>所谓硬手段就是在用户端的硬件上下功夫下手段,进驻在用户硬件设备上的SDK主动进行探嗅,探测硬件环境的变化、操作系统环境的异常、以及各种应用接口是否被劫持。第一时间得到用户智能设备的状态。当该用户的手机硬件及其系统环境出现异常时,立刻在后台对该用户的所有数据进行缜密的审核,1)追踪其IP及端口的状态,以及IP的历史行为;2)追踪其IMEI以及IMSI的对应关系,IMEI和IMSI基本可以理解为一把钥匙一把锁的对应,伪造一个IMEI号容易,但要想连同IMSI一同伪造,这个成本就变得奇高无比。而整个过程可以控制在15-30分钟,为跟渠道斗(si)争(bi)赢得充分时间窗口。</p>
<p>(二) 软手段:<br>在第二境界的基础上,他们通过长期的数据积累和研究发现:各个指标反馈出来的信息强弱不同,因此对所有的指标进行赋值,并让这些指标对该群用户做作弊投票,当累计值超过阀值时,宣布该用户为可疑用户。这样就可以完成了在24小时内对用户真假的补充判断。</p>
<p>要达到这个水平,不仅需要长期大量的数据积累和与时俱进的更新,还要有强大的数据处理算法和软硬通吃的技术实力。</p>
<p><strong>作者</strong>：古婆<br><strong>链接</strong>：<a href="https://www.zhihu.com/question/22958167/answer/81144971" target="_blank" rel="external">点击这里</a><br><strong>来源</strong>：知乎<br><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p><em><strong>本文整理自知乎，<a href="https://www.zhihu.com/question/22958167/answer/81144971">如何监测出安卓推广渠道作弊？</a></strong></em>。<br><em><strong>文章比较系统地介绍了三个境界的防作弊手段，对于APP运营者有一定价值，同时对于广告渠道来说也有一定的意义。</strong></em></p>
<p>如何判断渠道的质量和狡猾程度,如何判断用户是否真实、是否来自墙、是否机刷or肉刷而来,是运营人员乃至整个公司最为头疼的事情,因为事关成本,而寒冬将至,成本则事关生死,不可谓不大。</p>
<p>那么我们如何识别真假用户,从而有效的管理渠道呢?从运营的角度,要是能根据上量的用户的综合价值来给渠道付费,那当然就是最佳策略。什么叫用户的综合价值,那就是该用户为公司创造出来的综合价值,价值包括但不限于:</p>
<blockquote>
<p>1) 直接利润价值:比如购买行为,产生收入和潜在的利润;<br>2) 内容价值:比如产生了积极的、优质内容,间接的创造价值等;<br>3) 传播价值:比如因为ta的传播,引发了其他用户的使用等等;<br>4) 衍生价值:停留时长或关注时长,所带来的广告收益等;</p>
</blockquote>
<p>每个App的行业不同,这四种价值侧重不同。<br>因为按照激活这个时间作为结算的时间节点对我们来说,这个时间窗口太短,对甄别用户的真假带来巨大的挑战。<br>在这个巨大的挑战面前,就分化出作弊防护的不同境界。<br>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告之广告平台选择（Admob&Facebook）]]></title>
    <link href="http://leotse90.com/2016/03/22/Mobile-AD-Admob-Integration/"/>
    <id>http://leotse90.com/2016/03/22/Mobile-AD-Admob-Integration/</id>
    <published>2016-03-22T15:13:46.000Z</published>
    <updated>2016-03-23T00:46:22.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/facebook-money.jpeg" alt="facebook-audience-network"><br></center>

<p>现在的出海的移动互联网公司，实现变现一般都是两种途径(国内的变现途径也一样，但是不在今天的讨论范围内)：广告变现，APP内购。游戏一般依赖应用内消费（也有一些游戏通过广告进行变现），而剩下的很多非游戏类应用主要靠广告变现，比较具有代表性的有：CleanMaster、APUS、Kika等工具类产品，根据猎豹移动最新发布的2015年财报，它的海外移动营收中有95%来自于移动广告。<br><a id="more"></a><br>要实现广告变现，就需要有广告来源，一般的国内的公司出海变现需要依赖第三方广告平台，当然，也有些有实力的公司自己做广告平台。现在海外主要的广告平台有Admob、Facebook、Mopub、IronSource、DoubleClick等等，国内的像猎豹移动也正在推出自己的广告平台猎户系统，Kika也推出了自己的广告平台Koala。但是如果你只是一般的应用开发者致力于海外市场应用开发，那么推荐你主要依赖Admob与Facebook这两家进行商业变现就可以了。毕竟接广告不仅依赖于一个比较强大的商务团队，还需要具备一定的平台搭建能力。</p>
<h2 id="Admob_&amp;_Facebook_广告SDK实施">Admob &amp; Facebook 广告SDK实施</h2><p>哪怕是强如猎豹移动这种出海的先驱，它拥有自己的广告平台，但是它们的主要广告营收还是依赖于Facebook。Facebook Audience Network提供了CPC、CPI、CPM等丰富的广告资源，而且可以根据Facebook的用户的信息进行广告的精准投放，这种精准投放的前提条件也让Facebook广告填充率不够，因为它只能在安装了Facebook的机器上进行广告活动，考虑到国外Facebook的覆盖率，一般来说，Facebook的广告填充率能达到80%－90%。而Admob依靠Google，拥有海量的广告资源，而且Google Play几乎霸占了海外的应用市场份额，因此它在广告界的地位也是无可撼动。</p>
<p>要想通过Facebook和Admob进行变现，实施起来也十分方便，它们都提供了各自的广告SDK，只需要在他们的平台上申请Ad Unit ID即可轻松实现广告创收。下面是两家的实施示例代码，非常简单：<br>Admob实施代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String admobAdUnitId = <span class="string">"ca-app-pub-1301877944976160/5685349534"</span>;</span><br><span class="line">AdLoader.Builder adBuilder = <span class="keyword">new</span> AdLoader.Builder(context, admobAdUnitId);</span><br><span class="line"></span><br><span class="line">adBuilder.forAppInstallAd(<span class="keyword">new</span> NativeAppInstallAd.OnAppInstallAdLoadedListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppInstallAdLoaded</span><span class="params">(NativeAppInstallAd nativeAppInstallAd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AdLoader adLoader = adBuilder.withAdListener(<span class="keyword">new</span> AdListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdFailedToLoad</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br><span class="line"></span><br><span class="line">AdRequest adRequest = <span class="keyword">new</span> AdRequest.Builder().build();</span><br><span class="line">adLoader.loadAd(adRequest);</span><br></pre></td></tr></table></figure></p>
<p>Facebook Audience Network实施代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String facebookAdUnitId = <span class="string">"1605000876745596_1688342111425188"</span>;</span><br><span class="line"></span><br><span class="line">mFacebookNativeAd = <span class="keyword">new</span> com.facebook.ads.NativeAd(mContext, facebookAdUnitId);</span><br><span class="line"></span><br><span class="line">mFacebookNativeAd.setAdListener(<span class="keyword">new</span> AdListener() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Ad ad, AdError adError)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdLoaded</span><span class="params">(Ad ad)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ad loaded</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdClicked</span><span class="params">(Ad ad)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mFacebookNativeAd.loadAd();</span><br></pre></td></tr></table></figure></p>
<p>具体的实施可以参考它们的官网。</p>
<h2 id="Admob聚合Facebook优化">Admob聚合Facebook优化</h2><p><center><br><img src="/img/facebook-ad.jpg" alt="facebook-ad"><br></center><br>如前所说，一般你只要集成这两家的SDK就可以轻松变现，但是这也存在一些问题，比如：1.Facebook可以精准投放但是填充率不及Admob，应该怎么优化？2.两家的广告如果都能填充，如何进行抉择？</p>
<p>Admob提供了比较完善的解决方案，那就是SDK集成SDK，你可以在使用Admob SDK时集成Facebook Audience Network，并且可以在Admob后台进行设置，进行广告效果的调优。</p>
<p>Admob其实可以集成非常多的第三方广告平台，但是效果最好的要数Facebook。Admob集成的优势在于它提供了一种竞价模式。据了解，Admob的竞价有两种：</p>
<p>一种就是InMobi那种，Admob和Inmobi后台已经打通，可以互通有无，Admob知道Inmobi的实时eCPM，因此总是能返回eCPM高的广告给调用方；<br>另一种就是Facebook这种，Admob并不知道Facebook的实时eCPM，但是我们可以在Admob后台设置一个Facebook的eCPM阀值，比如我们在Admob上为Facebook的eCPM设置阀值为15，那么广告填充就会出现三种情况：  </p>
<blockquote>
<p>1）Facebook没有广告返回，直接返回Admob的广告，广告的eCPM就是Admob的平均eCPM；<br>2）Facebook有广告返回，但是Admob返回的广告eCPM大于Facebook预设的阀值，这里是15，那么返回Admob的广告，此时广告的eCPM会高于预设阀值；<br>3）Facebook有广告返回，但是Admob返回的广告eCPM小于Facebook预设的阀值，那么就会使用Facebook返回的广告，此时广告的eCPM就会是你在Facebook平台上的平均eCPM。</p>
</blockquote>
<p>由此可以看出，<strong>要想实现收益最大化，我们应该适当调高在Admob后台设置的Facebook eCPM阀值，并在Facebook后台将广告设置偏向“价格优先”。</strong>在我们的产品上，Facebook的eCPM经验阀值为15，整体收益最高。实际情况需要实施者不断观察不断调整，从而达到整体最优。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/facebook-money.jpeg" alt="facebook-audience-network"><br></center>

<p>现在的出海的移动互联网公司，实现变现一般都是两种途径(国内的变现途径也一样，但是不在今天的讨论范围内)：广告变现，APP内购。游戏一般依赖应用内消费（也有一些游戏通过广告进行变现），而剩下的很多非游戏类应用主要靠广告变现，比较具有代表性的有：CleanMaster、APUS、Kika等工具类产品，根据猎豹移动最新发布的2015年财报，它的海外移动营收中有95%来自于移动广告。<br>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告之GooglePlay推广流程]]></title>
    <link href="http://leotse90.com/2016/03/21/Mobile-Ad-GooglePlay/"/>
    <id>http://leotse90.com/2016/03/21/Mobile-Ad-GooglePlay/</id>
    <published>2016-03-21T15:22:01.000Z</published>
    <updated>2016-03-21T16:01:36.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/google-play.png" alt="google-play"><br></center>

<p>在进行移动应用推广的时候，大多数公司会根据不同需求选择不同的渠道进行推广。比如，国内的应用冲榜（也就是刷排名，这时候的一般的目的是进行融资前的造势）的时候，会找网盟进行推广，网盟推广的优点是刷量快、成本低；另外如果是应用推广（目的纯粹），那么会找一些比较专业的广告平台进行广告投放，海外的主要有Adwords、Admob、Facebook等等，相比于网盟，这些广告平台的成本高，但是产品的留存高。一般情况，我们在网盟上推广成本单个价格为Facebook等平台的一半，但是留存也只有后者的一半以下。<br><a id="more"></a><br>我们这里要介绍的是Google Play上的应用推广，这里的推广并不是指策略（广告素材本地化、借助于GA数据化运营等等），而是介绍了其推广的流程。</p>
<h2 id="GooglePlay推广流程">GooglePlay推广流程</h2><p>我们首先使用Google Play URL Builder生成推广链接，Google developers上会有详细的参数说明，这里不再赘述。</p>
<p>接下来重点介绍用户从点击推广链接到确认安装的流程：<br>1.<strong>用户点击推广链接</strong>：推广链接可以呈现在WEB页面或者APP的广告中，这时候，如果正常跳转，用户会跳转到Google Play的该应用下载页面；<br>2.<strong>用户下载安装应用</strong>：用户在GP上下载安装应用后，GP会发送一个广播，该广播中包含的是推广链接的相关参数；<br>3.<strong>应用上报推广数据</strong>：下载的应用会在收到2中发送的广告后，在适当的时候上报收到的推广参数；   </p>
<p>我们解读一下上述的流程，一般情况下，用户都会跳转到Google Play网页或者Google Play应用商店，国内的大部分手机都进行了“纯净”，因此可能会跳转到网页或者手机上自带的应用商店。</p>
<p>Google Play在用户安装应用后，通过Intent发送一个广播INSTALL_REFERENCE，关于INSTALL_REFERENCE，需要注意：  </p>
<blockquote>
<p>在Android 3.1（API 12）之前，INSTALL_REFERENCE在应用安装后发送；<br>Android 3.1之后，INSTALL_REFERENCE变为在应用第一次启动时发送。  </p>
</blockquote>
<p>这是因为Android 3.1以后引入了停止状态，而<strong>只有非停止状态的APP才能收到INSTALL_REFERENCE广播</strong>。<br>同时，INSTALL_REFERENCE只会发送给指定的通过推广安装的应用。从网页到应用是无法发送INSTALL_REFERENCE的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/google-play.png" alt="google-play"><br></center>

<p>在进行移动应用推广的时候，大多数公司会根据不同需求选择不同的渠道进行推广。比如，国内的应用冲榜（也就是刷排名，这时候的一般的目的是进行融资前的造势）的时候，会找网盟进行推广，网盟推广的优点是刷量快、成本低；另外如果是应用推广（目的纯粹），那么会找一些比较专业的广告平台进行广告投放，海外的主要有Adwords、Admob、Facebook等等，相比于网盟，这些广告平台的成本高，但是产品的留存高。一般情况，我们在网盟上推广成本单个价格为Facebook等平台的一半，但是留存也只有后者的一半以下。<br>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广告有效性原理]]></title>
    <link href="http://leotse90.com/2016/03/02/ad-effective-theory/"/>
    <id>http://leotse90.com/2016/03/02/ad-effective-theory/</id>
    <published>2016-03-01T17:00:35.000Z</published>
    <updated>2016-03-02T00:33:22.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>广告有效性原理用于描述广告从产生，到达用户以至于最后的转化行为的整个过程。整个模型主要包含三个阶段：选择、解释、态度。这三个名词初看起来有点难以理解，接下来会逐个解释这三个阶段。</p>
<h2 id="选择(selection)">选择(selection)</h2><p>选择主要包含两个子阶段：<strong>曝光阶段(exposure)</strong>与<strong>关注阶段(attention)</strong>。  </p>
<p>这个阶段主要是将广告带入受众的视线。所以这个阶段也可以理解为到达用户阶段。</p>
<h3 id="曝光阶段(exposure)">曝光阶段(exposure)</h3><p>广告展现出来的阶段。这一阶段拼的是广告位的曝光度，广告位对广告的效果起着决定性的作用。比如百度搜索广告，北区的曝光度比南区和东区都高，这是由产品本身决定的，如下图所示：<br><a id="more"></a></p>
<center><br><img src="/img/baidu-search-ad.png" alt="baidu-search-ad"><br></center>

<p>这张图上展示了百度搜索广告的北区广告和东区广告，我们明显可以知道北区的广告相比于东区更容易被用户浏览，更别提底部的南区广告了，这种差距不是一些技术上的优化就能抹平的。</p>
<h3 id="关注阶段(attention)">关注阶段(attention)</h3><p>如果说曝光阶段是广告进入受众视线可达到的一步，那么关注阶段则是广告被受众发现的过程。举个例子，大部分的公交站都有广告牌，比如说即将上映的电影，或者是刚推出的电子产品等，它的出现就是曝光阶段，但是只有某一天你被它吸引驻足停留，才算是进入了关注阶段。</p>
<center><br><img src="/img/bus-station-ad.jpg" alt="bus-station-ad"><br></center>

<p>如果说曝光阶段靠的是先天条件，那么关注阶段的效果就能靠后天努力了（当然先天优势依然很关键）。比如丰富的广告创意，或者符合潜在目标人群的兴趣爱好等，都能提升关注阶段的效果。</p>
<p>这个阶段，有几个重要的原则：</p>
<blockquote>
<p>1.尽量不要打断用户的任务；<br>2.明确传达向用户推送广告的原因；<br>3.内容符合用户的兴趣或需求。</p>
</blockquote>
<p>这三点原则在实际实施中很有用，尤其是CPC和CPM的广告。关于第一个原则，有一个实际的例子，笔者所在公司有一款输入法产品，曾经在用户输入某个关键字的时候弹出符合该条件的广告或内容（现在百度输入法还在这样做），但是效果不理想，反而GP上指责不断，这个idea不久就夭折了，因为用户使用输入法一般在聊天或者其他记录查询操作，如果这个时候强行打断用户插入广告，牺牲了产品体验的同时并没有提升广告效果。而第二个原则Amazon很好地贯彻了，Amazon的推荐商品下方一般都有推荐的理由，这样对用户来说，广告出现得并不突兀，反而会让人觉得这是非常合理人性化的商品推荐。</p>
<center><br><img src="/img/amazon-recommend-ad.png" alt="amazon-recommend-ad"><br></center>

<p>第三个原则可以根据用户的兴趣爱好及需求（问卷调查、数据挖掘、用户行为分析等手段），比较精准地推荐广告，这个原则要执行起来技术难度较大，但是一旦实施效果将会非常明显。</p>
<h2 id="解释(interpretation)">解释(interpretation)</h2><p>“解释”这个阶段需要解释一下，这个“解释”主要是广告投放方向广告受众讲明来意并被潜在受众理解和接受的阶段。它主要包含理解阶段(comprehension)和接受阶段(acceptance)。</p>
<h3 id="理解阶段(comprehension)">理解阶段(comprehension)</h3><p>这个阶段的主要目标是让用户明白他关注到的广告的用意，并理解广告所传达的信息。这个通俗地讲就是用户理解了这个广告是干嘛的，香烟广告观众看完要知道这个广告的产品是烟草而不是打火机，食品广告就要让用户知道这是在卖吃的。</p>
<p>这个阶段也有两个原则：</p>
<blockquote>
<p>1.广告内容要在用户能理解的具体兴趣范围内；<br>2.设定与关注程度相匹配的理解门槛。</p>
</blockquote>
<p>这两个原则恐怕也是需要解释一下的，第一个原则的前提是广告投放人群定向，而这两个原则都在指引我们在设计广告和投放广告时尽量找到它对应的潜在受众。</p>
<h3 id="接受阶段(acceptance)">接受阶段(acceptance)</h3><p>广告受众看到了，关注了，也读懂了，但是如果不被用户接受，那么也是前功尽弃。在接受阶段，除了广告的投放需要尽量精准外，还需要注意广告的形式，广告不要过度影响或妨碍用户。比如一个小孩在使用APP的时候，浏览到一则根据他兴趣推荐的最新游戏的广告，但是广告内容却是充满性暗示的美女图片，我们假设小孩还和以前一样是比较单纯的群体，那么这种广告反而会起到负面效果。</p>
<p>接受，就是合适的广告在合适的时机出现在合适的位置。</p>
<h2 id="态度(attitude)">态度(attitude)</h2><p>前面的解释阶段注重的是广告投放方向广告的受众传递信息，那么这个“态度”阶段就是广告受众向广告投放方表明自己立场的过程。</p>
<h3 id="保持阶段(retention)">保持阶段(retention)</h3><p>这个阶段主要是针对品牌广告。品牌广告商希望自己的广告能比较持久的“保持”在受众的脑海里，以期在未来较长的一段时间里都能影响用户的选择。</p>
<h3 id="决策阶段(decision)">决策阶段(decision)</h3><p>这是广告的最终目的，品牌广告希望你记住广告商并在商场选购中不假思索地选择他们的产品，游戏应用安装类广告希望你下载他们的游戏并沉浸其中，公益广告希望你能遵循教导爱国孝顺礼貌勤劳等等。</p>
<p>决策是整个广告行为的收官阶段，也是评判广告是否有效的重要指标。</p>
<blockquote>
<p>广告没有专业可言，只有成功可言。</p>
</blockquote>
<p>是的，广告的世界就是直白。没有广告主会把注意力集中在广告是否丰富专业，他们的需求只有一个：看到广告的用户行动起来！</p>
<blockquote>
<p>对于互联网广告，越靠前的阶段，其效果的改善对点击率的贡献就越大；而越靠后的阶段，其效果的改善对转化率的贡献就越大。</p>
</blockquote>
<p><strong>关于广告有效性原理，虽然看起来理论气息很浓，但是它的“曝光”绝不只是希望得到我们的“关注”，而是需要我们“理解”并“接受”它的意旨，然后能“保持”在每一个广告人的脑海中并帮助我们在工作中做出更有用的“决策”！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>广告有效性原理用于描述广告从产生，到达用户以至于最后的转化行为的整个过程。整个模型主要包含三个阶段：选择、解释、态度。这三个名词初看起来有点难以理解，接下来会逐个解释这三个阶段。</p>
<h2 id="选择(selection)">选择(selection)</h2><p>选择主要包含两个子阶段：<strong>曝光阶段(exposure)</strong>与<strong>关注阶段(attention)</strong>。  </p>
<p>这个阶段主要是将广告带入受众的视线。所以这个阶段也可以理解为到达用户阶段。</p>
<h3 id="曝光阶段(exposure)">曝光阶段(exposure)</h3><p>广告展现出来的阶段。这一阶段拼的是广告位的曝光度，广告位对广告的效果起着决定性的作用。比如百度搜索广告，北区的曝光度比南区和东区都高，这是由产品本身决定的，如下图所示：<br>]]>
    
    </summary>
    
      <category term="广告杂谈" scheme="http://leotse90.com/tags/%E5%B9%BF%E5%91%8A%E6%9D%82%E8%B0%88/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中线程的异常处理]]></title>
    <link href="http://leotse90.com/2016/03/01/Java-exception-thread/"/>
    <id>http://leotse90.com/2016/03/01/Java-exception-thread/</id>
    <published>2016-02-29T16:47:23.000Z</published>
    <updated>2016-02-29T16:52:15.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="异常处理">异常处理</h2><p>异常，在程序出现的非正常状态；异常处理机制，就是程序语言针对这些异常状态采取的处理措施。当程序出现异常的时候，程序会暂停运行，并且程序的控制权会转交给异常处理器。</p>
<p>在Java中，我们有一套比较完善的异常处理机制。下面是Java中异常的一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception1 exception1)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception1 throws</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 exception2)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception2 throws</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// do this no matter what happened</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常主要分类">异常主要分类</h3><p>在Java中（Android一样），异常的基类是<code>Throwable</code>，而我们平时所看到的<code>Error</code>以及<code>Exception</code>都继承自<code>Throwable</code>。<br><a id="more"></a></p>
<center><br><img src="/img/java-exception.jpg" alt="java-exception"><br></center>

<p>而<code>Error</code>指的是Java在运行时系统中的内部错误或者资源不够等情况，问题一般较严重；对于<code>Error</code>，程序除了尽快全身而退外，其他什么都做不了。程序也不应该抛出<code>Error</code>对象，它一般是由JVM抛出；<br>相较于<code>Error</code>，<code>Exception</code>就温顺多了，我们一般情况下可以在代码中预测<code>Exception</code>的发生并对症下药，提前编写好异常处理的代码。</p>
<p><code>Exception</code>包括运行时异常（<code>RuntimeException</code>）以及非运行时异常，运行时异常主要包括类型转换异常、数组越界、空指针等；</p>
<blockquote>
<p>运行时异常，都是程序员的错。</p>
</blockquote>
<p><strong>非运行时异常</strong>，又叫编译异常，一般是外部错误，这些并不是程序本身的问题，而是在环境外部出现的异常，最常见的就是<code>IOException</code>，当程序想要读取或者写入一个不存在文件时，就会抛出<code>IOException</code>。从程序语法角度讲<strong>非运行时异常是必须处理的异常，否则程序就不能编译通过</strong>。</p>
<p><strong>运行时异常</strong>：都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException</code>(空指针异常)、<code>IndexOutOfBoundsException</code>(下标越界异常)等，程序中可以选择catch处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<strong>运行时异常的特点是Java编译器不会检查它</strong>，也就是说，当程序中可能出现这类异常，即使没有用try catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<p><strong><code>Error</code>和<code>RuntimeException</code>及其子类统称为unchecked异常，而其他称为checked异常（要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过）。<code>Exception</code>能被程序本身可以处理，<code>Error</code>是无法处理。</strong>。</p>
<center><br><img src="/img/java-exception2.jpg" alt="java-exception"><br></center>

<h3 id="异常处理流程">异常处理流程</h3><p>Java中，异常的主要处理流程如下：<br>1.代码块遇到异常，当前代码块停止运行，程序也随之暂停运行，程序控制权转移给异常处理器；<br>2.异常处理器开始搜索有没有能够处理当前异常的处理器，如果有，则执行处理器中的代码；如果没有，则抛出异常给当前代码块的调用方；<br>3.接收到抛出异常的代码块会重新经历以上1，2的步骤，如果没有合适的处理器，继续往上层抛出异常；<br>4.如果异常抛到程序入口仍然没有处理，则将异常抛给JVM；</p>
<center><br><img src="/img/exception-flow.jpg" alt="exception-flow"><br></center>

<h2 id="线程的异常处理">线程的异常处理</h2><p>1.线程可以抛出异常<br>这是一个基本事实，我们可以在线程中抛出一个异常，当前线程会中断，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Sub thread is running..."</span>);</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sub thread is running...</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-0"</span> </span><br><span class="line">java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">	at com<span class="class">.leotse</span><span class="class">.thread</span><span class="class">.MyThread</span>$<span class="number">1</span>.<span class="function"><span class="title">run</span><span class="params">(MyThread.java:<span class="number">10</span>)</span></span></span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是，我们不能直接在Override的run方法声明时直接抛出异常，如<code>public void run() throws Exception{...}</code>，Java会提示你<code>Exception is not compatible with throws clause in Runnable.run()</code>。</p>
<p>2.主线程能否捕捉子线程的异常<br>首先，我们需要明确一点，线程的run()方法定义了子线程的边界，也就是说，一个线程中的逻辑再怎么运行也不能超越其run()方法。这就明确了</p>
<blockquote>
<p>线程代码不能抛出任何checked异常，所有的线程中的checked异常都只能被线程本身消化掉。线程本身就是被看作独立的执行片断，它应该对自己负责，所以由它来消化所有的checked异常是很正常的。</p>
</blockquote>
<p>上面说的一直是checked异常，那么unchecked异常是不是不一样？对于unchecked异常中的<code>Error</code>我们显然无能为力，但是对于另外一部分－<code>RuntimeException</code>我们能否处理？我们看下面一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"Sub thread is running..."</span>);</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Sub thread throws an exception..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Main thread is running..."</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果Main thread能捕捉到子线程的运行时异常（前面讲过，属于unchecked异常），那么<code>Sub thread throws an exception...</code>就会被打印出来（即能被catch住），运行结果如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sub thread is running..<span class="class">.Exception</span> <span class="keyword">in</span> thread <span class="string">"Thread-0"</span> </span><br><span class="line">Main thread is running...</span><br><span class="line">java<span class="class">.lang</span><span class="class">.RuntimeException</span></span><br><span class="line">	at com<span class="class">.leotse</span><span class="class">.thread</span><span class="class">.MyThread</span>$<span class="number">1</span>.<span class="function"><span class="title">run</span><span class="params">(MyThread.java:<span class="number">12</span>)</span></span></span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果显示有点乱，但是我们仍然可以看到，<code>Sub thread throws an exception...</code>这句话并没有打印出来，因此说明在这里我们的MainThread并没有捕捉到子线程抛出的unchecked异常。</p>
<blockquote>
<p>线程方法的异常只能自己来处理。</p>
</blockquote>
<p>更多关于异常的知识：<br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/" target="_blank" rel="external">Java 异常处理的误区和经验总结</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="异常处理">异常处理</h2><p>异常，在程序出现的非正常状态；异常处理机制，就是程序语言针对这些异常状态采取的处理措施。当程序出现异常的时候，程序会暂停运行，并且程序的控制权会转交给异常处理器。</p>
<p>在Java中，我们有一套比较完善的异常处理机制。下面是Java中异常的一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception1 exception1)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception1 throws</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 exception2)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception2 throws</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// do this no matter what happened</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常主要分类">异常主要分类</h3><p>在Java中（Android一样），异常的基类是<code>Throwable</code>，而我们平时所看到的<code>Error</code>以及<code>Exception</code>都继承自<code>Throwable</code>。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对不起，我是一名广告人]]></title>
    <link href="http://leotse90.com/2016/02/14/I-am-Adman/"/>
    <id>http://leotse90.com/2016/02/14/I-am-Adman/</id>
    <published>2016-02-14T15:23:22.000Z</published>
    <updated>2016-02-15T05:49:59.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<blockquote>
<p>不做总统就做广告人。<br>I am Adman.</p>
</blockquote>
<p><center><br><img src="/img/protect-yourself.jpg" alt="protect-yourself"><br></center><br><a id="more"></a></p>
<h2 id="广告开发也是广告人">广告开发也是广告人</h2><p>Adman，坊间称之为广告人，一般指的是那些为甲方客户产品进行广告营销策划与设计的专业人士。他们的主要工作内容是在接到用户的需求后，分析用户的产品，为之实现行之有效的推广创意，从而促进用户产品的销量（这类广告最为常见，CPA广告等等），或提高用户品牌的知名度（主要有品牌广告），又或者达到用户所需要宣传的效果（比如公益广告）。</p>
<p>那么，作为一名非纯正的publisher的互联网公司广告团队中一名开发人员，何以敢称自己为一名广告人呢？</p>
<p>不只是广告的搬运工。你看我现在每天的主要工作是将服务端的广告数据分发到客户端并追踪广告效果，说得不给面子一点，就是一名广告创意的搬运工，默默地将别人设计的广告创意从广告主或者ADX等来源搬运到用户的手机应用里。但是我不服！手握着无数同行们精心设计的成果，将其最终展现在潜在的用户面前，这俨然是广告创意从降世到大展拳脚中非常关键的一环，我不仅仅是搬运工，无论多么劲爆、多么attractive的广告创意（广告人视角），都必须被市场检验才能算得上真正的牛X。伟大的革命导师教导我们：<strong>一切不被用户接受的广告创意都是纸老虎！</strong></p>
<p>直接面向用户。当时，用户的手指离我的广告创意只有0.01公分，四分之一秒后这位用户将深深地爱上我，“你的手指从我的身上划过去吧”。广告人一直都说广告的创意往往不是来自于灵光乍现而是来源于生活，来源于群众。而我们广告开发所做的一切就是要这些广告创意回到群众中去，特别是回到那些需要广告的群众中去，在广告行业里，我们坚持贯彻<strong>从群众中来，到群众中去</strong>的方针。</p>
<p>数据，数据，数据。与其说现在是移动互联网时代，不如说现在是移动数据时代。多少大佬叫嚣着21世纪最重要的财富是数据。在广告行业里，数据的重要性也是毋庸置疑的，我们可以通过广告数据分析广告创意的效果，我们可以通过数据调整广告投放的策略，我们还可以通过数据更精准地投放广告。数据可以为广告插上翅膀，而这些数据怎么来？怎么分析？分析后怎么调整怎么投放？这些就又回到我们广告开发的老本行了。</p>
<p>这三点理由已经足够说明，广告人的人口组成里还有我们这些任劳任怨、面朝电脑背朝天的广告开发们！</p>
<h2 id="做广告，就要大大方方的做">做广告，就要大大方方的做</h2><p>广告为什么会在很多用户心中称为与老鼠、蟑螂并称新时代“三害”？一个主要原因是广告的滥投。打开电视是广告，网上看电影前面强制看75s广告、打开一个网页也是各种设计诡异点击关闭却打开满屏飘忽不定神出鬼没的广告，好不容易没经住广告上的美人计诱惑点进去结果是个诈骗网站，玩个手机APP也弹出一堆广告，就算你走到大街上，你还是躲不过一张张塞过来的小卡片广告。广告貌似无处不在，它潜伏在我们的周围，时不时就冒出来抢占我们的注意力，破坏我们的美丽心情。这种广告当然神烦，它们的背后黑手当然是广告人。但是少林寺还有成昆呢，武当派还有宋青书呢，哪个名门正派没有出过人渣，请相信，这些个让我们避之不及的小广告也是部分未能得道的低等广告人的拙劣手笔。</p>
<p>不得不承认，现在国内的广告行业很乱，而这个乱的根本原因就是“钱”！<br>国内的互联网产品大多奉行“先用免费馅饼圈地，然后关门磨刀宰客”的发展策略，因此变现的途径主要就围绕着服务收费和广告变现来展开，服务收费并不是每个人都可以做的，但是广告变现就相对来说实现起来简单很多，只要我胆量够大，只要PM没有反对，那么我就敢在用户视线的每一次光临都塞进去一个广告，更何况国内是GP的法外之地。用户体验算什么，他们的心里都有这样一本帐，假如我们产品有100w用户，我们多增加一个广告位带来的收入是6w刀，损失的用户是2w人，然后我们可以再花5w刀买2w的用户（数据纯属捏造，如有雷同，那是扯淡），这样一轮下来你看我们用户数还是100w，但是我们的收入增加了1w刀。这样看起来，这笔买卖很划算。但是朋友们，帐不是这么算的，这么做生意简直就是杀鸡取卵！觉得这笔买卖划算的可能是过于乐观了：</p>
<blockquote>
<p>1.广告位数量和广告收入不是简单的线性关系；<br>2.花银子购买的用户忠诚度和自然增长的用户忠诚度完全不是一个level。</p>
</blockquote>
<p>先说广告位数量和广告收入不是简单的线性关系。经济学中有一条很著名的拉弗曲线（Laffer Curve），它描述了税率和税收之间的关系，这条曲线表明并不是税率越高，税收就越多，事实上，它是一个先增长后下降的曲线，因为税率过高会降低人们到工作积极性，从而对税收有了负作用。广告位数量和广告收入之间的关系也类似，它不是简单的线性相关，广告收入会先随着广告位的增加而上升，然后过了转折点后会开始下降，这是因为用户体验也加速变差了，用户都吓跑了，一个极端的例子是满屏幕都是广告的网站你会进第二次么？（一些小电影网站需要另当别论，因为相较于人们从稀缺资源中获得的感官刺激，这点注意力损耗不算什么。）</p>
<p><center><br><img src="/img/Laffer_Curve.jpg" alt="Laffer Curve"><br></center><br>然后就是用户的忠诚度问题，对于很多互联网公司，特别是移动互联网公司，花钱买量已经是非常正常的事情了，据称国内某专业的海外市场工具公司每天花几十万dollar在买量上。但是一般情况下，买量的作用在于制造产品或者应用十分受欢迎的假象或者增加投资人的信心。<br>如果我们在变现过程中，期望通过先损害用户体验赚钱然后花钱买量的这样的路子，那么这就和我们当年的“先发展，再治理”战略方针是“同一个世界，同一个梦想”了。怎么理解这个忠诚度呢？打个比方，你在中关村大街上只要扫码下载就送充电宝下载的APP和你自己去通过探索等主观意愿去获取的APP，你更倾向于卸载哪个？前面的那个例子中，如果这100w用户全部按照暴力变现－买量的方式置换一遍，我们是可以收获50w的收入，但是我们在讨论用户的时候，要知道还有一个指标叫做留存率，这个留存率直接对应着用户的忠诚度。100w优质用户＝100w劣质用户＋50w刀？这个就看你怎么算了，如果只是想捞一笔就跑，那您请尽兴！</p>
<p>因此，我们很多同行都在干着杀鸡取卵的事，他们坚信做广告就是要伤害用户体验，所以为了他们幻想的利益最大化，索性连碧莲都不要了，能塞广告的地方一个也不放过，广告尽量做得隐蔽，能有多流氓就有多流氓，这里点名表扬WPS的弹窗广告（写博客的时候刚好碰上），整个广告弹窗你就压根找不到关闭的地方，而且它就牢牢占据你屏幕右下方不会自动离去。我承认，广告变现与用户体验确实很难两全，但是很难不代表不能，你看有那么多的广告人在努力让广告变得更加被大众所接受，朋友圈广告就是一个很好的例子，现在的朋友圈广告已经在一定程度上成为了话题，Youtube上的广告可以让用户选择是否观看，最近我的女朋友也十分喜欢宜家的“如果没有厨房，也许你不必早起”这则广告。一定程度上说明广告可以被用户欣然接受，只要我们给他们看到的是他们想看到的。</p>
<p><center><br><img src="/img/FedEx.jpg" alt="FedEx"><br></center><br>如果你真的觉得在用户体验和广告变现中太难权衡，那么，起码你得大大方方地做吧！真小人和伪君子，后者更被人唾骂，更何况是虚伪的小人！是广告就告诉用户这是广告，想看可以看不想看可以绕道，而不是要想尽办法伪装自己然后骗取用户的点击。Google的Admob在这上面真的可以说是我辈楷模，为了提升广告效果建议使用原生广告，但是你必须让用户知情这是一枚广告。</p>
<p><strong>做广告，就要大大方方的做</strong>。这是一位广告界前辈说过的话。如果我们现在真的没有能力去做出完美的广告，那么我们可以选择去提升自己的能力，或者多思考多尝试少去伤害用户，最不济也得做到大大方方做广告吧。</p>
<p><em>（2016年情人节于长沙－北京的天空里）</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<blockquote>
<p>不做总统就做广告人。<br>I am Adman.</p>
</blockquote>
<p><center><br><img src="/img/protect-yourself.jpg" alt="protect-yourself"><br></center><br>]]>
    
    </summary>
    
      <category term="广告杂谈" scheme="http://leotse90.com/tags/%E5%B9%BF%E5%91%8A%E6%9D%82%E8%B0%88/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VAST3.0视频广告规范介绍]]></title>
    <link href="http://leotse90.com/2016/01/29/VAST3.0/"/>
    <id>http://leotse90.com/2016/01/29/VAST3.0/</id>
    <published>2016-01-28T16:23:22.000Z</published>
    <updated>2016-01-28T16:40:50.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>说到VAST，就不得不提到<a href="http://www.iab.com" target="_blank" rel="external">IAB</a>，全称为Interactive Advertising Bureau，我们称之为互联网广告署，它的主要职责是制定网络业务流程的开发标准以及行业准则，并对网络广告收入进行跟踪。</p>
<p>我们今天要介绍的就是IAB的六个主要部分之一——VAST（Video Ad Serving Template）。它是互联网视频广告的统一标准，采用XML格式。随着在线视频内容的广告越来越普遍，人们也越来越关注互联网视频广告的商业化，在VAST出台之前，视频广告并没有统一的广告协议，行业乱象促使需要有人站出来制定一个通用的标准，这时候IAB开始出来行使它的职责，它为在线互联网视频广告制定了一套统一的、可扩展的广告协议。VAST消除了视频广告的技术壁垒，在VAST3.0之前，已经有两个较为普遍的版本，但是现在通用、流行的就是我们说的3.0版本，3.0版本保证了对2.0的兼容。</p>
<p>VAST协议主要包含以下三部分：</p>
<blockquote>
<p>视频广告的内容（creatives）<br>视频广告的跟踪事件及其追踪链接<br>视频广告的wrapper</p>
</blockquote>
<a id="more"></a>
<p>在VAST3.0中，保证了支持以下五种类型的广告：</p>
<blockquote>
<p>线性广告<br>非线性的广告<br>可跳过线性广告<br>伴随线性广告<br>广告荚</p>
</blockquote>
<p>其中，可跳过的线性广告以及广告荚是3.0新增的两种格式。</p>
<h2 id="专业术语">专业术语</h2><p>我们接下来要简单介绍一下VAST中主要的专业术语。</p>
<h3 id="VAST_Tag">VAST Tag</h3><p>VAST标签，获取VAST的URI。通过访问VAST tag可以connect到ad server，从而获取到VAST的response。   </p>
<h3 id="Video_Ad">Video Ad</h3><p>视频广告，这是VAST的主角。它主要指的是视频流（in-stream video）。</p>
<h3 id="Primary_Ad_Server">Primary Ad Server</h3><p>主广告服务器，视频播放器请求广告内容的第一个广告服务器。主广告服务器通常是由publisher的广告服务器。<br>从主广告服务器返回的数据不一定是我们所需的广告视频，还有可能是另一个广告服务器的地址，也就是下面介绍的二级广告服务器。</p>
<h3 id="Secondary_Ad_Server">Secondary Ad Server</h3><p>二级广告服务器，如果主广告服务器返回的不是视频广告的内容，而是一个重定向，指向另一个广告服务器，而这一级的广告服务器也不一定是最后一跳，也就是说还有可能有三级广告服务器、四级广告服务器，以此类推。但是最后一跳的广告服务器一定会提供包含视频广告信息的VAST响应。</p>
<h3 id="Wrapper">Wrapper</h3><p>封装。如果VAST的响应返回的是一个Wrapper，那么就意味着我们需要访问Wrapper中提供的URI访问下一级广告服务器。</p>
<h3 id="Clickthrough">Clickthrough</h3><p>点击。当用户点击广告creatives时所打开的页面。</p>
<h3 id="InLine_Ad">InLine Ad</h3><p>线内广告。指的是包含视频广告所需信息的VAST响应，当VAST的线内广告收到响应后，无需调用其他所需要的广告服务器。</p>
<p>接下来介绍的是VAST3.0支持的广告：</p>
<h3 id="Linear_Ad">Linear Ad</h3><p>线性广告。这种类型的广告我们平时接触很多，当我们在网上看电影的时候我们常常会在播放电影之前（pre-roll）、播放之后（post-roll）出现广告，更有甚者，电影中间（mid-roll）也有可能插播广告。<br>线性广告的形式多种多样，它可以是视频、rich media或者只是一张静止的图像。</p>
<p>可跳过线性广告属于比较特殊的线性广告，也就是用户可以根据需要选择是否看完广告，国外的Youtube的广告一般是这种，用户可以在观看5s后选择是否继续观看广告。</p>
<h3 id="Nonlinear_Ad">Nonlinear Ad</h3><p>非线性广告。依旧属于视频流广告，它也和视频的内容一起显示，但是与线性广告不同的是，非线性广告通常覆盖视频播放器的底部或顶部的五分之一。<br>非线性广告的形式也是多种多样，包含文本、图像等等。</p>
<h3 id="Companion_Ad">Companion Ad</h3><p>伴随广告。这种广告区别于前两者，它出现在视频播放器之外，一般是横幅广告或者富媒体广告。</p>
<p>下图展示了以上四种广告：<br><img src="/img/ads-vast.png" alt="ads-vast"></p>
<h3 id="Ad_Pod">Ad Pod</h3><p>广告荚。大多数视频网站前面的视频广告都是这种形式，包含一系列的线性视频广告。<br><img src="/img/ad-pods.png" alt="ad-pod"></p>
<h2 id="VAST3-0_工作原理">VAST3.0 工作原理</h2><p>常见的情况是直接从主广告服务器上获取视频广告信息。IAB给出这个流程的示意图：<br><img src="/img/master-ad-server-vast.png" alt="master-ad-server-vast"><br>从这个图上我们可以很清楚地看到请求VAST的流程，Ad server直接向视频播放器返回所需的InLine响应，视频播放器在解析了ad server的响应后，打开视频广告，并向ad server发跟踪链接。</p>
<p>另一种情况就是从多级广告服务器上获取视频广告信息，我们以二级广告服务器为例：<br><img src="/img/multi-ad-server-vast.png" alt="multi-ad-server-vast"><br>主广告服务器返回的是Wrapper，也就是视频播放器还需要继续请求二级广告服务器，然后获取到需要的视频创意。这里需要注意的是，跟踪事件需要发送给主广告服务器以及二级广告服务器。</p>
<h2 id="VAST3-0_响应示例">VAST3.0 响应示例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">VAST</span> <span class="attribute">version</span>=<span class="value">”3.0”</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">Ad</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">InLine</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">AdSystem</span>&gt;</span>My Ad Server<span class="tag">&lt;/<span class="title">AdSystem</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">AdTitle</span>&gt;</span>Car Company<span class="tag">&lt;/<span class="title">AdTitle</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">Impression</span>&gt;</span>...<span class="tag">&lt;/<span class="title">Impression</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">Creatives</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">Creative</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="title">Linear</span>&gt;</span>...<span class="tag">&lt;/<span class="title">Linear</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="title">Creative</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">Creative</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="title">CompanionAds</span>&gt;</span>...<span class="tag">&lt;/<span class="title">CompanionAds</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="title">Creative</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">Creatives</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">InLine</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">Ad</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">VAST</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>参考阅读</strong>：<br><a href="http://www.iab.com/guidelines/digital-video-ad-serving-template-vast-3-0/" target="_blank" rel="external">Digital Video Ad Serving Template (VAST) 3.0</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>说到VAST，就不得不提到<a href="http://www.iab.com">IAB</a>，全称为Interactive Advertising Bureau，我们称之为互联网广告署，它的主要职责是制定网络业务流程的开发标准以及行业准则，并对网络广告收入进行跟踪。</p>
<p>我们今天要介绍的就是IAB的六个主要部分之一——VAST（Video Ad Serving Template）。它是互联网视频广告的统一标准，采用XML格式。随着在线视频内容的广告越来越普遍，人们也越来越关注互联网视频广告的商业化，在VAST出台之前，视频广告并没有统一的广告协议，行业乱象促使需要有人站出来制定一个通用的标准，这时候IAB开始出来行使它的职责，它为在线互联网视频广告制定了一套统一的、可扩展的广告协议。VAST消除了视频广告的技术壁垒，在VAST3.0之前，已经有两个较为普遍的版本，但是现在通用、流行的就是我们说的3.0版本，3.0版本保证了对2.0的兼容。</p>
<p>VAST协议主要包含以下三部分：</p>
<blockquote>
<p>视频广告的内容（creatives）<br>视频广告的跟踪事件及其追踪链接<br>视频广告的wrapper</p>
</blockquote>]]>
    
    </summary>
    
      <category term="VAST" scheme="http://leotse90.com/tags/VAST/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
</feed>
