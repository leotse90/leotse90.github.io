<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一条心猿意码的狗]]></title>
  <subtitle><![CDATA[My name is L.T.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leotse90.com/"/>
  <updated>2016-01-18T16:18:13.000Z</updated>
  <id>http://leotse90.com/</id>
  
  <author>
    <name><![CDATA[Leo Tse]]></name>
    <email><![CDATA[proleo@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android中的Bitmap]]></title>
    <link href="http://leotse90.com/2016/01/19/Android-Bitmap/"/>
    <id>http://leotse90.com/2016/01/19/Android-Bitmap/</id>
    <published>2016-01-18T16:10:12.000Z</published>
    <updated>2016-01-18T16:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Bitmap简介">Bitmap简介</h2><p>Bitmap，我们称之为位图文件，它的扩展名一般是.bmp，有时也可以是.dip。位图由点（像素）组成，其可以理解为一个像素矩阵，矩阵中的每一个点表示对应位置上像素的颜色，每个点可以由多种颜色组成，包括2，4，8，16，24，32位色彩。一张1200x628分辨率的32位真彩图片，所占的存储空间为：1200x628x32/(8x1024)＝2944KB。由于位图的构造，使得其图像效果很好好，它是非压缩格式的，但是这也导致它需要占用较大的存储空间，这让位图变得不太适合在网络上传输。</p>
<p><img src="/img/bitmap-example.bmp" alt="Bitmap example"><br><a id="more"></a><br>由于Bitmap的应用比较广泛，因此Android中常常使用到Bitmap。但是在使用Bitmap的时候，我们常常需要考虑到其占用内存较大的事实，因此关注Bitmap的OOM异常成为我们使用Bitmap的必修课。我们主要需要注意以下几个方面：</p>
<blockquote>
<p>1.Android系统资源有限；<br>2.Bitmap很能吃内存；<br>3.应用的UI一般加载多张Bitmap，这样会一下消耗很多内存。</p>
</blockquote>
<h2 id="Bitmap的处理">Bitmap的处理</h2><h3 id="Bitmap的加载优化">Bitmap的加载优化</h3><p>考虑我们前面讲到的Bitmap很耗内存，我们在加载Bitmap的时候就需要时时注意内存情况。在选择图片时，我们就需要知道找到一张合适的图片比一张效果好的图片更加合理（除非你的应用对图片质量要求很高，比如壁纸类应用）。这里介绍Android中的Bitmap的处理类：<code>BitmapFactory</code>。</p>
<p><code>BitmapFactory</code>提供了多种decode图片的方法，比如：<code>decodeByteArray()</code>，<code>decodeFile()</code>，<code>decodeResource()</code>等等，这些方法方便我们从不同的来源创建Bitmap，这些方法都可以通过<code>BitmapFactory.Options</code>来指定decode选项，设置<code>inJustDecodeBounds</code>属性为true可以在decode时避免分配内存，它会返回一个空的Bitmap，但是我们可以获取到Bitmap的outWidth, outHeight与outMimeType。我们这样就可以在构造Bitmap之前读图片的尺寸与类型。为了避免OOM，我们在一开始就可以检查Bitmap图片的尺寸。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkBitmap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BitmapFactory.Options mOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    mOptions.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(getImgResource(), R.id.mImage, mOptions);</span><br><span class="line">    <span class="keyword">int</span> mImgHeight = mOptions.outHeight;</span><br><span class="line">    <span class="keyword">int</span> mImgWidth = mOptions.outWidth;</span><br><span class="line">    String mImgType = mOptions.outMimeType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resources <span class="title">getImgResource</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在获取了Bitmap的尺寸后，就能很灵活地决定是否需要加载完整的Bitmap图片，如果我们在评估以下几项后决定是否需要加载一个缩小版本的图片：</p>
<blockquote>
<p>1.加载完整的Bitmap需要耗费的内存；<br>2.加载这张Bitmap是否会增加其他相关的内存占用；<br>3.放置这张图片的的控件尺寸是否合适；<br>4.屏幕大小以及设备的屏幕密度；</p>
</blockquote>
<p>在评估后如果觉得没有必要加载完整的图片就可以考虑加载缩小版的Bitmap。我们需要告诉Bitmap的解码器我们打算加载缩小版的Bitmap，这时可以在<code>BitmapFactory.Options</code>中设置<code>inSampleSize</code>的值，例如, 一个分辨率为2048x1536的图片，如果设置<code>inSampleSize</code>为4，那么会产出一个大约512x384大小的Bitmap。加载这张缩小的图片仅仅使用大概0.75MB的内存，如果是加载完整尺寸的图片，那么大概需要花费12MB（前提都是Bitmap的配置是 ARGB_8888）。下面有一段根据目标图片大小来计算Sample图片大小的代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(</span><br><span class="line">            BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw height and width of image</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span></span><br><span class="line">        <span class="comment">// height and width larger than the requested height and width.</span></span><br><span class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt; reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;</span><br><span class="line">            inSampleSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Note</strong>: 设置inSampleSize为2的幂是因为解码器最终还是会对非2的幂的数进行向下处理，获取到最靠近2的幂的数。详情参考<code>inSampleSize</code>的文档。<br>为了使用该方法，首先需要设置<code>inJustDecodeBounds</code>为true, 把options的值传递过来，然后设置<code>inSampleSize</code>的值并设置 <code>inJustDecodeBounds</code>为false，之后重新调用相关的解码方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId,</span><br><span class="line">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First decode with inJustDecodeBounds=true to check dimensions</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate inSampleSize</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode bitmap with inSampleSize set</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用上面这个方法可以简单地加载一张任意大小的图片。如下面的代码样例显示了一个接近100x100像素的缩略图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mImageView.setImageBitmap(</span><br><span class="line">    decodeSampledBitmapFromResource(getImgResources(), R.id.mImage, <span class="number">100</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure></p>
<p>类似的，我们也可以通过替换合适的<code>BitmapFactory</code>解码方法来实现一个类似的方法从其他的数据源解析Bitmap。</p>
<h3 id="Bitmap的内存管理与缓存">Bitmap的内存管理与缓存</h3><p>在Android的演变进程中，管理Bitmap内存也发生了改变。在Android 2.2及以前的版本，当GC的时候，应用的线程会被暂停，在Android2.3开始，新增了并发GC机制，<strong>这意味着在一个Bitmap不再被引用之后，它所占用的内存会被立即回收。</strong><br>在Android2.3.3及之前，一个Bitmap的像素级是存放在Native空间里，这些数据与Bitmap本身是隔离的，Bitmap本身被存放在Dalvik堆中，我们无法预测在Native内存中的像素级数据何时会被释放，这意味着程序容易超过它的内存限制并且崩溃。自Android 3.0开始， 像素级数据则是与Bitmap本身一起存放在Dalvik堆中。</p>
<p>好在我们现在Android的主流版本在Android4.0以上，因此Bitmap在不被引用后就会被回收。</p>
<blockquote>
<p>在过去，一种比较流行的内存缓存实现方法是使用软引用（SoftReference）或弱引用（WeakReference）对Bitmap进行缓存，然而我们并不推荐这样的做法。从Android 2.3开始，垃圾回收机制变得更加频繁，这使得释放软（弱）引用的频率也随之增高，导致使用引用的效率降低很多。而且在Android 3.0之前，备份的Bitmap会存放在Native Memory中，它不是以可预知的方式被释放的，这样可能导致程序超出它的内存限制而崩溃。</p>
</blockquote>
<h3 id="Bitmap的线程操作">Bitmap的线程操作</h3><p>我们可以通过<code>BitmapFactory</code>的解码方法来获取Bitmap，但是当图片来源于网络或者其他非内存来源时，我们就需要考虑由此带来的线程问题，毕竟我们在UI线程上不适合干这件事，那么我们可以考虑使用<code>AsyncTask</code>：加载Bitmap的类继承<code>AsyncTask</code>，并重载<code>doInBackground()</code>以及<code>onPostExecute()</code>方法。开始异步加载Bitmap，只需要创建一个新的任务并执行它即可。</p>
<blockquote>
<p>为ImageView使用WeakReference确保了AsyncTask所引用的资源可以被垃圾回收器回收。由于当任务结束时不能确保ImageView仍然存在，因此我们必须在onPostExecute()里面对引用进行检查。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference imageViewReference;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapWorkerTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a WeakReference to ensure the ImageView can be garbage collected</span></span><br><span class="line">        imageViewReference = <span class="keyword">new</span> WeakReference(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode image in background.</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        data = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> decodeSampledBitmapFromResource(getResources(), data, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once complete, see if ImageView is still around and set bitmap.</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageViewReference != <span class="keyword">null</span> &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ImageView imageView = imageViewReference.get();</span><br><span class="line">            <span class="keyword">if</span> (imageView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以按照这样异步加载Bitmap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(imageView);</span><br><span class="line">    task.execute(resId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们就Android中的Bitmap进行比较全面的介绍，当然可以参考官网了解更多有关<a href="http://developer.android.com/reference/android/graphics/Bitmap.html" target="_blank" rel="external">Bitmap</a>的信息。</p>
<p>(整理自网络)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Bitmap简介">Bitmap简介</h2><p>Bitmap，我们称之为位图文件，它的扩展名一般是.bmp，有时也可以是.dip。位图由点（像素）组成，其可以理解为一个像素矩阵，矩阵中的每一个点表示对应位置上像素的颜色，每个点可以由多种颜色组成，包括2，4，8，16，24，32位色彩。一张1200x628分辨率的32位真彩图片，所占的存储空间为：1200x628x32/(8x1024)＝2944KB。由于位图的构造，使得其图像效果很好好，它是非压缩格式的，但是这也导致它需要占用较大的存储空间，这让位图变得不太适合在网络上传输。</p>
<p><img src="/img/bitmap-example.bmp" alt="Bitmap example"><br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://leotse90.com/tags/Android/"/>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发(三)]]></title>
    <link href="http://leotse90.com/2016/01/12/Java-concurrency3/"/>
    <id>http://leotse90.com/2016/01/12/Java-concurrency3/</id>
    <published>2016-01-11T16:15:21.000Z</published>
    <updated>2016-01-11T16:16:10.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="返回值">返回值</h2><p>我们知道，可以通过创建Runnable来创建任务，但是我们却不能通过这种方式返回值。Java因此提供了另一个接口来达到返回一个值的目的，这个接口就是Callable。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法中返回的值的类型，我们通过ExecutorService.submit()来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leotse.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CallableTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"This is task "</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService eService = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i ++)&#123;</span><br><span class="line">			results.add(eService.submit(<span class="keyword">new</span> CallableTask(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Future&lt;String&gt; r : results)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(r.get());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				eService.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这个例子向我们展示了Callable的用法。Callable中的call()相当于Runnable中的run()方法。<br>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。可以通过get方法获取执行结果，get()方法会阻塞直到任务返回结果。  </p>
<p>我们在这里对比一下Callable与Runnable的一些主要区别：</p>
<blockquote>
<p>1.Callable接口提供了call()方法，Runnable接口提供了run()方法；<br>2.call()有返回值，run()方法没有返回值；<br>3.call()可以抛出受检查的异常，run()则不能抛出受检查的异常。</p>
</blockquote>
<h2 id="线程休眠">线程休眠</h2><p>有时候，我们在程序中，需要线程等待一段时间，我们可以通过sleep()方法通知Thread暂停指定的时间。线程的休眠相对比较简单，还是来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SleepTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Task "</span> + id + <span class="string">", currentTimeMillis is "</span> + System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepTask(i));</span><br><span class="line">			t.start();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task <span class="number">0</span>, currentTimeMillis is <span class="number">1452526404372</span></span><br><span class="line">Task <span class="number">1</span>, currentTimeMillis is <span class="number">1452526406373</span></span><br><span class="line">Task <span class="number">2</span>, currentTimeMillis is <span class="number">1452526408373</span></span><br><span class="line">Task <span class="number">3</span>, currentTimeMillis is <span class="number">1452526410374</span></span><br><span class="line">Task <span class="number">4</span>, currentTimeMillis is <span class="number">1452526412375</span></span><br></pre></td></tr></table></figure></p>
<p>这样的时间比较难以辨认，你可以使用Date类打印标准化时间，以便更加直观看到sleep()的效果。</p>
<h2 id="线程的优先级">线程的优先级</h2><p>我们在并发程序中启动了多个线程，但是这些线程并不一定在重要程度上一样，我们用线程的<strong>优先级</strong>来定义线程的重要程序。线程的优先级意味着不同级别的线程占用CPU的概率不同，优先级低的线程不会不执行。一般来说，程序中的优先级都以默认的优先级来运行，线程的优先级可以通过getPriority()方法来获取。但是一般不建议控制线程的优先级，因为调度器的行为并不可控。</p>
<h2 id="线程让步">线程让步</h2><p>我们在上一篇<a href="http://leotse90.com/2016/01/07/Java-concurrency2/">博客</a>中介绍Thread的时候提到了yield()方法，该方法的作用是告诉当前线程：嘿，你已经用了CPU一段时间了，是时候让出CPU了。但是这只是一种建议，而不是一种保证。一般来说，对于任何重要的控制或在调整应用时，都不能指望yield()方法能达成我们的目的。</p>
<h2 id="后台线程">后台线程</h2><p>如果在应用中，我们需要进行网络请求，或者我们需要执行一些不太重要的事情，这些任务就可以放在后台线程中。后台线程（Daemon）并不是程序中不可或缺的部分，所以如果程序中所有的非后台线程都已经结束，那么程序就已经执行结束，同时会kill掉所有的后台线程。换言之，只要有任何非后台线程还在运行状态，程序就不会结束。</p>
<p>如果要指定一个线程为Daemon线程，只需调用setDaemon()方法即可，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>当程序中最后一个非后台线程终止运行，后台线程就会突然终止，因此一旦main()退出，JVM就会立即关闭所有的后台进程。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="返回值">返回值</h2><p>我们知道，可以通过创建Runnable来创建任务，但是我们却不能通过这种方式返回值。Java因此提供了另一个接口来达到返回一个值的目的，这个接口就是Callable。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法中返回的值的类型，我们通过ExecutorService.submit()来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leotse.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CallableTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"This is task "</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService eService = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i ++)&#123;</span><br><span class="line">			results.add(eService.submit(<span class="keyword">new</span> CallableTask(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Future&lt;String&gt; r : results)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(r.get());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				eService.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发(二)]]></title>
    <link href="http://leotse90.com/2016/01/07/Java-concurrency2/"/>
    <id>http://leotse90.com/2016/01/07/Java-concurrency2/</id>
    <published>2016-01-06T16:26:33.000Z</published>
    <updated>2016-01-09T17:22:00.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Java的线程机制">Java的线程机制</h2><p>我们在上一篇<a href="http://leotse90.com/2016/01/06/Java-concurrency1/">博客</a>中，提到最理想的实现并发编程的方式就是使用进程，但是Java中我们使用线程进行多任务处理，原因在上一篇博客中也已经提及。</p>
<p>在Java中，每一个线程都会对应一个任务，这些任务构成了一个并发的程序。    在底层看来，每一个线程都觉得自己独占了CPU，虽然事实上它们只是在某一个时间切片上占有了CPU。CPU会轮流给每一个线程分配时间，这些细节一般不需要我们去了解。</p>
<h3 id="Runnable接口">Runnable接口</h3><p>我们知道，Java中的并发程序是由任务构成，那么Java中怎么声明一个任务呢？Java为我们提供了一个Runnable接口，凡是实现了Runnable接口的类皆可以称之为一个任务。下面的实例展示了Java中如何声明任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I am a task"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我们看到这里有一个run()方法，我们将打算在这个任务中执行的业务逻辑都放在run()方法中。我们另行编写一个测试类用来执行这个Task。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyRunnable task = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">		task.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行的结果如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am <span class="tag">a</span> task</span><br></pre></td></tr></table></figure></p>
<p>这样看来，觉得Runnable和普通的Java类没有什么区别。这里只是在main()线程中执行了这个任务。如果我们希望这个任务和一个线程对应起来，应该怎么做呢？我们需要显式地将任务绑定到一个线程上。这就需要我们用到Thread类。</p>
<h3 id="Thread类">Thread类</h3><p>在Java中，一个Thread类的对象就是一个Java程序的执行线程。JVM允许一个程序有多个线程。每一个线程都有其优先级，高优先级的线程会先于低优先级的线程执行，想必这个很容易理解。每一个线程都可以被声明为一个后台线程。如果一个运行的线程中创建了一个新的Thread对象，那么这个新的Thread对象的初始优先级和创建它的线程一样，如果创建它的线程是一个后台线程，那么这个新的Thread对象也是一个后台线程。</p>
<p>当JVM启动时，通常会有一个非后台线程运行，这就是我们熟知的main线程，JVM会一直执行程序中的线程直到发生了下列情况：<br>1）Runtime类的exit()方法被调用，并且安全管理器允许这个退出操作执行；<br>2）所有的线程都是非后台进程，而且都已经停止运行；或者获取了run()方法调用的返回值；又或者run()抛出了一个异常。</p>
<p>我们在上面提到需要显示将一个任务和一个线程绑定在一起。常用的方法就是在创建一个Thread对象的时候将任务作为构造器的参数。我们将前面的MyRunnable类改造一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threadCount = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.threadCount = count;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Thread "</span> + threadCount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们编写另一个类MyThreadDemo来创建任务并执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">			MyRunnable task = <span class="keyword">new</span> MyRunnable(i);</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者我们可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(i)).start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们创建了5个任务，并把它们分别和一个Thread对象进行绑定，然后执行这些线程，得到结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span></span><br><span class="line">Thread <span class="number">4</span></span><br><span class="line">Thread <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>由于线程调度机制是非确定性的，所以每次执行的结果都可能会不同。</p>
<p>在Thread类中，我们需要关注以下一些主要的方法：<br><strong>yield()</strong>:该方法会建议调度器当前进程将要让出自己对处理器的使用，但是调度器可以选择是否需要接受这个建议。一般不建议使用这个方法，但是如果在debug或测试的时候还是可以使用的。</p>
<p><strong>sleep()</strong>:这个方法可以短暂中断当前执行线程。我们可以指定当前执行线程的休眠时间；</p>
<p><strong>start()</strong>:开始执行一个线程，当调用这个方法时，JVM会执行这个线程的run()方法。调用这个方法的结果就是两个线程并发执行：从这个start()方法调用返回的线程，执行run()方法的线程。需要注意的是，我们不能多次启动同一个线程，而且一个线程一旦执行结束就不能重启；阅读Thread的源码可知，start()本身是一个同步方法，且里面调用了本地方法start0()方法启动一个线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is not invoked for the main method thread or "system"</span><br><span class="line">     * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">     * to this method in the future may have to also be added to the VM.</span><br><span class="line">     *</span><br><span class="line">     * A zero status value corresponds to state "NEW".</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span><br><span class="line">     * so that it can be added to the group's list of threads</span><br><span class="line">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span><br><span class="line">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>exit()</strong>:系统调用这个方法以期让一个线程在其真正退出运行前进行资源的清理工作；</p>
<p><strong>interrupt()</strong>:中断当前线程。但是在实际编程中，我们在使用它时需要特别注意，你可以看看这篇<a href="http://www.blogjava.net/jinfeng_wang/archive/2008/04/27/196477.html" target="_blank" rel="external">博客</a></p>
<blockquote>
<p>许多程序员都建议使用runnable，因为直接继承Thread类会增加类的层次。</p>
</blockquote>
<p>这些都是Java的线程机制中比较基础的，还有其他的诸如Executor以及优先级等其他概念，我们将在下一次介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Java的线程机制">Java的线程机制</h2><p>我们在上一篇<a href="http://leotse90.com/2016/01/06/Java-concurrency1/">博客</a>中，提到最理想的实现并发编程的方式就是使用进程，但是Java中我们使用线程进行多任务处理，原因在上一篇博客中也已经提及。</p>
<p>在Java中，每一个线程都会对应一个任务，这些任务构成了一个并发的程序。    在底层看来，每一个线程都觉得自己独占了CPU，虽然事实上它们只是在某一个时间切片上占有了CPU。CPU会轮流给每一个线程分配时间，这些细节一般不需要我们去了解。</p>
<h3 id="Runnable接口">Runnable接口</h3><p>我们知道，Java中的并发程序是由任务构成，那么Java中怎么声明一个任务呢？Java为我们提供了一个Runnable接口，凡是实现了Runnable接口的类皆可以称之为一个任务。下面的实例展示了Java中如何声明任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I am a task"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发(一)]]></title>
    <link href="http://leotse90.com/2016/01/06/Java-concurrency1/"/>
    <id>http://leotse90.com/2016/01/06/Java-concurrency1/</id>
    <published>2016-01-05T16:30:15.000Z</published>
    <updated>2016-01-06T16:28:01.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="并发，并发，并发">并发，并发，并发</h2><p>有顺序编程，就有并发编程。事实上，几乎我们所有的程序都可以通过顺序编程来完成，只是你必须忍受一些非常情况。<br>并发说起来很奇怪，它具有可论证的确定性，但是实际上却具有不可确定性。它的不可确定性是因为你没有办法预知在实际情况下会发生事情导致工作失败，而且你也没有办法通过编写代码进行完备的测试。<br>虽然实际应用中，并发很难做到完全掌握，但是这不能成为我们不作为的理由。</p>
<blockquote>
<p>如果视而不见，你就会遭其反噬。</p>
</blockquote>
<p>作为一名骄傲的程序员，并发编程是基础，也是必备知识。</p>
<h2 id="为什么需要并发">为什么需要并发</h2><p>这是一个老生常谈的问题，但是我们不能规避这个问题，要想深入理解一件事物，就必须弄清楚它的来龙去脉。<br><a id="more"></a><br>我们设定我们现在在做饭，我们需要做的事情list如下：<br>1）淘洗大米；<br>2）插电做饭；<br>3）洗好紫菜；<br>4）打鸡蛋；<br>5）洗净豌豆并剥开；<br>6）牛肉切丁；<br>…</p>
<p>是的，我们想来一顿米饭＋紫菜蛋汤＋豌豆牛肉粒的穷人版商务套餐。我们可以有很多种方法完成这顿午餐。其中有两种常见可行的方案：<br>1.完全按照顺序来，即1) -&gt; 2) -&gt; 3) -&gt; 4) -&gt; 5) -&gt; 6)，也就是每次都需要等待上一个步骤完成再进行下一步；<br>2.我们将时间打碎，在完成1) -&gt; 2)之后，无需等待2）完成，即不用等到生米煮成熟饭，就开始着手洗紫菜、打鸡蛋，然后在煲汤的同时，开始准备豌豆和牛肉。</p>
<p>很明显，除了死心眼，大家都会选择第2种方案或者其他类似的方案。第1种方案就是我们所说的顺序编程，而第二种方案就是并发编程。</p>
<blockquote>
<p>通常来说，并发是提高运行在单核上的程序的性能。</p>
</blockquote>
<p>为什么是提供单核上程序的性能呢？<br>如果只有一个核即处理器，我们来回切换工作，反而会增加上下文切换的损耗，怎么会是提高性能呢？如果和上述的例子结合起来就不难发现，如果有些事情需要等待，但是这个等待的时间间隙我们可以做一些并不依赖于正在处理的事情的其他业务，比如做菜并不依赖煮饭（除非你用同一口锅），洗豌豆并不依赖于煲汤。这样我们的时间就被充分利用起来了。用行话来说，就是<strong>阻塞</strong>。如果程序中的某个任务因为该程序控制范围外的某些条件而导致不能继续执行，那么我们就说这个任务或者线程阻塞了。如果没有引入并发，那么线程将一直阻塞，直至这些条件发生改变。</p>
<blockquote>
<p>某种程度上讲，没有阻塞，就没有并发。（单核）</p>
</blockquote>
<p>最简单直接的方式就是使用进程。<br>多任务操作系统会周期性将CPU从一个进程切换到另一个进程，虽然会有切换带来的耗时，但是对用户来说基本可以当作同时在运行多个进程。而且操作系统会帮我们将这些进程隔离开来，每个进程都有自己的一亩三分地，使得它们变得相互独立。这对并发编程来说，似乎非常理想，不会出现争夺公共资源的情况，每个任务都在自己的地址空间中做着自己的事情，进程们也根本不需要相互通信。但是进程通常都有数量限制以及开销上的限制，因此在实际编程中并不常见直接将进程作为并发的实现方式。</p>
<blockquote>
<p>函数型语言被设计为可以将并发任务彼此隔离，其中每个函数的调用都不会产生任何副作用，因此可以当作独立的任务来驱动。</p>
</blockquote>
<p>在Java中，我们常常用到的是在顺序编程的基础上使用比进程更小粒度的线程来实现并发。编写Java并发程序的一个最基本的困难是如何协调不同线程驱动的任务之间对一些公共资源（如IO、内存）的使用。</p>
<p>使用并发的另一个目的是改进代码设计。我们前面提到，我们可以使用顺序编程完成几乎所有程序，但是这会使得我们的程序变得复杂，使用并发可以使得我们的程序结构更加清晰简化。</p>
<p>我们假设我们的程序由很多的部件的组成，每一个部件都可以独立运作，那么理想情况就是每一个部件都对应一个线程，但是实际上我们的多线程系统一般都会限制线程的数量，而且这个数字不会太大，因此我们往往我们不能达到理想情况下的每一个部件都对应一个线程。在Java中，线程机制是抢占式的，也就是说，系统可能周期性中断线程，然后切换到另一个线程，从而让每个线程都有运行的时间片。我们可以通过协作多线程来解决这个问题。在协作式系统中，每个任务都是可控的，即可以通过编程人员的控制自动放弃控制，相对于抢占式线程机制，协作式线程机制一方面上下文切换的开销小，另一方面同时执行的线程数量理论上没有限制。</p>
<p>当然，并发是有代价的，那就是我们需要额外花费上下文切换的代价，但是这个代价不算高昂，特别是和它所带来的收益进行比较。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="并发，并发，并发">并发，并发，并发</h2><p>有顺序编程，就有并发编程。事实上，几乎我们所有的程序都可以通过顺序编程来完成，只是你必须忍受一些非常情况。<br>并发说起来很奇怪，它具有可论证的确定性，但是实际上却具有不可确定性。它的不可确定性是因为你没有办法预知在实际情况下会发生事情导致工作失败，而且你也没有办法通过编写代码进行完备的测试。<br>虽然实际应用中，并发很难做到完全掌握，但是这不能成为我们不作为的理由。</p>
<blockquote>
<p>如果视而不见，你就会遭其反噬。</p>
</blockquote>
<p>作为一名骄傲的程序员，并发编程是基础，也是必备知识。</p>
<h2 id="为什么需要并发">为什么需要并发</h2><p>这是一个老生常谈的问题，但是我们不能规避这个问题，要想深入理解一件事物，就必须弄清楚它的来龙去脉。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[企业计算的终结]]></title>
    <link href="http://leotse90.com/2015/12/17/%E4%BC%81%E4%B8%9A%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%88%E7%BB%93/"/>
    <id>http://leotse90.com/2015/12/17/企业计算的终结/</id>
    <published>2015-12-17T14:25:21.000Z</published>
    <updated>2015-12-17T14:54:42.000Z</updated>
    <content type="html"><![CDATA[<p><em>作者：尼古拉斯·卡尔</em><br><em>翻译：黄思路</em><br><em>文章来源：《斯隆管理评论》</em></p>
<p><em>这是在36kr上看到的一篇文章，对于文中有关信息技术发展的理解感触颇深，于是kiang到了这里(<a href="http://36kr.com/p/5041175.html" target="_blank" rel="external">原文</a>)。</em></p>
<blockquote>
<p>花费数百万美元打造内部数据中心后，企业往往会发现面临着快速淘汰这些数据库的窘境。IT 正从一种企业资产转变为一种服务购买。</p>
</blockquote>
<p>20 世纪早期，有一些之前的几十年里无法想象的事情陆续发生：制造厂商开始关闭、拆除水轮设备、蒸汽机和发电机。要知道，从工业时代开始，电力就是任何产业得以运作的必要前提，工厂作坊除了维持独立发电站来使运作机器以外别无选择。新世纪的到来带来了一种新的可能，许多新兴发电商开始通过建立中央电厂和使用电网给远距离外的客户输送电能。制造商本身不需要再维持独立发电站的运营，他们可以从这些新兴发电商那里购买需要的用电。</p>
<p>几乎过了整整一个世纪后，历史再次重演。过去50年中最重要的一项商业成就——信息技术——正在经历类似的转变。信息技术曾以电脑、软件和其他各式各样的形式作为公司的一种资产，而现在，它正在转化为一种从效用供应商那里购买的服务。商业界很少有公司真正意识到这个转变的重大意义和深远影响。至今，关于效应计算的讨论也仅仅是停留在信息技术供应商的市场标语里，如同那些含义模糊的各类名词，“自动系统”、“服务及虚拟化”、“服务型架构” 等等。其实这些充满官腔的言词不仅没有着向大众照亮这一转变的未来，更使人们对于它的理解变得非常模糊。<br><a id="more"></a><br>当下最盛行的一种观点也非常保守。这种观点认为现有的信息技术供应和应用模型会持续下去，并且企业数据中心仍然会是这种模型的核心。然而，这样的看法非常短浅，而且极具危险性。传统模型的经济基础已经动摇，并且在未来很难幸存。<strong>如同早期电力供应的转变警示的那样，信息技术从分散资产向集中效应服务的转变有着重大意义</strong>。这将颠覆战略、运营的早先设想，改变产业经济，扰乱市场，以及给每一位用户和供应商带来艰巨的挑战。信息技术的商业化应用历史总被描述为伴随惊人的飞跃，但是我们眼下的这场大变革是史上未见的——哪怕是个人电脑或是因特网的问世也无法与之相提并论。</p>
<h2 id="从资产到花费">从资产到花费</h2><p>信息技术如同之前的蒸汽和电力，被经济学家称为通用技术的一种。通用技术被大大小小的公司用来处理纷繁复杂的各类事务，给商业和社会带来深远的变化。在供应稳定的前提下，通用技术的广泛应用为规模经济的发展提供了巨大潜力。不过这类经济需要一段很长的时间才能被完全认识、全面开发。在通用技术发展的早期阶段，技术标准远未完善，配置网络也非常局限，很难得以集中发展。因此通用技术的供应根据不同需要相匹配，发展模式非常分散。个体公司必须采购各种使用这种技术需要的配置，组装、搭建好之后想办法使这套系统运转起来，并专门雇佣专家进行保养和维修。</p>
<p><strong>这样的分散式供应其实非常的浪费资源：它对各家公司来说意味着大量的投资和高昂的成本，并在技术和劳动力方面导致沉重的多余开支和极高的产能过剩。</strong>这种状况对于技术配置提供商来说无疑是有利的，因为他们可以从这种过度投资中获益颇丰，然而这种模式最终还是不可持续的。随着通用技术的发展，集中输送也具备了可能，大型的公共服务供应商开始取代私人供应商。尽管公司可能需要数年的时间弃置他们专有的供应业务和这背后的沉没成本，与大型供应商合作所带来的成本节约还是更具吸引力，对那些大型企业来说也是无法拒绝的诱惑。放弃旧模式也就成为了一种打造竞争力的必然做法。</p>
<p>电力供应的演变就是印证这一过程的一个明确案例。19世纪80年代，商业供电才刚开始，很多小型供电商在城市迅速发展，他们中的很多都是小规模个体运营，使用燃煤发电机生产容量非常有限的电力。由于他们的电力是直流电，不能被输送的很远，这个服务距离也就被限制在一英里之内。运营的高成本使得他们向客户征收高昂的费用，因此他们的客户大多都是财力雄厚的商场、写字楼、业主和市政机构，这些客户需要电力的目的主要是用以维持照明系统。</p>
<p>仅依靠这些小型发电站对于大型工业发展来说并非长久之计。为了满足大量的电力需求，大型工业企业必须建立自己的发电站。他们与电力提供商，比如通用电气和西屋电气签订协约，从他们那里获取发电设备和专业人员配备，雇佣电气工程师和相关专家操作、维护这一套复杂的系统，使之融入生产链的运作中。在电气化早期发展的阶段，私人发电商很快占据了主导地位。到1902年，在美国境内大约有50000家私人发电厂。1907年，这些工厂已经在生产整个国家使用的电力中的60%。</p>
<p>和这些大厂商的情况不同，像城市印刷厂这样的小型工业企业选取的是完全不同的路径。他们无法承担安装发电机和配备维修人员的费用，因而只能依靠附近的集中发电站，即使这意味着要付一笔不菲的费用，还要忍受频繁的电力中断。那时候，这些小厂商的感受就像是在电气化竞赛中被甩后一截而不得不采用看上去低人一等的供应模式，以此维持电力带来的生产率的提高。事实上，人们当时并没有想到这些小型企业其实是一种大趋势的先行者，很快的，他们强大的竞争对手也会意识到从外部供应商那里购买电力带来的明显优势，从而选择与他们一样的路。</p>
<p>这种转变的发生是以一系列的科技进步为背景的。第一，巨型热涡轮机的发展给规模经济提供了更大的潜力。第二，交变电流使电力输送的距离更远，扩大了中央电站可以服务的客户规模。第三，换流器的发明可以转换电流的不同形式，也就使得旧设备可以适应新系统的运作。最后，具备交流电下工作能力的电动机的发明使工厂可以利用新兴电网来运行机器。早在二十世纪初，所有技术元素就已经就位，向制造厂商提供集中化的电力供应，淘汰它们老化的、独立的发电机。</p>
<p><strong>单有技术进步也是不够的。现状的彻底改变也需要商业视野。能够把握技术、市场和经济趋势的综合体的人可以领先创造全新的供应模式</strong>——这个人就是一位名为塞缪尔·英萨尔的英国会计。对电力深有研究的英萨尔在 1880年移民纽约，很快成为托马斯·爱迪生最为信任的顾问，帮助这位发明家扩大商业帝国。不过英萨尔最伟大的成就是在他离开爱迪生之后，1892年 他辞去工作搬去了芝加哥，在那里担任一家拥有三个发电站和不超过5000名客户的小型独立发电公司的总裁。在不到25年的时间里，他将这家小公司打造成为世界上最大的企业之一——名为联邦爱迪生的大型垄断企业。</p>
<p>英萨尔最先意识到，通过新技术的资本化来巩固发电量，集中的公用事业可以满足任何大型工厂的电力需求。并且公用事业的规模经济加上用户群体中用电需求的扩散可以帮助他们获得更高的产能利用率，进而提供比私有的分量表发电便宜很多的电力。洞悉事态发展的英赛尔当机立断买下了芝加哥所有的小型发电公司，并且在自己的发电站中安置了5000千瓦的大型发电机。同样重要的行动还包括，英赛尔首先推出电能计量和可变定价，大幅削减对大客户的报价，以此稳固这些客源。最后，他详细制定了一套市场方案，使制造商确信，关闭原先的独立发电机转而从自己的公司购买电力才是明智之举。</p>
<p>随着芝加哥各大厂商朝自己的公司蜂拥而至，英赛尔的预见变成了现实。1908年 一位来自 Electrical World and Engieneer 的记者写道：“尽管在芝加哥还存在无数个体运作的发电厂，他们现在经历着的是前所未有的来自集中发电站的压迫…联邦爱迪生公司拥有的很多发电机以前都是属于芝加哥一些大型独立厂商的。” 质变的临界点已经到来。尽管很多厂商可能还是会在未来几年选择独立发电，私人发电向公共发电的转折已经开始。在1907年 到1920年间公共发电占了全美总量的40%-70%，到了1930年，这个比例已经上升到 80.8%。</p>
<p>将电力由一项复杂资产转化为一种常规的可变开支，这种观点的转变帮助厂商节约成本，腾出资本用于更有价值的生产目标。同时，他们可以精简员工，减少技术过时和故障的风险，企业管理人员也因此可以避免对重大隐患的时刻担忧。曾经无法想象的公共电力的广泛使用已经不可逆转的发生，私人发电站也被时代淘汰。</p>
<h2 id="信息技术转型开始">信息技术转型开始</h2><p>当然，历史的类比总是有其局限性，信息技术和电力技术有太多重大区别。比如，信息技术所包涵的软件程序是人类智慧的产品，受到知识产权法的保护。不过，信息技术和电力技术之间也有很多相同之处——而当代的观察者很容易忽视这些相似点。今天，人们把电看做一种 “简易” 的效用，毫无新鲜感的电流会遵循安全的、设计好的途径通过埋在墙壁里的插座。已经见惯了无数和电有关的工具，从家用台灯到装配线上的机床，电已经变得如此平常，以至于我们不再把它看作为一种了不起的基础科技——它们经历了独特又熟悉的生命演变。不过，事实并非总是如此。</p>
<p>电气化刚开始时，电是一种极其复杂、不可预知并且还远未被完全掌控的力量，它可以改变任何它触碰到的东西。借用现代的术语，电的应用层当时只停留在发电机、电线和电流本身。人们需要研究清楚如何将电力应用到具体运营中，也就由此衍生出各种根本性的改变、长期实践、业务流程和组织架构。随着科技的进步，人们不得不经常与老化、过时的设备作斗争——所谓的 “遗产系统（传统系统）” 往往会阻碍进步的发展。</p>
<p>作为一种商业资源或输入的信息技术科技，今天看来与上世纪电力技术发展的开端颇为相似。公司企业从供应商那里购买各类设备，包括电脑、储存硬盘、网络交换机以及各种软件，然后将所有这些融合到一套复杂的、内部的信息处理系统或者数据库中。他们聘请专门的工作人员维护这套系统，还经常需要外部顾问来解决尤其棘手的问题。公司的执行层工作常常会因为这受到牵制，影响真正的业务表现——以汽车行业为例，为了维持公司的独立信息基础设施运行顺畅，汽车制造和销售都需要极尽所能最大化利润。</p>
<p>成千上万的独立数据中心使用的其实是基本类似的硬件系统和软件程序，而这些数据中心已经给很多个体公司带来了严重的危害，对整体经济来说也是如此。信息技术资产的过度建设导致极低程度的资本利用率。最近的一次对六家企业数据库的研究表明，超过 1000 台服务器仅仅发挥了 10%-35%的处理能力。台式电脑的表现就更加糟糕，以 IBM 为例，平均产能利用率只有 5%。总部位于康涅狄格州斯坦福德的 Gartner 公司通过研究发现，大约 50%-60%的公司数据存储容量处于被浪费的状态。产能过剩的状态也不仅限于硬件。由于软件程序具有极高的扩展性，也就是说，它们可以在极少甚至没有增量成本的前提下服务更多的用户，因而在数千个不同的网站安装完全一样或类似的软件会导致急剧的经营管理失当，不管是在前期支出还是在现行成本费用方面。各家公司对大同小异的 IT 部门的复制也会导致对劳动力的过度投资。2003年 的一项调查显示，美国各家公司 IT 部门平均预算的 60%都被用于常规支持和功能性维护。</p>
<h2 id="个人电脑">个人电脑</h2><p>如果说有什么可以代表现今企业IT状况的话，那无疑是个人电脑。个人电脑不仅占据了现代公司的每一张办公桌，更是典型的企业计算总体状况的缩影：零散、多余、并且越来越疏于利用。</p>
<p>个人电脑的发明是一个伟大的成就，是现近代商业史上一项最重要的发明。它使计算能力扩散到个人，激发创新，提高个人生产力，并且无疑加速了网络的发展，包括因特网和 World Wide Web。然而强大的、高容量的网络的发展也使台式电脑的必要性越来越低；计算资源可以不论距离、越来越多的被提供给用户。当个人电脑的容量达到最大时，用户的需求却并没有保持一致的扩张。人们仅仅使用计算马力中极小部分，现代电脑的多GB硬盘容量也往往要不是空的，要不就被塞满无价值的文件。</p>
<p>有人争论说个人电脑现在反正非常便宜，也就无所谓有没有被浪费了。然而这种说法并没有考虑到维护、更新大量个人电脑和相关软件所产生的庞大开支，也忽视了个人电脑常常是现代公司最大安全隐患这一事实——黑客入口和诉讼证据储存库。</p>
<p>上世纪90年代后期，Oracel 首席执行官拉里艾里森因为声称个人电脑会成为 “一种可笑的设备” 而广受批评，他认为个人电脑将被瘦客户机所取代——连接中央主机的终端以及其他精简设备。艾里森的论断的时机也许并不正确，但并不代表这个论断也不正确。随着效用计算的发展，现代公司保留台式电脑的倾向将越来越弱。在家里，个人电脑也许是计算的引擎，但是在商业里，它却无足轻重，并且越来越不必要。</p>
<p>当产能过剩与冗余功能相结合，向集中供应的转变也就具备了成熟的条件。然而公司持续在维护甚至扩大个体数据中心上进行大量投资，这是为什么？就和 20世纪早期制造厂商依旧安装个体发电机的原因一样：缺少可靠、大规模的效用模型。而这种模型现在正在产生和发展。效用计算的初级形态正在增值，很多公司也在加快对他们的投资。有些公司使用由像 IBM、惠普公司和数据信息系统等供应商所提供的紧急硬件支持来维护自己的大数据中心，有些则采用远程软件商提供的应用程序。包括采购、运输管理、财务、客户服务、销售团队管理以及其它各种功能在内的这些程序项目已经充分表明，即使是非常复杂的应用也可以通过服务提供的方式由因特网获取。</p>
<h2 id="开拓者">开拓者</h2><p>小型公司在转向公共电力提供这方面打了先头。由于缺少建立独立发电站的资金，他们除了从外部供应商那里购买电力之外并没有什么其他选择。早起采用效应计算的公司中最激进的也属于资本受限的一类组织：中小型企业，政府机构和非营利组织。</p>
<p>例如，宾夕法尼亚联邦早在十年前就开始向效用计算的方式转移。经过几年的策划，该州于1999年秋天开始关闭17个政府组织所运营的数据中心，并巩固由优利系统公司领衔的供应商联盟提供的硬件和软件设施。类似的，纽约的林肯艺术中心也采用了效应模式。他们不再维持原先售票系统的应用程序和服务器，而是使用 IBM 提供和维护的硬件，只需要每个月缴纳一笔资费。</p>
<p>一些大企业开始在更大规模上接纳效用计算的方式。澳洲航空公司从 2004年 开始卸载他们的数据中心，将数百个服务器和大型计算机迁移到新供应商提供的设备。现在该公司只需要根据实际的计算容量使用量来支付相应的资费。澳洲航空公司甚至将业务中最核心的预定和票务系统外包给总部位于西班牙马德里的技术提供商 Amadeus 全球旅游分销。据澳航首席信息官菲奥娜贝尔福称，公司数据中心预算中用于固定成本的百分比已经从 70%降到了 30%，正是因为向效用供给的转变。</p>
<p>很多其他的大公司正在建立内部的 “效用” 供给，提供整个公司的计算资源。他们巩固了以往的分散计算、数据储存和网络硬件，实施更严格的软件标准，并利用包括虚拟化、网络服务在内的新技术给业务部门和企业公司提供最量身定做的服务。DHL近期整合了旗下八个北美数据中心，将它们融入位于亚利桑那的统一处理器中。从事化学和药物行业的拜耳美国将也将其信息技术运营加以集中，将42个数据中心整合为两处，并减半了服务器数量——这样做带来成本节约高达一亿美元。这也代表随着规模效用的出现，我们将向更广阔的信息技术资源整合又迈近一步。</p>
<p>早期的发展进程没有展示出的，是一个真正效用模型的充分程度和力量。当代很多零碎的效用服务以对传统数据中心重新打造的方式存在；个体公司必须将效用服务与他们过去的软件硬件联系起来。确实，很多公司不得不放弃极具吸引力的效用服务或是在外包过程中遇到很多问题，因为对传统系统的整合是非常困难的。只有在外包商满足公司所有的IT要求，包括数据处理、储存、应用时，真正的效用计算才能发生。效用模型要求的，是对传统上保留在零散内部数据中心的资产的所属权权被转移给效用提供商，并由他们加以巩固。</p>
<p>这个过程需要很多年才能完全展开，但是技术积木已经在开始累积搭建。三大进步——虚拟化、网格计算和 Web 服务尤为重要，尽管他们的重要性经常由于和他们联系在一起的晦涩术语被模糊化。这三大技术扮演的角色有点类似于早期的电流转换器，当然是以不同的表现形式呈现：他们使之前互不相容的部分构建、融合成一个大而紧密的系统。虚拟化技术消除了不同计算平台之间的差异，使应用程序可以在不同的操作系统中运行。网格计算允许大量的硬件部分，比如服务器和磁盘驱动有效的发挥作用，汇集它们的能力并自动分配去执行不同的任务。Web 服务将应用程序的互动标准化，将他们变成可轻易拆卸、组装的模块。</p>
<p>单个来看，每一种技术都非常有趣，但是将他们组合在一起是一件真正具有革命性的事情。利用高容量的光纤通信网络，人们可以将零散、笨重的一套硬、软件组件整合为一个单个、灵活性的基础设施，并且可以被无数家公司以不同的方式采用。随着某个系统服务的用户增多，这个系统的需求负荷也变得更平衡，它的产能利用率得以提高，规模经济也在扩大。考虑到技术的不断演变和进步也伴随着相关新兴技术的出现，将信息技术作为一种效用提供的能力只会不断提高，并且这么做所带来的经济刺激也会不断增长。</p>
<p><strong>效用计算的最大障碍并不是技术，而是态度。</strong>如同向集中电力的模式转变，最大的障碍在于传统操作、过去的投资、和以这两者为基础建立的根深蒂固的管理预设。大公司只有在信息技术效用的可靠性、稳定性和好处明确建立起来之后，才敢对他们的数据中心下手改革。为了让这样的变革发生，当代的 “塞缪尔英萨尔” 需要具备如何运营信息技术效用的清晰视野，同时还必须有使其发生的经济实力和想象力。就像他的前辈那样，这样的视野会打造出高效的、大规模的信息技术工厂，与成熟的计量和计价系统相结合，为不同客户提供优越灵活的、量身定做的全套服务。同时，他也会用极具说服力的营销方案向企业高管证明，集中化管理之前零散的资源不仅可以节约成本、解放资本，更可以提高安全性，加强灵活性和减少风险。简而言之，这个人将会创造一个产业。</p>
<h2 id="新产业的形状">新产业的形状</h2><p>新产业具体会以什么样子呈现还未可知，但是我们可以大概预见其轮廓。它将会有主要的三部分，最中心的部分是信息技术效用本身——大型企业将在中央系统中维护核心计算资源，并将它们输送给终端用户。效用模型的运作需要大批不同的部件提供商——电脑、储存、网络设备、操作和效用软件、应用程序等。最后，大型网络运营商将负责超大容量的数据线路。并且，肯定会有有能力的公司同时负责这些门类中一种以上的供应项目。</p>
<p>这种效用模型最激动人心之处在于它的独特——也正是这些独特让信息技术非常适合向效用服务发展。如果是电力技术，只有基本的发电功能可以集中化，因为它的应用是通过发电机物理性传送到电灯泡等电力设备的，也就是说他们必须用于用户本地供应。然而信息技术的应用是以软件为主要形式，可以由提供商远程操作。就算是为客户定制的应用也可以被安置在供应商处。终端用户只需要维护各种输入和输出设备，比如监控器、打印机、键盘、扫描仪、移动设备、传感器等需要用来接收、传送和操作数据，以及重新配置服务的相关仪器。尽管有些客户会倾向于本地运行程序，效用提供商还是可以拥有和操作大部分硬件和软件，放大他们的规模优势。</p>
<p>哪些公司会成为新兴的效用供应商？目前至少有四类可能。首先是致力于企业计算硬件的传统大型制造商，比如IBM, 惠普公司, 太阳微系统公司等。他们有非常丰富的设置、运营商业系统的经验，并且毫无意外的，他们已经开始非常积极的转向效用提供商的角色定位。太阳微系统公司不仅以单位计费出租处理储存容量，还在网上拍卖计算能力。第二类是专业性的托管运营商，比如休斯顿的VeriCenter和弗吉尼亚MCI的Digex服务，他们现在依然给中小型公司运营整体数据中心。这些在挣扎在网络泡沫崩溃后的专门性公司也开始模仿电气化早期原先作为中央发电站的运营商的做法。第三类是类似谷歌和亚马逊的因特网创新公司，他们建立的广泛成熟的计算网络理论上可以被调整以适应更多用途。最后一类是我们现在还不怎么了解的创业公司，他们有研发灵活策略的潜力。因为效用行业规模驱动和资本密集的特点，规模和重点对于成功来说非常关键。任何公司都难以做到保持领先的同时实现其他商业目标。</p>
<p><strong>目前看来，效用计算系统似乎符合哈佛商学院克莱顿克里斯滕森定义的颠覆式创新模式：首先占领低端市场，然后脱颖而出，最终成为占据主导地位的供应模式。</strong>因此，它有可能对现在很多大型部件提供商构成极大地危险，包括微软、戴尔、甲骨文、SAP 等通过对企业的世界销售大获成功的公司。效用模型将供应商与终端客户隔离，迫使他们向、或是通过大型集中效用的方式销售产品和服务，这也会带来更大的议价能力。大部分被广泛使用的部件，从电脑、操作系统到复杂的自动化业务流程的 “企业应用”，在未来都会作为便宜常见的商品而被购买。</p>
<p>当然，当下领先的部件供应商拥有庞大的市场能力和管理技能，他们也有时间根据效用模型的发展调整策略，有些可能会向前融入这种有过成功先例的效用模式。当厂商开始从购买电力时，两家最大的提供商，包括提供发电机和相关部件的通用电气和西屋电气当即买下很多电力公司的股份，大力扩大业务规模。早在 1895年，通用电气就在全美和欧洲投资了超过五千九百万美元的电力设施。</p>
<p>不过这样的先例也向我们警示了整合买卖双方行为的风险。美国的电力业务越来越被集中在少数公司手里，政府顾忌到垄断公司对这种关键性资源的掌控，因而对行业设置了更严格的限制。信息技术行业的组成部分更多样化，但是少数公司对基础设施的独断控制的可能性也是存在的。垄断不仅会导致对终端用户的高额收费，也会减缓创新速度，带来其他各种危害。可见，保持一种提供商和效用商之间的良性竞争对于未来数年健康、繁荣的信息基础产业是至关重要的。</p>
<h2 id="从未来回望">从未来回望</h2><p>任何对于未来的预测，尤其是涉及到科技进步速度和方向的预测，都具有投机性，我们现在面对的状况也不例外。然而，如果说技术进步总是无法预测的，那么经济和市场能力总是以一种有规律且有一致性的方式引导商业发展。商业的历史告诉我们，重复投资和分散能力对集中供应提供了强有力的刺激。计算能力和网络进步也允许信息技术以一种愈发“虚拟化”的方式发展，而基础技术资产和用户获取、转译和处理信息点的距离也可以越来越远。考虑到这种发展趋势，信息技术企业激进的变革将不可避免。</p>
<p>有时，最大的产业变革似乎让人不可思议，即使它确确实实在发生。现在当我们回望过去的电力行业，我们看到的是一段以清晰、明确的逻辑所展开的演变过程。不难辨别，个体公司修建和维护专有发电厂的行为是一种过渡性现象，一种人为的必须，并没有太大经济意义。从当下的立场来看，电力的效用化是必然结果。现在看上去毫无疑问的事情对于当时的工厂厂主、管理人员来说都是非常牵强、甚至可笑荒唐的，因为对于他们来说，维护独立电能是已经延续了数十年的传统做法。</p>
<p>想象一下，未来的人在回望一百年之后、现在的我们，他们会看到什么？难道独立数据中心不也正是一种过渡性现象吗？——和当年的独立发电厂一样的一种权宜之计。难道信息技术效用的发展不正是一种自然、必然的趋势吗？并且，难道现在的企业计算方式本质上来说不正是毫无逻辑却又注定如此吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>作者：尼古拉斯·卡尔</em><br><em>翻译：黄思路</em><br><em>文章来源：《斯隆管理评论》</em></p>
<p><em>这是在36kr上看到的一篇文章，对于文中有关信息技术发展的理解感触颇深，于是kiang到了这里(<a href="http://36kr.com/p/5041175.html">原文</a>)。</em></p>
<blockquote>
<p>花费数百万美元打造内部数据中心后，企业往往会发现面临着快速淘汰这些数据库的窘境。IT 正从一种企业资产转变为一种服务购买。</p>
</blockquote>
<p>20 世纪早期，有一些之前的几十年里无法想象的事情陆续发生：制造厂商开始关闭、拆除水轮设备、蒸汽机和发电机。要知道，从工业时代开始，电力就是任何产业得以运作的必要前提，工厂作坊除了维持独立发电站来使运作机器以外别无选择。新世纪的到来带来了一种新的可能，许多新兴发电商开始通过建立中央电厂和使用电网给远距离外的客户输送电能。制造商本身不需要再维持独立发电站的运营，他们可以从这些新兴发电商那里购买需要的用电。</p>
<p>几乎过了整整一个世纪后，历史再次重演。过去50年中最重要的一项商业成就——信息技术——正在经历类似的转变。信息技术曾以电脑、软件和其他各式各样的形式作为公司的一种资产，而现在，它正在转化为一种从效用供应商那里购买的服务。商业界很少有公司真正意识到这个转变的重大意义和深远影响。至今，关于效应计算的讨论也仅仅是停留在信息技术供应商的市场标语里，如同那些含义模糊的各类名词，“自动系统”、“服务及虚拟化”、“服务型架构” 等等。其实这些充满官腔的言词不仅没有着向大众照亮这一转变的未来，更使人们对于它的理解变得非常模糊。<br>]]>
    
    </summary>
    
      <category term="IT" scheme="http://leotse90.com/tags/IT/"/>
    
      <category term="互联网" scheme="http://leotse90.com/categories/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES之当你更新Document，你在更新些什么？]]></title>
    <link href="http://leotse90.com/2015/11/24/ES%E4%B9%8B%E5%BD%93%E4%BD%A0%E6%9B%B4%E6%96%B0Document%E4%BD%A0%E5%9C%A8%E6%9B%B4%E6%96%B0%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <id>http://leotse90.com/2015/11/24/ES之当你更新Document你在更新些什么/</id>
    <published>2015-11-24T14:59:13.000Z</published>
    <updated>2015-11-25T00:10:48.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="怎么更新ElasticSearch中的Document？">怎么更新ElasticSearch中的Document？</h2><p>在ES中更新数据的场景有很多，比如我们要修改一个用户的年龄、爱好，又或者我们需要实时同步MySQL中的数据到ES中。我们都有修改已经存在的Document的需求。ES本身提供了两种方法让我们修改一个Document的数据，我们假设我们想要修改的内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="built_in">test</span>/customer/<span class="number">1</span>/_<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想将yolovon女神的年龄修改到真实年龄18岁。我们可以进行以下两种方法：<br>1.使用PUT，就像我们插入数据时那样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/customer/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_index"</span>: <span class="string">"test"</span>,</span><br><span class="line">   <span class="string">"_type"</span>: <span class="string">"customer"</span>,</span><br><span class="line">   <span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这里需要注意的是，我们必须将所有的字段全部输入一次，如果你只在PUT的body里输入我们要更新的字段（比如在这里我们只传入age的值），那么新的Document的就会变成我们后面PUT进去的样子（即只有age一个字段）。<br>另外，我们可以看到这里的返回信息有用以标示该document唯一性的<code>_index</code>，<code>_type</code>，<code>_id</code>，以及<code>_version</code>表明该document的更新版本，<code>created</code>表明这个不是新建的而是已经存在的document。</p>
<p>2.使用POST，update模式更新Document：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test/customer/<span class="number">1</span>/_<span class="keyword">update</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"doc"</span>: &#123;</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会看到这样的结果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">   "<span class="attribute">_type</span>": <span class="value"><span class="string">"customer"</span></span>,</span><br><span class="line">   "<span class="attribute">_id</span>": <span class="value"><span class="string">"1"</span></span>,</span><br><span class="line">   "<span class="attribute">_version</span>": <span class="value"><span class="number">3</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候，我们的document也变为了：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">name</span>": <span class="value"><span class="string">"yolovon"</span></span>,</span><br><span class="line">   "<span class="attribute">age</span>": <span class="value"><span class="number">20</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>age</code>已经变成了20。而且在这里，我们只针对需要修改的<code>age</code>字段进行操作，而其他字段并不需要关心。</p>
<h2 id="更新操作都干了些什么？">更新操作都干了些什么？</h2><p>那么，在更新的时候到底发生了什么？上面的两种更新策略又有什么区别？  </p>
<p>我们知道，在Elasticsearch中，document是不可变的。  </p>
<blockquote>
<p>Documents in Elasticsearch are immutable; we cannot change them. Instead, if we need to update an existing document, we reindex or replace it.</p>
</blockquote>
<p>这样一来，我们在更新Document时到底是怎么实现的？  </p>
<p><strong>在ES中，不管我们用以上哪种方式进行更新document，它都不是真正地对原来的document进行操作。而是先将原来的document标记为删除状态，然后重新新增一个document（也就是我们看到的新的document），实际上，原来的document并没有立即消失，只是你已经不能访问它了，ES稍后会在后台真正地删除原来的document。</strong></p>
<p>不管我们用那种方式进行更新，ES都会按照以下的步骤进行更新：</p>
<blockquote>
<p>1.查询出旧的document；<br>2.修改document中的字段；<br>3.删除旧的document；<br>4.重新索引一个新的document。</p>
</blockquote>
<p>但是两者还是有区别的，当使用<code>PUT</code>一个完整的document时，它需要请求两次，一次<code>get</code>请求和一次<code>index</code>请求，而使用<code>POST</code>进行<code>_update</code>操作的时候只需要一次<code>_udpate</code>请求即可。</p>
<p>因此我们在使用的时候，尽量避免使用<code>PUT</code>进行document的更新，特别是当我们需要批量地修改ES数据时。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="怎么更新ElasticSearch中的Document？">怎么更新ElasticSearch中的Document？</h2><p>在ES中更新数据的场景有很多，比如我们要修改一个用户的年龄、爱好，又或者我们需要实时同步MySQL中的数据到ES中。我们都有修改已经存在的Document的需求。ES本身提供了两种方法让我们修改一个Document的数据，我们假设我们想要修改的内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="built_in">test</span>/customer/<span class="number">1</span>/_<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想将yolovon女神的年龄修改到真实年龄18岁。我们可以进行以下两种方法：<br>1.使用PUT，就像我们插入数据时那样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/customer/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_index"</span>: <span class="string">"test"</span>,</span><br><span class="line">   <span class="string">"_type"</span>: <span class="string">"customer"</span>,</span><br><span class="line">   <span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ElasticSearch与MySQL数据同步]]></title>
    <link href="http://leotse90.com/2015/11/11/ElasticSearch%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://leotse90.com/2015/11/11/ElasticSearch与MySQL数据同步以及修改表结构/</id>
    <published>2015-11-11T14:12:23.000Z</published>
    <updated>2015-11-12T00:31:38.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES与MySQL的数据同步">ES与MySQL的数据同步</h2><p>如果你需要进行ES与MySQL的数据同步，亦即将MySQL中的数据导入到ES中，并保持同步，一般来看，有以下几种方法：<br>1.自己动手写一个同步的模块。实时tail处理MySQL的binlog，将数据库的新增、修改或删除这些操作同步在ES上执行。这种方案可行，但是实现起来代价大；</p>
<p>2.<a href="https://github.com/siddontang/go-mysql-elasticsearch" target="_blank" rel="external">go-mysql-elasticsearch</a>。这是Git上的一个开源项目，差不多是第一种方案的一个实现版本。这个插件支持实时同步MySQL与ES的新增、修改以及删除操作。但是缺点是使用起来不够灵活，它的作者给出了它的以下缺点：</p>
<blockquote>
<p>-binlog row image must be full for MySQL, you may lost some field data if you update PK data in MySQL with minimal or noblob binlog row image. MariaDB only supports full row image.<br>-Can not alter table format at runtime.<br>-<code>mysqldump</code> must exist in the same node with go-mysql-elasticsearch, if not, go-mysql-elasticsearch will try to sync binlog only.  </p>
</blockquote>
<a id="more"></a>
<p>这三点比较重要的缺点影响我使用这种方案，特别是不能运行时修改表结构。对于很多在线业务来说是比较难以接受的。</p>
<p>3.<a href="https://github.com/jprante/elasticsearch-jdbc" target="_blank" rel="external">elasticsearch-river-jdbc</a>。这种方案是1、2的结合体。可以较为灵活地进行数据同步，比如可以在同步的时候指定需要同步的字段以及筛选条件。这也是比较流行的解决方案，但是它也有一个比较致命的缺点，那就是删除操作不能同步（物理删除）！</p>
<p>如果你的系统对删除操作频繁，而且都是物理删除，并且能接受不能运行时修改表结构等条件，那么使用go-mysql-elasticsearch将是非常不错的选择；如果你的表结构改变得相对频繁，而且不用对表进行物理删除（比如用逻辑删除取而代之），那么你可以选择elasticsearch-river-jdbc。如果你对这两者都不满意，而且觉得自己的编码能力还不错，那么完全可以自己定制一个满足自己需求的插件。</p>
<h2 id="elasticsearch-river-jdbc使用">elasticsearch-river-jdbc使用</h2><p>我们这里选择使用elasticsearch-river-jdbc作为我们同步ES与MySQL的插件。我们这里简单介绍一下elasticsearch-river-jdbc的安装与使用：<br>1.确保ES的集群的每个Node都能访问MySQL数据库；  </p>
<p>2.安装River：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;./bin/plugin --install river-jdbc --url  <span class="symbol">http:</span>/<span class="regexp">/xbib.org/repository</span><span class="regexp">/org/xbib</span><span class="regexp">/elasticsearch/plugin</span><span class="regexp">/elasticsearch-river-jdbc/</span><span class="number">1.5</span>.<span class="number">0.5</span>/elasticsearch-river-jdbc-<span class="number">1.5</span>.<span class="number">0.5</span>-plugin.zip</span><br></pre></td></tr></table></figure></p>
<p>3.下载mysql-connector-java-5.1.30-bin.jar并将其保存在{$ES_HOME}/plugins/jdbc/目录下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="symbol">http:</span>/<span class="regexp">/cdn.mysql.com/</span><span class="regexp">/Downloads/</span><span class="constant">Connector</span>-<span class="constant">J</span>/mysql-connector-java-<span class="number">5.1</span>.<span class="number">37</span>.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>如果是ES集群，你需要在每一个Node上执行这一步。</p>
<p>4.创建一个JDBC river<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;curl -XPUT <span class="string">'localhost:9200/_river/my_jdbc_river/_meta'</span> -d <span class="string">'&#123;</span><br><span class="line">     "</span>type<span class="string">" : "</span>jdbc<span class="string">",</span><br><span class="line">     "</span>jdbc<span class="string">" : &#123;</span><br><span class="line">         "</span>driver<span class="string">" : "</span><span class="transposed_variable">com.</span><span class="transposed_variable">mysql.</span><span class="transposed_variable">jdbc.</span>Driver<span class="string">",</span><br><span class="line">         "</span>url<span class="string">" : "</span>jdbc:mysql:<span class="comment">//localhost:3306/test",</span></span><br><span class="line">         <span class="string">"user"</span> : <span class="string">"root"</span>,</span><br><span class="line">         <span class="string">"password"</span> : <span class="string">"123456"</span>,</span><br><span class="line">         <span class="string">"sql"</span> : <span class="string">"select * from test.student;"</span>,</span><br><span class="line">         <span class="string">"interval"</span> : <span class="string">"30"</span>,</span><br><span class="line">         <span class="string">"index"</span> : <span class="string">"test"</span>,</span><br><span class="line">         <span class="string">"type"</span> : <span class="string">"student"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;’</span><br></pre></td></tr></table></figure></p>
<p> 5.你可以查看ES是否已经同步了这些数据：<br> <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -XGET <span class="comment">'localhost:9200/test/student/_search?pretty&amp;q=*'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改表结构后的数据同步">修改表结构后的数据同步</h2><p>如果你需要修改正在与ES进行数据同步的表的结构，你有以下三种方案（亲测可行）：<br><strong>方案一</strong>：创建JDBC river的时候使用sql语句：<code>select * from table_name;</code><br>乍一看，这种方法很坑。但是确实适合那些喜欢简单粗暴的coder。但是这种方案的场景比较苛刻：   </p>
<blockquote>
<p>MySQL中表在创建时id命名为_id，这是因为_id是ES中每一条document的唯一标识；如果不这样干，你会发现每一次同步ES的type中都会增加MySQL表中条目数个Document；<br>MySQL表所有的字段对ES都是有效的、必要的；</p>
</blockquote>
<p><strong>方案二</strong>.方案一的改进版，使用sql语句：<code>select *, id as _id from table_name;</code><br>这个方案在你需要在ES中存储MySQL中表所有字段的时候变得比较有效。</p>
<p><strong>方案三</strong>：使用elasticsearch的alias。具体的操作比较简单，可以参照<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html" target="_blank" rel="external">官网的介绍</a>。</p>
<p>前两种方案有点取巧，第三种方案才是正道。</p>
<p>如果你愿意，完全建议自己定制一套解决方案。由于业务需要，本人最近也在开始写这样的插件。我会在这个博客里保持更新。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES与MySQL的数据同步">ES与MySQL的数据同步</h2><p>如果你需要进行ES与MySQL的数据同步，亦即将MySQL中的数据导入到ES中，并保持同步，一般来看，有以下几种方法：<br>1.自己动手写一个同步的模块。实时tail处理MySQL的binlog，将数据库的新增、修改或删除这些操作同步在ES上执行。这种方案可行，但是实现起来代价大；</p>
<p>2.<a href="https://github.com/siddontang/go-mysql-elasticsearch">go-mysql-elasticsearch</a>。这是Git上的一个开源项目，差不多是第一种方案的一个实现版本。这个插件支持实时同步MySQL与ES的新增、修改以及删除操作。但是缺点是使用起来不够灵活，它的作者给出了它的以下缺点：</p>
<blockquote>
<p>-binlog row image must be full for MySQL, you may lost some field data if you update PK data in MySQL with minimal or noblob binlog row image. MariaDB only supports full row image.<br>-Can not alter table format at runtime.<br>-<code>mysqldump</code> must exist in the same node with go-mysql-elasticsearch, if not, go-mysql-elasticsearch will try to sync binlog only.  </p>
</blockquote>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="MySQL" scheme="http://leotse90.com/tags/MySQL/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES查询－match VS match_phrase]]></title>
    <link href="http://leotse90.com/2015/11/10/ElasticSearch-match-VS-match-phrase/"/>
    <id>http://leotse90.com/2015/11/10/ElasticSearch-match-VS-match-phrase/</id>
    <published>2015-11-09T16:05:35.000Z</published>
    <updated>2015-11-09T16:18:09.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="match_VS_match_phrase">match VS match_phrase</h2><p>我们以一个查询的示例开始，我们在student这个type中存储了一些学生的基本信息，我们分别使用match和match_phrase进行查询。<br>首先，使用match进行检索，关键字是“He is”：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"He is"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行这条查询，得到的结果如下：<a id="more"></a><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">took</span>": <span class="value"><span class="number">3</span></span>,</span><br><span class="line">   "<span class="attribute">timed_out</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">   "<span class="attribute">_shards</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">successful</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">failed</span>": <span class="value"><span class="number">0</span></span><br><span class="line">   </span>&#125;</span>,</span><br><span class="line">   "<span class="attribute">hits</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">4</span></span>,</span><br><span class="line">      "<span class="attribute">max_score</span>": <span class="value"><span class="number">0.2169777</span></span>,</span><br><span class="line">      "<span class="attribute">hits</span>": <span class="value">[</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"2"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.2169777</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"februus"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">24</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is passionate."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, programing"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"1"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.16273327</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"leotse"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">25</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is a big data engineer."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, swiming, hiking"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"4"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.01989093</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"pascal"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">25</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He works very hard because he wanna go to Canada."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"programing, reading"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"3"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.016878016</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"yolovon"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"female"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">24</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"She is so charming and beautiful."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, shopping"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;</span><br><span class="line">      ]</span><br><span class="line">   </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>而当你执行match_phrase时：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"He is"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">took</span>": <span class="value"><span class="number">3</span></span>,</span><br><span class="line">   "<span class="attribute">timed_out</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">   "<span class="attribute">_shards</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">successful</span>": <span class="value"><span class="number">5</span></span>,</span><br><span class="line">      "<span class="attribute">failed</span>": <span class="value"><span class="number">0</span></span><br><span class="line">   </span>&#125;</span>,</span><br><span class="line">   "<span class="attribute">hits</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">total</span>": <span class="value"><span class="number">2</span></span>,</span><br><span class="line">      "<span class="attribute">max_score</span>": <span class="value"><span class="number">0.30685282</span></span>,</span><br><span class="line">      "<span class="attribute">hits</span>": <span class="value">[</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"2"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.30685282</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"februus"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">24</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is passionate."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, programing"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">            "<span class="attribute">_type</span>": <span class="value"><span class="string">"student"</span></span>,</span><br><span class="line">            "<span class="attribute">_id</span>": <span class="value"><span class="string">"1"</span></span>,</span><br><span class="line">            "<span class="attribute">_score</span>": <span class="value"><span class="number">0.23013961</span></span>,</span><br><span class="line">            "<span class="attribute">_source</span>": <span class="value">&#123;</span><br><span class="line">               "<span class="attribute">name</span>": <span class="value"><span class="string">"leotse"</span></span>,</span><br><span class="line">               "<span class="attribute">sex</span>": <span class="value"><span class="string">"male"</span></span>,</span><br><span class="line">               "<span class="attribute">age</span>": <span class="value"><span class="number">25</span></span>,</span><br><span class="line">               "<span class="attribute">description</span>": <span class="value"><span class="string">"He is a big data engineer."</span></span>,</span><br><span class="line">               "<span class="attribute">interests</span>": <span class="value"><span class="string">"reading, swiming, hiking"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">         </span>&#125;</span><br><span class="line">      ]</span><br><span class="line">   </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>占的篇幅有点长，但是如果能基于此看清这两者之间的区别，那也是值得的。</p>
<p>我们分析一下这两者结果的差别：  </p>
<blockquote>
<p>1.非常直观的一点，对于同一个数据集，两者检索出来的结果集数量不一样；<br>2.对于match的结果，我们可以可以看到，结果的Document中description这个field可以包含“He is”，“He”或者“is”；<br>3.match_phrased的结果中的description字段，必须包含“He is”这一个词组；<br>4.所有的检索结果都有一个_score字段，看起来是当前这个document在当前搜索条件下的评分，而检索结果也是按照这个得分从高到低进行排序。  </p>
</blockquote>
<p>我们要想弄清楚match和match_phrase的区别，要先回到他们的用途：match是全文搜索，也就是说这里的搜索条件是针对这个字段的全文，只要发现和搜索条件相关的Document，都会出现在最终的结果集中，事实上，ES会根据结果相关性评分来对结果集进行排序，这个相关性评分也就是我们看到的_score字段；总体上看，description中出现了“He is”的Document的相关性评分高于只出现“He”或“is”的Document。（至于怎么给每一个Document评分，我们会在以后介绍）。</p>
<blockquote>
<p>相关性(relevance)的概念在Elasticsearch中非常重要，而这个概念在传统关系型数据库中是不可想象的，因为传统数据库对记录的查询只有匹配或者不匹配。</p>
</blockquote>
<p>那么，如果我们不想将我们的查询条件拆分，应该怎么办呢？这时候我们就可以使用match_phrase：<br>match_phrase是短语搜索，亦即它会将给定的短语（phrase）当成一个完整的查询条件。当使用match_phrase进行搜索的时候，你的结果集中，所有的Document都必须包含你指定的查询词组，在这里是“He is”。这看起来有点像关系型数据库的like查询操作。</p>
<h2 id="相关性评分的相关知识">相关性评分的相关知识</h2><p>相信到这里，我们都能比较清楚的理解这两者的区别。但是我们还有一个问题没有弄清楚，那就是_score到底是怎么得出的？为什么同样包含了“He is”这个phrase，_id为2的Document得分为0.30685282，而_id为1的Document的得分为0.23013961？</p>
<p>查询语句会为每个Document计算一个相关性评分_score，评分的计算方式取决于不同的查询类型。ES的相似度算法为TF/IDF（检索词频率/反向文档频率）。我们在这里顺带介绍一下TF/IDF的几个相关概念：</p>
<p>1.<strong>字段长度准则</strong>：这个准则很简单，字段内容的长度越长，相关性越低。我们在上面的两个例子中都能看到，同样包含了“He is”这个关键字，但是”He is passionate.”的相关性评分高于”He is a big data engineer.”，这就是因为字段长度准则影响了它们的相关性评分；</p>
<p>2.<strong>检索词频率准则</strong>：检索关键字出现频率越高，相关性也越高。这个例子中没有比较明显的体现出来，你可以自己试验一下；</p>
<p>3.<strong>反向Document频率准则</strong>：每个检索关键字在Index中出现的频率越高，相关性越低。</p>
<p>一般的，我们理解了以上三个准则，就能了解ES的相关性评分的基本守则。以下是一些相关性评分的Tips：</p>
<blockquote>
<p>单个查询可以使用TF/IDF评分标准或其他方式。<br>如果多条查询子句被合并为一条复合查询语句，那么每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
</blockquote>
<p>因为“相关性评分”这个概念和这篇博文的“相关性评分”并不高，因此在此就不展开讨论，只是点到为止，如果想要了解更多有关ES相关性评分的内容，可以自行Google，也可以继续关注我的博客，以后会专门探讨这一块内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="match_VS_match_phrase">match VS match_phrase</h2><p>我们以一个查询的示例开始，我们在student这个type中存储了一些学生的基本信息，我们分别使用match和match_phrase进行查询。<br>首先，使用match进行检索，关键字是“He is”：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"description"</span>: <span class="string">"He is"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行这条查询，得到的结果如下：]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】避免使用GroupByKey]]></title>
    <link href="http://leotse90.com/2015/11/04/%E3%80%90%E8%AF%91%E3%80%91%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8GroupByKey/"/>
    <id>http://leotse90.com/2015/11/04/【译】避免使用GroupByKey/</id>
    <published>2015-11-04T11:37:15.000Z</published>
    <updated>2015-11-04T11:42:25.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>原文：<a href="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/best_practices/prefer_reducebykey_over_groupbykey.html" target="_blank" rel="external">Avoid GroupByKey</a></p>
<h3 id="译文">译文</h3><p>让我们来看两个wordcount的例子，一个使用了<code>reduceByKey</code>，而另一个使用<code>groupByKey</code>:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">words</span> =</span> <span class="type">Array</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordPairsRDD</span> =</span> sc.parallelize(words).map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithReduce</span> =</span> wordPairsRDD</span><br><span class="line">                           .reduceByKey(_ + _)</span><br><span class="line">                           .collect()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithGroup</span> =</span> wordPairsRDD</span><br><span class="line">                          .groupByKey()</span><br><span class="line">                          .map(t =&gt; (t._1, t._2.sum))</span><br><span class="line">                          .collect()</span><br></pre></td></tr></table></figure></p>
<p>上面两个函数所得到的结果都是正确的，但是当数据集很大时，使用了<code>reduceByKey</code>的例子表现更佳。这是因为在shuffle输出的数据前，Spark会Combine每一个partition上具有相同key的输出结果。<br><a id="more"></a><br>看下图我们就能理解<code>reduceByKey</code>的工作流程。我们注意到同一台机器上数据shuffle之前，相同key的数据（通过调用传入<code>reduceByKey</code>的lambda函数）Combine在一起的，然后再一次调用这个lambda函数去reduce来自各个partition的全部值，从而得到最终的结果。  </p>
<p><img src="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/images/reduce_by.png" alt="ReduceByKey"></p>
<p>另一方面，当调用<code>groupByKey</code>的时候，所有的键值对都会进行shuffle，这将增加很多无谓的数据进行网络传输。</p>
<p>为了确定哪台机器将接受Shuffle后的键值对，Spark会针对该键值对数据的key调用一个分区函数。当某一台executor机器上的内存不足以保存过多的Shuffle后数据时，Spark就会溢写数据到磁盘上。然而，这种溢写磁盘会一次性将一个key的全部键值对数据写入磁盘，因此如果一个key拥有过多键值对数据——多到内存放不下时，将会抛出Out Of Memory异常。在之后发布的Spark中将会更加优雅地处理这种情况，使得这个job仍会继续运行，但是我们仍然需要避免（使用<code>groupByKey</code>）。<strong>当Spark需要溢写磁盘的时候，它的性能将受到严重影响</strong>。</p>
<p><img src="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/images/group_by.png" alt="GroupByKey"></p>
<p>如果你有一个非常大的数据集，那么<code>reduceByKey</code>和<code>groupByKey</code>进行shuffle的数据量之间的差异将会更加夸张。</p>
<p>下面是一些你可以用来替代<code>groupByKey</code>的函数：<br>1）当你在combine数据但是返回的数据类型因输入值的类型而异时，你可以使用<code>combineByKey</code>；<br>2）如果key使用到结合函数和“零值”，你可以用<code>foldByKey</code>函数合并value；</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>原文：<a href="http://databricks.gitbooks.io/databricks-spark-knowledge-base/content/best_practices/prefer_reducebykey_over_groupbykey.html">Avoid GroupByKey</a></p>
<h3 id="译文">译文</h3><p>让我们来看两个wordcount的例子，一个使用了<code>reduceByKey</code>，而另一个使用<code>groupByKey</code>:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">words</span> =</span> <span class="type">Array</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordPairsRDD</span> =</span> sc.parallelize(words).map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithReduce</span> =</span> wordPairsRDD</span><br><span class="line">                           .reduceByKey(_ + _)</span><br><span class="line">                           .collect()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">wordCountsWithGroup</span> =</span> wordPairsRDD</span><br><span class="line">                          .groupByKey()</span><br><span class="line">                          .map(t =&gt; (t._1, t._2.sum))</span><br><span class="line">                          .collect()</span><br></pre></td></tr></table></figure></p>
<p>上面两个函数所得到的结果都是正确的，但是当数据集很大时，使用了<code>reduceByKey</code>的例子表现更佳。这是因为在shuffle输出的数据前，Spark会Combine每一个partition上具有相同key的输出结果。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="Spark" scheme="http://leotse90.com/tags/Spark/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ElasticSearch初探]]></title>
    <link href="http://leotse90.com/2015/11/01/ElasticSearch%E5%88%9D%E6%8E%A2/"/>
    <id>http://leotse90.com/2015/11/01/ElasticSearch初探/</id>
    <published>2015-11-01T14:05:15.000Z</published>
    <updated>2015-11-01T14:29:49.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES介绍">ES介绍</h2><p>我们首先来看<a href="https://www.elastic.co" target="_blank" rel="external">ES</a>（全称是Elastic Search）到底是什么，下面是Wikipedia给出的定义：</p>
<blockquote>
<p>Elasticsearch is a search server based on Lucene. It provides a distributed, multitenant-capable full-text search engine with a RESTful web interface and schema-free JSON documents. Elasticsearch is developed in Java and is released as open source under the terms of the Apache License. Elasticsearch is the second most popular enterprise search engine after Apache Solr.</p>
</blockquote>
<p>百度上给出了中文版定义：</p>
<blockquote>
<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是第二流行的企业搜索引擎。</p>
</blockquote>
<p>在这段定义之外，我们看看ES还有哪些吸引人的地方：<br><a id="more"></a><br>1）ES的搜索几乎是实时的，当你向一个ES服务器或者一个ES集群发出搜索请求后，你可以在非常短的延迟后获取到你想要的数据（不超过1s）；<br>2）ES的集群是去中心化的，也就是说，不像Hadoop这种分布式框架，ES集群不存在单点故障。ES集群中包含多个节点，节点可以通过选举选出它们的中心节点，因此，当集群中的一个节点出现故障时，集群马上会选取出下一个新的中心节点来管理集群；<br>3）ES的横向扩展性能非常好，集群维护者不用担心集群出现资源不够的情况，因为你只需要增加一台服务器，然后在其上安装ES然后简单进行配置，这台新的节点就能成为集群中的一员；<br>4）ES提供了分片机制（Shard），一个索引（Index）可以划分为多个Shard，这些Shard分布在集群中不同的节点上，能有效提升集群的处理效率；<br>5）ES为其中的数据提供了replica，确保数据的冗余存储，从而使得整个ES集群可用性大大增强，亦即当一个节点出现故障时，存储在其上的数据仍然可以在其他的节点上访问到；<br>6）ES简单易用，除了为开发者和使用者提供了RESTful接口外，ES本身非常易于学习和使用，这一点在应用中你可以感受到。它的社区也十分活跃，相关的文档资料也较健全。</p>
<p>这些点足以让我们拥有信心在需要的时候投入ES的怀抱，当然我们还需要考虑ES的一些不足，在本人的了解范围里以及结合本人的使用经验，ES集群可能存在以下问题：  </p>
<p><strong>脑裂问题</strong>：ES集群有可能在节点间网络通信故障时成为“裂脑人”。这是ES集群的去中心化带来的不足。我们假设这样一个场景，我们的ES集群有10个节点，它们分别在两个机房A和B，有一天机房的网络出现问题，A机房无法与B机房进行通信，这时候，ES的选举机制会被触发，A机房会选取出一个中心节点，B机房也会选取出一个中心节点，整个集群一分为二，虽然对外提供访问时仍然问题不大，但是这两个集群会出现数据不同步的问题；  </p>
<p><strong>权限管理机制不健全</strong>：迄今为止，ES集群没有比较健全的权限管理机制，如果你需要对ES的访问和使用权限进行管理，或者你需要为ES集群提供一个前端web服务，那么你需要在后台自行实现一个权限管理机制。</p>
<h2 id="ES相关概念">ES相关概念</h2><p>我们这里只介绍ES的一些相关的术语，在此之前，我们结合关系型数据库来简单介绍一下ES的结构：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Relational DB <span class="subst">-&gt; </span>Databases <span class="subst">-&gt; </span>Tables <span class="subst">-&gt; </span><span class="keyword">Rows</span> <span class="subst">-&gt; </span>Columns</span><br><span class="line">Elasticsearch <span class="subst">-&gt; </span>Indices   <span class="subst">-&gt; </span>Types  <span class="subst">-&gt; </span>Documents <span class="subst">-&gt; </span>Fields</span><br></pre></td></tr></table></figure></p>
<p>理解ES的结构本身不难，但是由于ES的这些术语在我们的圈子里已经有一些其他的受众较广的含义，所以这样一种与RDB的对比可以帮助我们理解ES的结构，ES本身可以想象成一个MySQL，ES中的Index就是数据库DB，而Type相当于数据库中的表，以此类推。</p>
<p><strong>索引Index</strong>:在ES中，Document中的所有字段都会建立索引（这里的索引是我们平常所理解的意思，如数据库的索引），这种设定使得ES中的每个文档的每个字段都是可以直接用来搜索的。事实上，我们的数据被存储和索引在分片中，索引只是一个把一个或多个分片分组在一起的逻辑空间。</p>
<p><strong>分片Shard</strong>:我们可以将ES中的分片Shard理解为HDFS中的文件块Block，一个完整的Index可以划分为多个Shard，然后分别存储在不同的节点上；</p>
<p><strong>类型Type</strong>:我们能够自己定义ES中的Type，Type是Index的一个逻辑分区，每个类型都有自己的映射或者结构定义，就像传统数据库表中的列一样；</p>
<p><strong>文档Document</strong>:如果你的Tool Kit中有OOP，那么你可以简单将Document理解为对象Object，它是ES中可被索引的基础信息单元；Type是序列化为JSON格式的数据。</p>
<p><strong>映射Mapping</strong>:ES中的映射相当于数据库中表的定义，映射定义了字段类型，每个字段的数据类型，以及字段被ES处理的方式。映射还用于设置关联到类型上的元数据。</p>
<p>这里只简单介绍了ES相关的基础信息，万里长征这才是第一步，但是希望这些信息可以让我们对ES有一个比较清晰的理解，至于如何使用ES进行存储数据、查询数据以及分析数据，我们需要在实践上不断学习和参悟。</p>
<p>最后推荐一本书，希望能帮助到各位学习和理解ES：<a href="http://es.xiaoleilu.com/index.html" target="_blank" rel="external">Elasticsearch 权威指南</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES介绍">ES介绍</h2><p>我们首先来看<a href="https://www.elastic.co">ES</a>（全称是Elastic Search）到底是什么，下面是Wikipedia给出的定义：</p>
<blockquote>
<p>Elasticsearch is a search server based on Lucene. It provides a distributed, multitenant-capable full-text search engine with a RESTful web interface and schema-free JSON documents. Elasticsearch is developed in Java and is released as open source under the terms of the Apache License. Elasticsearch is the second most popular enterprise search engine after Apache Solr.</p>
</blockquote>
<p>百度上给出了中文版定义：</p>
<blockquote>
<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是第二流行的企业搜索引擎。</p>
</blockquote>
<p>在这段定义之外，我们看看ES还有哪些吸引人的地方：<br>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之数组]]></title>
    <link href="http://leotse90.com/2015/10/26/Scala%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://leotse90.com/2015/10/26/Scala学习之数组/</id>
    <published>2015-10-26T13:10:22.000Z</published>
    <updated>2015-11-01T11:32:51.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>我们从这里开始接触Scala中的数据结构，我们首先来看最基础却非常有用的数据结构——数组。<br>这里会涉及两种数组：定长数组以及可变数组，顾名思义，定长数组就是数组在声明的时候就固定了大小，而可变数组可以根据我们使用的实际情况进行调整数组的长度。在Scala中，定长数组为Array，而可变数组为ArrayBuffer。</p>
<h2 id="定长数组">定长数组</h2><p>我们先来看定长数组。声明一个定长数组有以下两种方式：<br><strong>1.声明数组的类型与长度</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr1</span> =</span> <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">arr1: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们用<code>new</code>关键字来声明一个Array对象，用来存储4个Int类型的数值，而这4个Int类型的数值初始值都为0。想必这点大家都很容易理解，类似的，String类型的初始值为null，Double类型的初始值为0.0。<br><a id="more"></a><br><strong>2.声明数组时直接提供初始值</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr2</span> =</span> <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">arr2: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr3</span> =</span> <span class="type">Array</span>(<span class="number">2</span>, <span class="string">"hello"</span>)</span><br><span class="line">arr3: <span class="type">Array</span>[<span class="type">Any</span>] = <span class="type">Array</span>(<span class="number">2</span>, hello)</span><br></pre></td></tr></table></figure></p>
<p>我们在这种声明方式中，无需使用<code>new</code>关键字，Scala会根据初始值的类型来推断出数组的类型，当数组存在多种类型时，此时数组的类型为这多种类型的最近公共父类。</p>
<p>另外，我们在这里还可以注意到，我们在声明数组的时候使用了关键字<code>val</code>，即数组为常量，但是实际上，这里的数组元素都是可以改变值的。这时候，我们可以将<code>val</code>定义的数组理解为：我们用<code>val</code>来指定arr1这个容器只能用来存储4个Int类型的数字，多了不行，其他类型的也不行，但是这4个Int类型的数字究竟是什么，声明方表示并不关心。</p>
<p>我们用<code>(location)</code>来访问数组中的元素。并且可以直接赋值给数组中的元素：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; arr2(<span class="number">0</span>)</span><br><span class="line">res12: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; arr2(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scala&gt; arr2</span><br><span class="line">res14: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="可变数组">可变数组</h2><p>有时候，我们在一开始声明的时候只知道我们需要数组这种容器，但是具体要放多少数据我们暂且不知道，这时候我们需要用到可变数组（又称为数组缓冲）ArrayBuffer。ArrayBuffer的声明和Array并没有太大的差异。<br>不过，在实际使用ArrayBuffer前，需要导入相关的包依赖：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br></pre></td></tr></table></figure></p>
<p>下面我们来看ArrayBuffer的声明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arrbuf1</span> =</span> <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]</span><br><span class="line">arrbuf1: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>()</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arrbuf2</span> =</span> <span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">arrbuf2: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arrbuf3</span> =</span> <span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="string">"hello"</span>)</span><br><span class="line">arrbuf3: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Any</span>] = <span class="type">ArrayBuffer</span>(<span class="number">1</span>, hello)</span><br></pre></td></tr></table></figure></p>
<p>和数组Array一样，可变数组也使用<code>(location)</code>来访问数组的元素；并且，ArrayBuffer使用<code>+=</code>来添加元素，使用<code>++=</code>来实现对其他集合的扩展。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; arrbuf2(<span class="number">0</span>)</span><br><span class="line">res18: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2</span><br><span class="line">res20: scala.collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2 += <span class="number">5</span></span><br><span class="line">res21: arrbuf2.<span class="keyword">type</span> = <span class="type">ArrayBuffer</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; arrbuf2 ++= <span class="type">Array</span>(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">res22: arrbuf2.<span class="keyword">type</span> = <span class="type">ArrayBuffer</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>其他的一些有关Array以及ArrayBuffer的操作，可以去ScalaDoc上查阅，你可以点击<a href="http://www.scala-lang.org/api/current/#scala.Array" target="_blank" rel="external">Array</a>或者<a href="http://www.scala-lang.org/api/current/#scala.collection.mutable.ArrayBuffer" target="_blank" rel="external">ArrayBuffer</a>。</p>
<h2 id="总结">总结</h2><p>我们到此了解了数组的基本声明和使用方式，关于数组的具体使用需要根据实际需求进行选择。数组的有关知识也不是这几十行文字和代码所能表达得清楚的，以后的博文中会继续介绍Scala中其他的数据结构以及数组的其他的特性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>我们从这里开始接触Scala中的数据结构，我们首先来看最基础却非常有用的数据结构——数组。<br>这里会涉及两种数组：定长数组以及可变数组，顾名思义，定长数组就是数组在声明的时候就固定了大小，而可变数组可以根据我们使用的实际情况进行调整数组的长度。在Scala中，定长数组为Array，而可变数组为ArrayBuffer。</p>
<h2 id="定长数组">定长数组</h2><p>我们先来看定长数组。声明一个定长数组有以下两种方式：<br><strong>1.声明数组的类型与长度</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">arr1</span> =</span> <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">arr1: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们用<code>new</code>关键字来声明一个Array对象，用来存储4个Int类型的数值，而这4个Int类型的数值初始值都为0。想必这点大家都很容易理解，类似的，String类型的初始值为null，Double类型的初始值为0.0。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之函数]]></title>
    <link href="http://leotse90.com/2015/10/22/Scala%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://leotse90.com/2015/10/22/Scala之函数/</id>
    <published>2015-10-22T10:31:41.000Z</published>
    <updated>2015-11-06T10:40:14.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>今天我们来介绍Scala中的函数的一些基本概念以及用法。  </p>
<h2 id="函数是一等公民">函数是一等公民</h2><p>在Scala中，函数是一等公民。<br>首先来解释一下什么是<em>一等公民</em>，它指的是在程序中可无限使用的对象。<br>那么”函数是Scala的一等公民“这句话怎么理解呢？一言蔽之，就是函数能作为实参，还能作为返回值，它能作为一个普通变量进行使用。详细一点来说，Scala中函数作为一等公民的主要表现有：  </p>
<ul>
<li>可以传递和赋值</li>
<li>嵌套函数</li>
<li>匿名函数</li>
<li>高阶函数</li>
<li>闭包<a id="more"></a>
<h2 id="函数">函数</h2>我们来正式介绍Scala中的函数，先看函数的主要构成，和其他编程语言一样，函数主要由：<strong>函数名</strong>、<strong>参数</strong>以及<strong>函数体</strong>三部分组成。下面我们会从这三个方面介绍Scala中的函数。下面是一个函数的示例：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(</span>x: <span class="type">Int</span>) = println(x)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数名">函数名</h3><p>关于函数名，没有太多需要介绍的，和其他编程语言一样，支持数字、字母以及下划线，$符号，同样的，数字不能放在函数名第一位。一般建议，函数命名采用驼峰风格（小驼峰）。  </p>
<h3 id="参数">参数</h3><p>接下来是参数，在Scala中，所有的参数必须指定类型。在某些情况下，函数的参数可以有默认值，我们称之为默认参数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">func</span>(</span>x: <span class="type">Int</span>, y: <span class="type">Int</span> = <span class="number">3</span>) = x + y</span><br><span class="line">func: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; func(<span class="number">2</span>)</span><br><span class="line">res14: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">scala&gt; func(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">res15: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">scala&gt; func(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&lt;console&gt;:<span class="number">16</span>: error: too many arguments <span class="keyword">for</span> method func: (x: <span class="type">Int</span>, y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line">       func(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; func(y=<span class="number">2</span>, x=<span class="number">6</span>)</span><br><span class="line">res17: <span class="type">Int</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>我们需要注意，如果我们传入的参数数量和函数的参数数量不一致(不能多于函数的参数数量)，函数会从左到右依次将值传给参数。但是当你在传参时指定了参数名（带名参数），那么参数的顺序就不再重要。  </p>
<p>如果我们的参数长度未知，这时我们可以使用变长参数。变长参数实际上是一个类型为Seq的参数（Seq是一个有先后顺序的值的序列，比如数组或者列表）。但是你不能直接将值的序列当成参数传给函数（特指参数为变长参数的函数）。我们看下面的代码便能明白变长参数的使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">toStr</span>(</span>args: <span class="type">String</span> *) = args.mkString(<span class="string">","</span>)</span><br><span class="line">toStr: (args: <span class="type">String</span>*)<span class="type">String</span></span><br><span class="line"></span><br><span class="line">scala&gt; toStr(<span class="string">"leotse"</span>, <span class="string">"yolovon"</span>)</span><br><span class="line">res20: <span class="type">String</span> = leotse,yolovon</span><br><span class="line"></span><br><span class="line">scala&gt; toStr(<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>)</span><br><span class="line">res21: <span class="type">String</span> = <span class="type">One</span>,<span class="type">Two</span>,<span class="type">Three</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数体">函数体</h3><p>在上面的示例中，我们已经多次见过Scala中的函数，他们的函数体如果只有一个表达式或者语句，那么直接跟在函数名后即可（有等号=），如果函数体包含多条语句，那么我们可以使用我们以前介绍过的块表达式。</p>
<h3 id="返回值">返回值</h3><p>我们知道，块表达式的值为{…}中的最后一个表达式的值，那么在Scala的函数中，如果没有指定函数的返回值，块表达式的返回值就是块表达式的最后一个语句的值。<strong>一般情况下，我们都不需要显式指定Scala函数的返回值。</strong>当然我们也可以直接指定函数的返回值类型，如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(</span>v1: <span class="type">Int</span>, v2: <span class="type">String</span>): <span class="type">Double</span> = &#123;function body&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里再一次说明了函数是第一等公民，因为我们直接将函数func指定了一个类型Double。</p>
<h2 id="过程">过程</h2><p>在前面介绍函数的时候，我们看到Scala函数和其他编程语言函数定义不同的地方，那就是函数名后面加了一个等号＝。那么这个＝是不是必须的呢？答案是不。如果函数体在块表达式中而且返回值为Unit类型，那么就可以不要这里的＝，我们称这样的函数为<strong>过程</strong>。不过，有人建议我们一般情况下都加上＝号，并且指定函数的返回值类型，哪怕是Unit类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">func1</span> (</span>a: <span class="type">Int</span>, b: <span class="type">Int</span>) &#123;</span><br><span class="line">     |     println(a + b)</span><br><span class="line">     | &#125;</span><br><span class="line">func1: (a: <span class="type">Int</span>, b: <span class="type">Int</span>)<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">scala&gt; func1(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">func2</span> (</span>a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">     |     println(a + b)</span><br><span class="line">     | &#125;</span><br><span class="line">func2: (a: <span class="type">Int</span>, b: <span class="type">Int</span>)<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">scala&gt; func2(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>Scala的函数基础知识暂且告一段落，但是只有多动手试试才能对Scala的函数有更深层次的理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>今天我们来介绍Scala中的函数的一些基本概念以及用法。  </p>
<h2 id="函数是一等公民">函数是一等公民</h2><p>在Scala中，函数是一等公民。<br>首先来解释一下什么是<em>一等公民</em>，它指的是在程序中可无限使用的对象。<br>那么”函数是Scala的一等公民“这句话怎么理解呢？一言蔽之，就是函数能作为实参，还能作为返回值，它能作为一个普通变量进行使用。详细一点来说，Scala中函数作为一等公民的主要表现有：  </p>
<ul>
<li>可以传递和赋值</li>
<li>嵌套函数</li>
<li>匿名函数</li>
<li>高阶函数</li>
<li>闭包]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之控制结构]]></title>
    <link href="http://leotse90.com/2015/10/21/Scala%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://leotse90.com/2015/10/21/Scala控制结构/</id>
    <published>2015-10-21T09:48:25.000Z</published>
    <updated>2015-11-01T11:32:33.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="块表达式">块表达式</h3><p>首先，我们需要了解一下块表达式。我们这样定义块表达式：凡是用{}包含的语句都同属一个块表达式，在Scala中，块表达式的值等于块表达式最后一条语句的值（在Scala中，每一个表达式都有一个值）。我们看下面的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> v = &#123;<span class="keyword">var</span> a = <span class="number">2</span>; <span class="keyword">var</span> b = <span class="number">4</span>; a + b;&#125;</span><br><span class="line">v: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">v1</span> =</span> &#123;<span class="keyword">var</span> s1 = <span class="string">"hello"</span>; <span class="keyword">var</span> i = <span class="number">20</span>;&#125;</span><br><span class="line">v1: <span class="type">Unit</span> = ()</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以总结以下两点：1.块表达式的值由{…}中的最后一条语句的值决定，那么当我们在定义一个函数的时候，一般不需要定义返回值，因为最后一条语句的值就是这个块表达式的值；2.侧面反映了Scala中赋值语句的值为Unit类型（注：Scala中的Unit类型相当于Java中的void，其只有一个值()）。<br><a id="more"></a></p>
<h3 id="条件表达式">条件表达式</h3><p>条件表达式的作用就不赘述，我们直接来介绍Scala中的条件表达式。它的一般形式如下：<br><code>if (expression) block1 else block2</code><br>值得注意的是，Scala虽然和Java一样，判断条件expression需要为Boolean类型，但是和其他一些语言不一样的是，在Scala中，只有真正的Boolean类型：true或者false能作为判断的依据，而正整数、非空字符串等不能表示true，同理，整数0、空字符串等亦不能表示false。看下面的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">if</span> (<span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span>;</span></span><br><span class="line"> found   : <span class="type">Int</span>(<span class="number">1</span>)</span><br><span class="line"> required: <span class="type">Boolean</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">           ^</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">if</span> (<span class="string">""</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span>;</span></span><br><span class="line"> found   : <span class="type">String</span>(<span class="string">""</span>)</span><br><span class="line"> required: <span class="type">Boolean</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">""</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">           ^</span><br></pre></td></tr></table></figure></p>
<p>在Scala中，我们可以将条件表达式的值直接赋给一个变量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">r</span> =</span> <span class="keyword">if</span> (<span class="string">"hello"</span> &gt; <span class="string">"world"</span>) <span class="string">"hello"</span> <span class="keyword">else</span> <span class="string">"world"</span></span><br><span class="line">r: <span class="type">String</span> = world</span><br></pre></td></tr></table></figure></p>
<p>这种用法熟悉Python的coder可能会比较容易接受，Scala这种设计可能会使得代码在阅读起来并没有那么友善，但是确实可以使得我们的代码更简洁。</p>
<p>另外，Scala并不支持switch语句，因此如果我们有模式匹配上的需求，我们需要用到Scala提供的更强大的模式匹配机制，感兴趣的朋友可以先行了解一下。</p>
<h3 id="循环表达式">循环表达式</h3><p>和Java一样，Scala提供了两种循环表达式：while以及for。<br>通常，函数式语言会避开while循环，因为while实现的大多数操作都可以使用递归来完成。Scala中while循环和Java类似：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> x = <span class="number">3</span></span><br><span class="line">x: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     |     println(x)</span><br><span class="line">     |     x -= <span class="number">1</span></span><br><span class="line">     | &#125;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>Scala中的for循环却和Java中的不太一样，在形式上有较大的改变，有一种观点认为：“Scala 的for实际上是一条管道，它在将元素传递给循环主体之前处理元素组成的集合，每次一个。此管道其中的一部分负责将更多的元素添加到管道中（生成器），一部分负责编辑管道中的元素（过滤器），还有一些负责处理中间的操作（比如记录）。”：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">4</span>) print(i + <span class="string">" "</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">```  </span><br><span class="line">这段代码等同于：  </span><br><span class="line">```scala</span><br><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">4</span>) &#123;</span><br><span class="line">     |     print(i + <span class="string">" "</span>)</span><br><span class="line">     | &#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们看到<code>for (i &lt;- 1 to 4)</code>这种形式的表达式，这条表达式的意思是我们从1到4进行一个遍历，然后将这些值依次赋予变量i。更普遍的for定义是<code>for (v &lt;- expression)</code>，也就是将expression每次生成的值赋给变量v。我们看到<strong>在for循环的变量v之前并没有var或者val，此时，v的类型是集合的元素类型。</strong></p>
<p>这种循环便利非常方便，比如我们要遍历一个字符串：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (c &lt;- <span class="string">"hello, scala"</span>) print(c + <span class="string">"-"</span>)</span><br><span class="line">h-e-l-l-o-,- -s-c-a-l-a-</span><br></pre></td></tr></table></figure></p>
<p>我们还可以这样遍历其他诸如数组、集合之类。</p>
<p>for循环表达式还有更加先进的使用方法，我们称之为<em>for推导式</em>。还是先看一段代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">2</span>; j &lt;- <span class="number">1</span> until <span class="number">3</span>) println((i, j))</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">2</span>; j &lt;- <span class="number">1</span> until <span class="number">3</span> <span class="keyword">if</span> i != j) println((i, j))</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们需要解释一下这段代码，首先额外解释一下to和until的区别，x to y表示从x到y的所有整数，包含y；而x until y表示从x到y的所有整数不包含y（y &gt; x）。我们在这段代码看到，for循环的循环控制语句中有多条表达式，并且以分号分割，每个表达式我们称之为<strong>生成器</strong>，生成器的作用是在每一次循环的时候生成变量的值，控制变量j的赋值语句后跟着<code>if i != j</code>，这是一个<strong>守卫</strong>，守卫用以过滤符合条件的控制变量。</p>
<p>到这里为止，我们已经对Scala的控制结构有一个大致的了解。在实际编码中，我们会看到更灵活、更强大的控制结构使用方法，但是万变不离其宗，它们都是基于这些基本的控制结构形式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="块表达式">块表达式</h3><p>首先，我们需要了解一下块表达式。我们这样定义块表达式：凡是用{}包含的语句都同属一个块表达式，在Scala中，块表达式的值等于块表达式最后一条语句的值（在Scala中，每一个表达式都有一个值）。我们看下面的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> v = &#123;<span class="keyword">var</span> a = <span class="number">2</span>; <span class="keyword">var</span> b = <span class="number">4</span>; a + b;&#125;</span><br><span class="line">v: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">v1</span> =</span> &#123;<span class="keyword">var</span> s1 = <span class="string">"hello"</span>; <span class="keyword">var</span> i = <span class="number">20</span>;&#125;</span><br><span class="line">v1: <span class="type">Unit</span> = ()</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以总结以下两点：1.块表达式的值由{…}中的最后一条语句的值决定，那么当我们在定义一个函数的时候，一般不需要定义返回值，因为最后一条语句的值就是这个块表达式的值；2.侧面反映了Scala中赋值语句的值为Unit类型（注：Scala中的Unit类型相当于Java中的void，其只有一个值()）。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[心猿意码Scala之入门]]></title>
    <link href="http://leotse90.com/2015/10/20/Scala%E5%85%A5%E9%97%A8/"/>
    <id>http://leotse90.com/2015/10/20/Scala入门/</id>
    <published>2015-10-20T02:55:15.000Z</published>
    <updated>2015-11-01T11:31:54.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="为什么是Scala">为什么是Scala</h3><p>有人问Java之父James Gosling“除了Java语言以外，您现在还使用JVM平台上的哪种编程语言？”，他毫不犹豫的回答“Scala”。</p>
<blockquote>
<p>During a meeting in the Community Corner (java.net booth) with James Gosling, a participant asked an interesting question:”Which Programming Language would you use now on top of JVM, except Java?”. The answer was surprisingly fast and very clear: - Scala.</p>
</blockquote>
<p>可见，Scala是一门很受待见的编程语言，另一位大牛Horstmann指出，Scala试图将以下三组对立的思想融合在一门编程语言中:</p>
<blockquote>
<p>函数式编程 VS 面向对象编程<br>富有表达力的语法 VS 静态类型<br>高级的语言特性 VS 与Java高度集成</p>
</blockquote>
<p>这样看来，Scala就是想集各家所长，打造一种平衡的和谐，这看起来像是编程语言世界的乌邦托。<br><a id="more"></a><br>Scala和很多在Java基础上发展的语言一样，需要基于JVM，这一点使得Scala拥有强大的Java所拥有的特性，比如跨平台。但是成也JVM，败也JVM，JVM启动较慢的问题，需要编译等等这些也成为了Scala的瓶颈。只要还立足于JVM，Scala就一直会受到JVM的限制。<br>但是这些都无碍于Scala本身成为一门成功的语言，现在很多公司都已经逐渐投靠Scala阵营，比如twitter，特别是当使用Scala编写的Spark兴起之后，Scala更是成为很多公司大数据编程语言的首选。  </p>
<h3 id="REPL">REPL</h3><p>首先，我们需要认识一下REPL，全称为Read-Eval-Print-Loop，亦即读取－求值－打印－循环。如果是第一次接触这个概念，会觉得有点奇怪，我们可以将REPL称为<strong>交互式解释器</strong>。一般的，我们通过REPL可以快速学习和验证一门语言的特性（前提是这门语言支持REPL）。<br>但是并不是所有的语言都支持REPL，常见的编程语言支持REPL的有Ruby、Python、Lua，使用很广的Java、C++、C#、PHP以及JS等并不支持原生的REPL。当然，我们既然在这里讨论REPL，Scala是肯定支持REPL的。我们在学习Scala的时候可以直接在REPL coding。实际上，我们敲进去的代码首先被编译，然后JVM会执行编译后的字节码，然后返回执行的结果。</p>
<p>我们看一个示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="string">"Hello, Scala"</span></span><br><span class="line">res0: <span class="type">String</span> = <span class="type">Hello</span>, <span class="type">Scala</span></span><br></pre></td></tr></table></figure></p>
<p>从这个示例中，我们可以看到输入的是文本“Hello, Scala”，下面一行是输出，这里的res0是REPL为这个文本起的名字，后面的String表明这个文本是字符串类型。我们可以直接使用res0这个变量名去调用这个字符串文本。</p>
<h3 id="val和var">val和var</h3><p>在上一小节里面，我们已经见识到了Scala的变量声明，但是，我们一般情况下都希望将变量命名的权力牢牢控制在自己手上，因此我们可以使用以下方式声明变量。<br><strong>var</strong>：variable的缩写。用法如下：<br><code>var variable_name: [variable_type] = variable_value</code><br>变量的类型是可选的，因为如果没有指定变量的类型，Scala的编译器会根据变量的值推断出它的类型。我们看下面的示例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> x: <span class="type">Int</span> = <span class="number">1</span>  <span class="comment">// 指定x的类型为Int</span></span><br><span class="line">x: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; x = <span class="number">2</span>  <span class="comment">// 改变变量x的值</span></span><br><span class="line">x: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">var</span> y = <span class="number">3</span>  <span class="comment">// 没有指定y的类型</span></span><br><span class="line">y: <span class="type">Int</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p><strong>val</strong>：这里说变量其实不太准确，因为val声明的是不可变的常量。使用方法和var类似，只是不能修改它的值。在实际开发中，除非我们可以预知需要改变一个值的内容，否则我们一般用val声明。示例如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">val</span> <span class="title">z</span> =</span> <span class="number">3</span></span><br><span class="line">z: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt; z = <span class="number">2</span>  <span class="comment">// 不可以修改一个常量的值</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: reassignment to <span class="function"><span class="keyword">val</span></span></span><br></pre></td></tr></table></figure></p>
<p>一般的，我们不需要声明类型，除非必须。而且我们注意到Scala和Java等语言不一样，变量的类型声明在变量名后面。</p>
<p>我这里引用一段前辈说过的话，里面说明了使用val以及var的场景以及原因：  </p>
<blockquote>
<p><em>Scala 编程人员通常应该首选 val 结构，并在明确需要可变性的时候选择 var。原因很简单：除了使编程更容易之外，val 还能确保程序的线程安全性，Scala 中的一个内在主题是：几乎每次认为需要可变状态时，其实都不需要可变状态。 让我们从不可变字段和本地变量（val）开始，这是展示上述情况的一种方法，甚至对最坚定的 Java 怀疑论者也是如此。从 Java 中的 final 开始介绍可能不是很合理，或许是因为 Java 的非函数特性，尽管此原因不可取。一些好奇的 Java 开发人员可能想尝试一下。</em></p>
</blockquote>
<p>另外，我们在REPL中的示例中可以看到，解释器为我们没有命名的变量定义res0这个名字，凡是解释器定义的变量，如res0、res1等等，都是常量，不可修改:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res0</span><br><span class="line">res1: <span class="type">String</span> = <span class="type">Hello</span>, <span class="type">Scala</span></span><br><span class="line"></span><br><span class="line">scala&gt; res0 = <span class="number">1990</span></span><br><span class="line">&lt;console&gt;:<span class="number">11</span>: error: reassignment to <span class="function"><span class="keyword">val</span></span></span><br></pre></td></tr></table></figure></p>
<p>在Scala中，有8种类型，它们分别为Boolean、Byte、Char、Short、Int、Long、Float以及Double。在这里，我们和Java那样称它们为八大基本类型，因为Scala中并不会刻意去区分基本类型和引用类型，因为他们都是类。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="为什么是Scala">为什么是Scala</h3><p>有人问Java之父James Gosling“除了Java语言以外，您现在还使用JVM平台上的哪种编程语言？”，他毫不犹豫的回答“Scala”。</p>
<blockquote>
<p>During a meeting in the Community Corner (java.net booth) with James Gosling, a participant asked an interesting question:”Which Programming Language would you use now on top of JVM, except Java?”. The answer was surprisingly fast and very clear: - Scala.</p>
</blockquote>
<p>可见，Scala是一门很受待见的编程语言，另一位大牛Horstmann指出，Scala试图将以下三组对立的思想融合在一门编程语言中:</p>
<blockquote>
<p>函数式编程 VS 面向对象编程<br>富有表达力的语法 VS 静态类型<br>高级的语言特性 VS 与Java高度集成</p>
</blockquote>
<p>这样看来，Scala就是想集各家所长，打造一种平衡的和谐，这看起来像是编程语言世界的乌邦托。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://leotse90.com/tags/Scala/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive之JOIN操作]]></title>
    <link href="http://leotse90.com/2015/10/18/Hive%E4%B9%8BJOIN%E6%93%8D%E4%BD%9C/"/>
    <id>http://leotse90.com/2015/10/18/Hive之JOIN操作/</id>
    <published>2015-10-18T02:55:15.000Z</published>
    <updated>2015-10-21T06:41:59.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="Introduction">Introduction</h3><p>在MySQL等关系型数据库中，我们经常会用到联表查询，用以查询多张表的数据。<br>使用联表查询的场景一般是：我们需要对两张或多张表中的数据进行关联，从而得到我们所需要的数据集。  </p>
<p>在Hive中，也存在这样的场景，特别是进行数据分析的时候，但是，Hive虽然支持Hive JOIN语句，但是<strong>只限于等值连接</strong>，也就是说，只支持a.col=b.col而不支持a.col &gt;= b.col这类的条件，主要原因是通过MapReduce很难实现这种类型的联接。</p>
<p>接下来，我们将分析和介绍Hive中主要的JOIN操作。<br><a id="more"></a><br>我们假定我们有两张表：human和assets。它们分别记录了人口以及资产信息，它们的字段如下：<br><code>hive&gt; describe human;</code><br><code>OK</code><br><code>name                    string</code><br><code>age                     int</code><br><code>job                     string</code><br><code>addr                    string</code>  </p>
<p><code>hive&gt; describe assets;</code><br><code>OK</code><br><code>name                    string</code><br><code>bank                    string</code><br><code>fund                    int</code>  </p>
<p>在下面的例子中，将会用到这两张表。</p>
<h3 id="INNER_JOIN">INNER JOIN</h3><p>INNER JOIN，又称内连接。是较为常见的一种JOIN操作：<br><strong>Input</strong>: 表A、表B<br><strong>Condition</strong>: A.col = B.col<br><strong>Output</strong>: 表A和表B中满足Condition的所有数据记录<br><strong>Example</strong>:<br><code>SELECT a.col1, a.col2, b.col2, b.col3</code><br><code>FROM A a JOIN B b</code><br><code>ON a.col1 = b.col1</code><br><code>WHERE a.col3 = &#39;CONDITION&#39;;</code>  </p>
<p>我们来看一个具体的例子，我们想知道human表中每一个人在不同银行的存款记录，我们可以用以下SQL语句进行查询：<br><code>SELECT h.name, h.age, h.job, a.bank, a.fund FROM human h JOIN assets a ON h.name=a.name;</code><br>ON关键字指定了两种表联接的条件，<br>我们对输出结果进行了截取，只选取最终的数据查询记录，如下：<br><code>xiefeng    24    big data    CMB    15000000</code><br><code>leotse    25    programmer    CMB    200000000</code><br><code>leotse    25    programmer    CAB    10000000</code><br><code>yolovon    26    CEO    HB    5000000</code><br><code>yolovon    26    CEO    CCB    3200000</code>  </p>
<p>另外，我们需要注意的是，在Hive中，ON子句中尚不支持谓词OR。</p>
<p>如果我们对多表进行INNER JOIN操作，如:<br><code>SELECT a.col1, a.col2, b.col4, c.col5 FROM a</code><br><code>JOIN b ON a.col1 = b.col2</code><br><code>JOIN c ON a.col2 = c.col3</code><br><code>WHERE CLAUSE;</code><br>大多数情况下，Hive会对每次JOIN操作启动一个MR Job，（在Hive中，SQL的执行是从左至右的）这上面这个SQL语句的执行过程中，首先启动一个MR Job对表a和表b进行一次JOIN操作，然后再启动另一个新的MR Job对表a和表c进行一次JOIN操作。<br>上面说到是大多数情况下，那种小部分的情况是指只要我们使用的ON后的条件（即连接键）一致的话，那就只会产生一个MR Job。</p>
<p>Hive还假定最后一张JOIN的表最大，从而先将前面的表先缓存起来，直到最后一张表才进行计算，因此为了防止内存消耗过大，我们应该尽量保证JOIN操作的表从左到右表大小递增。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="Introduction">Introduction</h3><p>在MySQL等关系型数据库中，我们经常会用到联表查询，用以查询多张表的数据。<br>使用联表查询的场景一般是：我们需要对两张或多张表中的数据进行关联，从而得到我们所需要的数据集。  </p>
<p>在Hive中，也存在这样的场景，特别是进行数据分析的时候，但是，Hive虽然支持Hive JOIN语句，但是<strong>只限于等值连接</strong>，也就是说，只支持a.col=b.col而不支持a.col &gt;= b.col这类的条件，主要原因是通过MapReduce很难实现这种类型的联接。</p>
<p>接下来，我们将分析和介绍Hive中主要的JOIN操作。<br>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://leotse90.com/tags/Hive/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python多进程使用]]></title>
    <link href="http://leotse90.com/2015/10/17/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://leotse90.com/2015/10/17/Python多进程使用/</id>
    <published>2015-10-17T02:55:15.000Z</published>
    <updated>2015-10-23T02:35:40.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Intro">Intro</h2><p>我们知道，由于<a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="external">GIL</a>的关系，Python中多线程并不被看好。因此，Python我们常常使用模块subprocess模块和多进程multiprocessing模块来实现并发。而subprocess因为是调用外部程序而且只是通过管道进行文本交流，因此我们建议在Python并发编程中，尽量使用multiprocessing。  </p>
<p>multiprocessing模块和threading模块很像，该模块同时提供了本地和远程并发，你也不用担心GIL产生的副作用。并且multiprocessing可以在Unix和Windows下使用（区别于为shell而生的subprocess）。<br><a id="more"></a></p>
<h2 id="multiprocessing使用">multiprocessing使用</h2><p>在multiprocessing模块中，我们使用multiprocessing.Process()来创建一个新的进程对象。</p>
<p>一般情况下，我们需要在创建Process对象时指定进程执行的函数，以及该函数的参数：<br><code>process = multiprocessing.Process(target=worker, args=(param1, param2)</code><br>该对象的主要方法有：<br><strong>start()</strong>：启动进程；每个进程最多只能调用一次；<br><strong>run()</strong>：进程的执行逻辑在run()里。如果Process对象没有指定target，就会默认执行Process的run()方法；<br><strong>join([timeout])</strong>：阻塞当前进程，直到调用join方法的那个进程执行完，再继续执行当前进程；<br><strong>is_alive()</strong>：返回该进程是否存活；<br><strong>terminate()</strong>：终结一个进程。当调用这个函数的时候，运行逻辑中的exit和finally代码段将不会执行。而且这个进程的子进程不会被终结而是成为孤儿进程；  </p>
<p>下面我们给出一段多进程使用的示例代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocess</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controller</span><span class="params">()</span>:</span></span><br><span class="line">	processes = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">		process = multiprocessing.Process(target=worker, args=[i])</span><br><span class="line">		processes.append(process)</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.start()</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.join()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(param)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> param</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	controller()</span><br></pre></td></tr></table></figure></p>
<p>我们可以得到如下的输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="子进程通信">子进程通信</h2><p>multiprocessing支持两种类型的进程通信手段，分别是Queue和Pipe。  </p>
<h3 id="Queue">Queue</h3><p>Queue是一种多线程优先队列。它允许多个进程读和写，我们通过<code>mutiprocessing.Queue(maxsize)</code>创建一个Queue，maxsize表示队列中可以存放对象的最大数量。它的一些主要方法有：<br><strong>get()</strong>：删除并返回队列中的一个元素；<br><strong>put()</strong>: 添加元素到队列；<br><strong>qsize()</strong> : 返回队列中元素的个数；<br><strong>empty()</strong>: 队列为空返回True否则返回False；<br><strong>full()</strong>: 队列已满返回True，负责返回False；  </p>
<p>在下面的示例里，我们用Queue实现获取多进程执行时的输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controller</span><span class="params">()</span>:</span></span><br><span class="line">    processes = []</span><br><span class="line">    result_queue = multiprocessing.Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        process = multiprocessing.Process(target=worker, args=[i, result_queue])</span><br><span class="line">        processes.append(process)</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.join()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> result_queue.empty():</span><br><span class="line">        <span class="keyword">print</span> result_queue.get()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(param, result_queue)</span>:</span></span><br><span class="line">    result_queue.put(param + <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    controller()</span><br></pre></td></tr></table></figure></p>
<p>执行这段代码，输出为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">104</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Pipe">Pipe</h3><p>Pipe可以是单向，也可以是双向。我们通过mutiprocessing.Pipe(duplex=False)创建单向管道 (默认为双向)。它主要有send()和recv()两种方法，顾名思义，分别是发送消息和接受消息。<br>我们同样来看一段示例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controller</span><span class="params">()</span>:</span></span><br><span class="line">	processes = []</span><br><span class="line">	parent_conn, child_conn = multiprocessing.Pipe()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">		process = multiprocessing.Process(target=worker, args=[i, child_conn])</span><br><span class="line">		processes.append(process)</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.start()</span><br><span class="line">		<span class="keyword">print</span> parent_conn.recv()</span><br><span class="line">	<span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">		process.join()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(param, child_conn)</span>:</span></span><br><span class="line">	child_conn.send(param + <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	controller()</span><br></pre></td></tr></table></figure></p>
<p>执行这段代码，输出为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">104</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Q&amp;A">Q&amp;A</h2><p>为什么要先依次调用start再调用join，而不是start完了就调用join呢？<br>答：假设我们有两个进程p1，p2，如果我们在p1执行后先join()然后再p2.start()，我们就会发现是先执行完p1，再执行主线程，最后才开始p2。这是因为join是用来阻塞当前线程的，p1.start()之后，p1就提示主线程，需要等待p1结束才向下执行，那主线程就乖乖的等着啦，自然没有执行p2.start()。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Intro">Intro</h2><p>我们知道，由于<a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a>的关系，Python中多线程并不被看好。因此，Python我们常常使用模块subprocess模块和多进程multiprocessing模块来实现并发。而subprocess因为是调用外部程序而且只是通过管道进行文本交流，因此我们建议在Python并发编程中，尽量使用multiprocessing。  </p>
<p>multiprocessing模块和threading模块很像，该模块同时提供了本地和远程并发，你也不用担心GIL产生的副作用。并且multiprocessing可以在Unix和Windows下使用（区别于为shell而生的subprocess）。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://leotse90.com/tags/Python/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】Python中yield关键字用法]]></title>
    <link href="http://leotse90.com/2015/10/15/%E3%80%90%E8%AF%91%E3%80%91Python%E4%B8%ADyield%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/"/>
    <id>http://leotse90.com/2015/10/15/【译】Python中yield关键字用法/</id>
    <published>2015-10-15T02:52:15.000Z</published>
    <updated>2015-10-23T06:29:41.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>本文译自stackoverflow <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="external">What does the yield keyword do in Python?</a></p>
<h2 id="引子">引子</h2><p>这一切始于一位童鞋在Stack Overflow上问的问题：</p>
<p>Python中的yield关键字是用来干嘛的？它都干了些什么？<br><a id="more"></a><br>例如，我试图理解下面这段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</span><br><span class="line">        <span class="keyword">yield</span> self._leftchild</span><br><span class="line">    <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</span><br><span class="line">        <span class="keyword">yield</span> self._rightchild</span><br></pre></td></tr></table></figure></p>
<p>下面是调用代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result, candidates = list(), [self]</span><br><span class="line"><span class="keyword">while</span> candidates:</span><br><span class="line">    node = candidates.pop()</span><br><span class="line">    distance = node._get_dist(obj)</span><br><span class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</span><br><span class="line">        result.extend(node._values)</span><br><span class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>当_get_child_candidates函数被调用时发生了什么？返回了一个list？返回了单个元素？还是它再次被调用了？后面的调用什么时候停止呢？</p>
<p>下面是这个问题的精华回复：</p>
<h2 id="yield关键字用法">yield关键字用法</h2><p>要想理解yield关键字，首先你得理解什么是<strong>生成器</strong>。而在这之前我们先得了解迭代。  </p>
<h3 id="迭代">迭代</h3><p>当你创建了一个list，你就可以逐个元素去读取这个list，这就叫做迭代：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="prompt">... </span>   print(i)</span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>mylist就是可迭代的。当你使用list表达式，你就创建了一个list，亦即创建了一个迭代器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="prompt">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>Python中所有你可以用到”for…in…”表达式的地方都是可迭代的：list，string，files等等。迭代器的优点是你可以读你所需，但是你需要在内存中存储（这些迭代器中的）所有的值，而当我们拥有大量数据时我们并不希望这样做。</p>
<h3 id="生成器">生成器</h3><p>生成器亦即迭代器，但是生成器只能迭代一次。因为它并不会将所有的数据存在内存中，而是实时生成我们所需的数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="prompt">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>这个和你用元组()取代列表[]道理一样。但是，你不能指望<code>for i in mygenerator</code>运行第二次，因为生成器只能被使用一次：它（首先）计算得到0，然后会遗忘0并计算得出1，最终得到4（并遗忘1），以此类推。</p>
<h3 id="yield关键字">yield关键字</h3><p>Yield关键字和return的用法一样，只是（用到yield的）函数将会返回一个生成器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></span><br><span class="line"><span class="prompt">... </span>   mylist = range(<span class="number">3</span>)</span><br><span class="line"><span class="prompt">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="prompt">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="prompt">... </span>    print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子不是太好。但是当你发现你的函数要返回大量只需读一次的数据时你会体会到它（yield）的好处。</p>
<p>要想掌握yield关键字，你必须知道：当你调用这个函数时，函数体里的代码并没有执行，它只是<strong>返回一个生成器对象</strong>，这看起来有点难以理解。</p>
<p>接着，每次你用到这个生成器的时候你的代码都会运行一次。</p>
<p>现在最难的部分来了：</p>
<p>当你第一次调用函数返回的生成器时，它将会运行函数中的代码直到执行到yield，然后它将返回这个循环产生的第一个值。接下来，每一次调用都将执行函数中的这个循环一次，并返回下一个值，直到没有值可以返回为止。</p>
<p>生成器会在函数执行但是没有遇到yield的情况下置空，这可能是因为循环结束了，或者是不再满足”if/else”条件。</p>
<h3 id="问题中的代码解释">问题中的代码解释</h3><p><strong>生成器</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在这里你创建了node对象的一个返回生成器的函数`  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span>`  </span><br><span class="line"> </span><br><span class="line">  <span class="comment"># 下面这段代码将会在每次你使用这个生成器时被调用:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果node对象仍然有一个左child</span></span><br><span class="line">  <span class="comment"># 而且distance满足条件，则返回下一个左child</span></span><br><span class="line">  <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</span><br><span class="line">      <span class="keyword">yield</span> self._leftchild</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果node对象仍然有一个右child</span></span><br><span class="line">  <span class="comment"># 而且distance满足条件，则返回下一个右child</span></span><br><span class="line">  <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</span><br><span class="line">      <span class="keyword">yield</span> self._rightchild</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果这个函数运行到这里了，意味着这个生成器可以看成空的了。</span></span><br><span class="line">  <span class="comment"># 亦即：再也没有符合条件的左右child</span></span><br></pre></td></tr></table></figure></p>
<p><strong>调用方</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空的list和一个包含当前对象引用的list</span></span><br><span class="line">result, candidates = list(), [self]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环处理candidates (最初只有一个元素)</span></span><br><span class="line"><span class="keyword">while</span> candidates:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取最后一个candidate将其移除</span></span><br><span class="line">    node = candidates.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取obj和candidate之间的距离</span></span><br><span class="line">    distance = node._get_dist(obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果距离合适，保存结果在result中</span></span><br><span class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</span><br><span class="line">        result.extend(node._values)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将candidate的子节点保存在candidates中</span></span><br><span class="line">    <span class="comment"># 该循环会一直循环直到遍历了所有的子节点。</span></span><br><span class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>这段代码包含了以下几个很有意思的地方：</p>
<p>1）这个循环在遍历一个list，而这个list会在遍历的过程中增大。虽然存在变成无限循环的风险，但是这仍不失为遍历嵌套数据的好方法。在这里，candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))方法获取了这个生成器的所有元素，但是<code>while</code>在产生新的生成器，它们就会继续生产新的元素，直到换了一个节点。</p>
<p>2）extend()方法是list的一个用于将迭代器的元素追加在list中。<br>一般地，我们传一个list给它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a.extend(b)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p>但是在你给出的代码里，它获取了一个生成器，它有如下几个好处：<br>a.你不需要两次读取这些元素；<br>b.如果你有很多子节点，你不需要把它们都保存在内存中；<br>这个方法很管用，因为Python不关心你传入的参数是不是一个list。Python只关心参数是否是可迭代的如字符串、list、元组以及生成器。这叫做<a href="http://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">鸭子类型</a>，这也是Python为何如此赞的一个原因。但是这些都不在我们的讨论范围内。</p>
<p>你可以到此结束，也可以接着看下面生成器的一些高级用法：</p>
<h3 id="控制生成器">控制生成器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span> <span class="comment"># let's create a bank, building ATMs</span></span><br><span class="line"><span class="prompt">... </span>   crisis = <span class="keyword">False</span></span><br><span class="line"><span class="prompt">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="prompt">... </span>       <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</span><br><span class="line"><span class="prompt">... </span>           <span class="keyword">yield</span> <span class="string">"$100"</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hsbc = Bank() <span class="comment"># when everything's ok the ATM gives you as much as you want</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line">[<span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">True</span> <span class="comment"># crisis is coming, no more money!</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class="comment"># it's even true for new ATMs</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(wall_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">False</span> <span class="comment"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class="comment"># build a new one to get back in business</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</span><br><span class="line"><span class="prompt">... </span>   <span class="keyword">print</span> cash</span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果想要控制对资源的访问，这将非常受用。</p>
<h3 id="itertools，你上佳的朋友">itertools，你上佳的朋友</h3><p>itertools模块包含了操纵迭代的一些特殊的函数。你是不是曾经想过复制一个生产器？串联两个生成器？抑或在线性时间内将嵌套list中的元素分组？或者不依赖创建新list的情况下map/zip？</p>
<p>那么，你只要导入itertools模块就行了。</p>
<p>想要看个例子？让我们看看四匹马到达终点的可能顺序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(races)</span><br><span class="line">&lt;itertools.permutations object at <span class="number">0xb754f1dc</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p>
<h3 id="理解迭代的内部机制">理解迭代的内部机制</h3><p>迭代是实现迭代（实现了__iter__()函数）和迭代器（实现了__next__()函数）的过程。你可以从可迭代对象上获取一个迭代器，而迭代器是你可以迭代的对象。</p>
<p>想要了解更多，你可以看看这篇<a href="http://effbot.org/zone/python-for-statement.htm" target="_blank" rel="external">文章</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>本文译自stackoverflow <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python">What does the yield keyword do in Python?</a></p>
<h2 id="引子">引子</h2><p>这一切始于一位童鞋在Stack Overflow上问的问题：</p>
<p>Python中的yield关键字是用来干嘛的？它都干了些什么？<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://leotse90.com/tags/Python/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python任务调度队列Celery]]></title>
    <link href="http://leotse90.com/2015/10/14/Python%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97Celery/"/>
    <id>http://leotse90.com/2015/10/14/Python任务调度队列Celery/</id>
    <published>2015-10-14T02:55:15.000Z</published>
    <updated>2015-10-23T02:44:03.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Introduction">Introduction</h2><p>在Python的使用过程中，我们常常会遇到执行一些多进程任务，或者一系列长时间的后台任务。比如，多进程下载视频并上传到某一个文件系统中。这时候，我们可以使用任务调度队列帮我们进行任务的分发与管理。</p>
<p>Celery就是这样一个任务队列，易于使用，入门简单。Celery常常需要第三方作为发送和接收消息的中间层，一般我们用到的有RabbitMQ、Redis、MongoDB等等，次等的选择也可以是数据库。</p>
<p>一般推荐使用RabbitMQ，但是我们这里用到Redis，因为Redis安装的时候依赖少，而且性能稳定，但是Redis也有缺点，那就是断电的时候会丢失数据。我们在这里，就以Redis作为Celery的第三方中间层。<br><a id="more"></a></p>
<h2 id="Installation">Installation</h2><p>我们这里使用Celery+redis套餐进行任务的调度。  </p>
<p>Celery的安装非常简单，在linux系统下直接执行：  </p>
<pre>
sudo pip install Celery
sudo pip install celery-with-redis
</pre>
如果上述安装失败，可以尝试：  
<pre>
sudo easy_install Celery
</pre>

<p>我们来验证一下Celery是否安装成功，进入python shell，输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br></pre></td></tr></table></figure></p>
<p>如果没有报错，则说明安装成功。</p>
<p>接着我们安装redis：  </p>
<pre>
sudo apt-get install redis-server
</pre>
安装完成后，redis会自动启动，我们也来验证一下redis是否安装成功：  
<pre>
ps -aux|grep redis
</pre>
如果看到以下输出，则说明安装ok：  
<pre>
redis      942  0.2  0.0  73852  1832 ?        Ssl  Apr13 302:26 /usr/bin/redis-server /etc/redis/redis.conf
</pre>

<p>它们的安装都比较简单。接下来我们看如何使用Celery进行任务调度。</p>
<h2 id="Usage">Usage</h2><p>我们应该都知道生产者-消费者模型，在使用Celery的时候，我们也需要一个生产者和一个消费者，生产者负责往队列里写入待处理的数据，消费者负责将数据从队列中取出并进行处理。我们在这里将redis作为存储这种“数据”的地方。</p>
<p>我们来看这样一个示例，我们假设要下载一批视频v1，v2，v3….，这批视频列表存在另一个文件系统中，我们假设通过get_video_list方法来获取这批视频列表，另一方面，我们可以通过download_video_worker(video)来下载视频。</p>
<p>那么，生产者的伪代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> download_video_worker</span><br><span class="line">video_list = get_video_list()</span><br><span class="line"><span class="keyword">for</span> video <span class="keyword">in</span> video_list: </span><br><span class="line">    download_video_worker.apply_async([video])</span><br></pre></td></tr></table></figure></p>
<p>消费者的伪代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">download_app=Celery(<span class="string">"download_videos"</span>, broker=<span class="string">"redis://localhost:6379/0"</span>)</span><br><span class="line"><span class="decorator">@download_app.task`  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_video_worker</span><span class="params">(video)</span>:</span></span><br><span class="line">    download_video_to_local(video)</span><br></pre></td></tr></table></figure></p>
<p>接着我们运行Celery：  </p>
<pre>
celery -A download_video_worker worker --loglevel=info
</pre>

<p>这样，当我们每次往队列中放入video信息时，celery就会执行download_video_woker中的逻辑处理video的下载过程。</p>
<h3 id="推荐阅读">推荐阅读</h3><p><a href="http://www.celeryproject.org/" target="_blank" rel="external">Homepage - Celery: Distributed Task Queue</a><br><a href="https://denibertovic.com/posts/celery-best-practices/" target="_blank" rel="external">CELERY - BEST PRACTICES</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Introduction">Introduction</h2><p>在Python的使用过程中，我们常常会遇到执行一些多进程任务，或者一系列长时间的后台任务。比如，多进程下载视频并上传到某一个文件系统中。这时候，我们可以使用任务调度队列帮我们进行任务的分发与管理。</p>
<p>Celery就是这样一个任务队列，易于使用，入门简单。Celery常常需要第三方作为发送和接收消息的中间层，一般我们用到的有RabbitMQ、Redis、MongoDB等等，次等的选择也可以是数据库。</p>
<p>一般推荐使用RabbitMQ，但是我们这里用到Redis，因为Redis安装的时候依赖少，而且性能稳定，但是Redis也有缺点，那就是断电的时候会丢失数据。我们在这里，就以Redis作为Celery的第三方中间层。<br>]]>
    
    </summary>
    
      <category term="Celery" scheme="http://leotse90.com/tags/Celery/"/>
    
      <category term="Python" scheme="http://leotse90.com/tags/Python/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive浮点数比较与计算]]></title>
    <link href="http://leotse90.com/2015/10/12/Hive%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <id>http://leotse90.com/2015/10/12/Hive浮点数比较与计算/</id>
    <published>2015-10-12T02:55:15.000Z</published>
    <updated>2015-10-21T06:42:33.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h3 id="Hive浮点数比较">Hive浮点数比较</h3><p>Hive的较早前版本（0.9.0）在比较浮点数时会出现问题，如下：<br><code>hive&gt; select * from float_compare where weight&gt;120.9;</code><br><code>OK</code><br><code>xiefeng 128.2</code><br><code>yolovon 121.8</code><br><code>leotse 120.9</code><br>我们可以看到，leotse乱入了，他的weight等于120.9，这一点与我们的预期不符合。设想一下，如果这些数据不是weight而是money，那么结果就会变成后果。这是Hive的一个BUG，我们在Hive的issues上可以看到<a href="https://issues.apache.org/jira/browse/HIVE-2586" target="_blank" rel="external">Float comparison doesn’t work</a>。这个问题已经解决了，但是我们仍然可以分析一下其他的原因。<br><a id="more"></a><br>在float_weight表中，weight以float类型保存。当我们在HiveQL语句输入120.9时，Hive会将其保存为double类型，这样我们看看120.9分别在这两种类型的表示：<br><code>float 120.9000001</code><br><code>double 120.900000000001</code><br>我们知道，在比较float和double类型数值时，float会强制转型为double。这样当float_compare表中数值120.9在和HQL中120.9比较时，前者会转型为120.900000100000。我们可以看到120.900000100000&gt;120.900000000001。这也就是为什么leotse会出现在查询结果的原因。</p>
<p>虽然这个问题已经解决，但是仍然给我们一些启示，当我们在进行浮点数比较的时候，需要警惕float和double的自动转型，特别需要避免从窄类型数值向宽类型数值的转型。</p>
<h3 id="Hive浮点数计算">Hive浮点数计算</h3><p>相比上面的问题，浮点数的计算也是一个BUG，而且现在还没有解决，<a href="https://issues.apache.org/jira/browse/HIVE-3715" target="_blank" rel="external">float and double calculation is inaccurate in Hive</a>。</p>
<p>为了方便对比，我们先展示出表float_compare中的全部数据：<br><code>hive&gt; select * from float_compare;</code><br><code>OK</code><br><code>dooley 110.0</code><br><code>xiefeng 128.2</code><br><code>leotse    120.9</code><br><code>februus 119.0</code><br><code>yolovon 121.8</code>  </p>
<p>接下来我们将表中的weight的字段除以10，得到如下结果：<br><code>hive&gt; select weight/10 from float_compare;</code><br><code>OK</code><br><code>11.0</code><br><code>12.819999694824219</code><br><code>12.09000015258789</code><br><code>11.9</code><br><code>12.180000305175781</code>  </p>
<p>我们可以看到，除了110.0和120.0这种小数点后为0的，其他浮点数计算的结果都是不符合我们预期的。实际上，这个问题在Hive和Java中都存在（Hive用Java实现），而且所有使用IEEE标准进行浮点数编码的系统都存在这个问题。目前这个没有被解决，在这里摆出来是希望以后在遇到类似的浮点数计算的时候，我们能够长一个心眼，以免出现了谬误还不知道为什么。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h3 id="Hive浮点数比较">Hive浮点数比较</h3><p>Hive的较早前版本（0.9.0）在比较浮点数时会出现问题，如下：<br><code>hive&gt; select * from float_compare where weight&gt;120.9;</code><br><code>OK</code><br><code>xiefeng 128.2</code><br><code>yolovon 121.8</code><br><code>leotse 120.9</code><br>我们可以看到，leotse乱入了，他的weight等于120.9，这一点与我们的预期不符合。设想一下，如果这些数据不是weight而是money，那么结果就会变成后果。这是Hive的一个BUG，我们在Hive的issues上可以看到<a href="https://issues.apache.org/jira/browse/HIVE-2586">Float comparison doesn’t work</a>。这个问题已经解决了，但是我们仍然可以分析一下其他的原因。<br>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://leotse90.com/tags/Hive/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive 本地模式]]></title>
    <link href="http://leotse90.com/2015/10/11/Hive%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://leotse90.com/2015/10/11/Hive本地模式/</id>
    <published>2015-10-11T02:55:15.000Z</published>
    <updated>2015-10-21T06:42:20.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>我们都知道，Hive是通过将HiveQL转化为MR job进行数据查询和处理。当然，不是全部的HQL语句都需要转为MR，比如我们常见的：<br><code>SELECT * FROM access_log;</code><br>这时候，Hive Shell能很快地返回给我们结果，这是因为这里用到的是Hive的<strong>本地模式</strong>。<br>Hive查询耗时太长，一直都是大家吐槽的对象，在数据量大的情况下，当然微不足道，但是当我们的查询量很小亦即查询数据很少的时候，Hive启动的耗时将会显得非常刺眼，因此在0.7版本以后，Hive开始支持本地模式。</p>
<p>除了上面的示例使用到了本地模式，如果WHERE语句中只是分区字段这种情况，也是无需使用MR job的：<br><code>SELECT * FROM access_log</code><br><code>WHERE dt=&#39;20150916&#39;</code><br><code>LIMIT 10;</code><br>这是因为分区字段在HDFS中保存实际上是目录结构，这些都是不用通过计算获取的（包含LIMIT）。<br><a id="more"></a><br>除此之外，我们还可以怎么利用本地模式帮助我们快速处理少量数据呢？我们可以通过设置下面变量打开本地模式：<br><code>set hive.exec.mode.local.auto=true;</code><br>默认情况下这个设置为false，也就是说，Hive使用MR来执行其他的所有操作（区别上面介绍的两种）。</p>
<p>我们来感受下，下面截图为没有使用本地模式时查询数据条目数：<br><img src="https://github.com/leotse90/SparkNotes/blob/master/images/hive_local_mode_false.png" alt="hive_local_mode_false"><br>我们看到这个简单的操作用了34.321s，一共也就192条数据，这个固然和机器有关，但是MR启动以及计算导致时间成本太高。我们在下面的示例里打开了本地模式：<br><img src="https://github.com/leotse90/SparkNotes/blob/master/images/hive_local_mode_true.png" alt="hive_local_mode_true"><br>1.322s!，我们看到耗时明显降低，这就是本地模式的威力。</p>
<p>当然，使用本地模式也有一些条件：<br>1.<strong>输入数据的size</strong>：我们用参数hive.exec.mode.local.auto.inputbytes.max来指定本地模式处理的最大输入数据，默认为128MB；<br>2.<strong>Mapper的数量</strong>：参数hive.exec.mode.local.auto.tasks.max指定了本地模式下Mapper的最大数量，默认为4；<br>3.<strong>Reducer的数量</strong>：Reducer数量必须是0或1；</p>
<p>我们在使用Hive时，最好在$HOME/.hiverc配置文件中加入<code>set hive.exec.mode.local.auto=true;</code>设置。特别是当我们常常处理的数据量不大的时候！</p>
<p>另：由于Hadoop运行的机器和Hive client运行的机器可能环境不一致，JVM版本的不同或者软件的libs不同会导致本地模式可能出现不可预期的错误。另外一点值得我们注意的是，本地模式运行在Hive Client上一个独立的子JVM上，如果你愿意，那么你可以通过<code>hive.mapred.local.mem</code>参数来设置该子JVM最大内存，默认情况下，这个参数的值为0，在这种情况下，Hive会让Hadoop决定子JVM的默认内存限制。</p>
<p>参考：<br><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted#GettingStarted-Hive,Map-ReduceandLocal-Mode" target="_blank" rel="external">Hive GettingStarted</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>我们都知道，Hive是通过将HiveQL转化为MR job进行数据查询和处理。当然，不是全部的HQL语句都需要转为MR，比如我们常见的：<br><code>SELECT * FROM access_log;</code><br>这时候，Hive Shell能很快地返回给我们结果，这是因为这里用到的是Hive的<strong>本地模式</strong>。<br>Hive查询耗时太长，一直都是大家吐槽的对象，在数据量大的情况下，当然微不足道，但是当我们的查询量很小亦即查询数据很少的时候，Hive启动的耗时将会显得非常刺眼，因此在0.7版本以后，Hive开始支持本地模式。</p>
<p>除了上面的示例使用到了本地模式，如果WHERE语句中只是分区字段这种情况，也是无需使用MR job的：<br><code>SELECT * FROM access_log</code><br><code>WHERE dt=&#39;20150916&#39;</code><br><code>LIMIT 10;</code><br>这是因为分区字段在HDFS中保存实际上是目录结构，这些都是不用通过计算获取的（包含LIMIT）。<br>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://leotse90.com/tags/Hive/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
