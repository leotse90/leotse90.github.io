<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一条互联网广告狗]]></title>
  <subtitle><![CDATA[My name is L.T.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://leotse90.com/"/>
  <updated>2016-05-14T13:23:12.000Z</updated>
  <id>http://leotse90.com/</id>
  
  <author>
    <name><![CDATA[Leo Tse]]></name>
    <email><![CDATA[proleo@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[移动广告之互联网广告产业链]]></title>
    <link href="http://leotse90.com/2016/05/14/Mobile-AD-industry-chain/"/>
    <id>http://leotse90.com/2016/05/14/Mobile-AD-industry-chain/</id>
    <published>2016-05-14T13:21:32.000Z</published>
    <updated>2016-05-14T13:23:12.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/ad-chain.jpg" alt="ad-chain"><br></center>

<a id="more"></a>
<p>这张图估计大多数接触互联网广告的人都接触过。但是这里还是要放这张图，窃以为理解这张图已经可以算是理解了这个行业。本人对于广告这个行业来说也只能说是刚入门，这里面的门道太多，只能说路漫漫其修远兮了。</p>
<blockquote>
<p>1.Advertiser：广告主<br>2.Agency：广告代理<br>3.DSP：需求方平台<br>4.ADX：广告交易平台<br>5.Ad network：广告网络／广告平台<br>6.SSP：供应方平台<br>7.Publisher：媒体</p>
</blockquote>
<p>这次我只打算简单描述一下这个互联网广告产业链。因为每一个环节展开都需要花很长的篇幅。接下来会针对Ad Network，Adx，RTB，SSP&amp;DSP分别详细介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/ad-chain.jpg" alt="ad-chain"><br></center>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[［转］浅谈APP运营推广：该如何的精准投放广告？]]></title>
    <link href="http://leotse90.com/2016/05/04/how-to-delivery-ad/"/>
    <id>http://leotse90.com/2016/05/04/how-to-delivery-ad/</id>
    <published>2016-05-04T15:36:19.000Z</published>
    <updated>2016-05-04T15:40:34.000Z</updated>
    <content type="html"><![CDATA[<p><center><br><img src="/img/apptuiguang.jpg" alt="apptuiguang"><br></center><br><a id="more"></a></p>
<h2 id="前言">前言</h2><p>截至今年3月底，据工信部的数据，我国的智能手机用户总数已达12.9亿，同比增长3.6%，其中4G用户一季度增加6千万户，我国4G用户已达1.6亿户。伴随着移动互联网的快速发展，衔接有软件和硬件升级，人们已经习惯了用手机做任何事情，移动互联网已经渗透到我们生活中的方方面面，包括衣食住行。</p>
<p>那么作为一个移动互联网行业的从业者，特别是APP运营推广圈的朋友们，该如何在海量的手机用户中精准的获取到用户呢？身处这样一个移动互联网的大时代背景下，做app推广就应该站在不一样的高度去纵观全局，不能只为了推广而去推广，值得深思的问题是我们该如何做好运营？如何做好用户？一切都是为了用户，为了用户的一切。推广也是如此。</p>
<p>那么，今天我想要讲的就是我们在选择渠道的时候，怎样利用最低的成本找到精准用户 获取一手流量？</p>
<h2 id="一-该考虑：如何选择有效的渠道？">一.该考虑：如何选择有效的渠道？</h2><p>APP推广渠道主要分为付费和免费合作两种方式。流量为王的时代，免费推广基本上已经失去了它原本的意义。我想说的是在移动互联网的行业里，时间其实比钱更重要，免费的渠道虽然不花钱，但是花时间，时间和人力换算成成本，依然很高昂。</p>
<p>所以对于免费渠道推广我就不一一举例说明，今天主要讲讲付费的渠道推广。</p>
<p>现在市场上主流的APP从开发环境和搭载系统上来区分主要分为三种类型，分别是ios版本、android版本和WP8系统。</p>
<p>所以，针对于这个不同系统的因素，我们在选择渠道的时候也要考虑进去，以免你花钱买来的流量白白浪费，并且在对于推广数据分析的时候影响你对渠道</p>
<p>首先，目前可供选择的app推广渠道都有哪些？</p>
<h3 id="1-应用市场下载渠道">1.应用市场下载渠道</h3><p>（主要介绍安卓，因为ios渠道相对单一）</p>
<p>根据艾瑞咨询的统计数据分析显示，目前安卓应用日均下载量约为1.3亿，这也是由于应用市场和PC端各大软件管家以及下载站起步较早，已经培养了用户的下载习惯，所以针对于app，各个软件下载平台已成为首选的应用下载道。</p>
<p>一般情况，用户初次的下载，都是来自推荐以及曝光性搜索。一些推广人员研究某些市场的排名规则，进行关键词、评论、星级，下载量等的优化，更牛的推广人员是直接占据大量热门APP名称，使用户在搜索关键词的时候命中这些热门APP名称    使自己的搜索结果排序靠前，以及优化排行榜排名（刷榜），提升曝光。</p>
<p>为满足推广人员对于当下热门的第三方应用市场渠道的推广需求，有代理公司提供这种专业的推广服务，当然不花钱你自己也能做，耗人耗力。不明白为什么这样子的话，可以回过头看前言部分。</p>
<p>应用市场下载渠道的推广成本与费用，若按cpc计算大致为0.5元~1.5元不等；若按CPD大概为2~5元；至于CPT根据位置不同从几千到几万一天不等，不过我不推荐CPT这种方式。当然有钱你可以做，</p>
<p>渠道优势：用户质量相对来说高，量大，可快速获取用户</p>
<p>渠道劣势：留存转化低，做精准用户的应用那就更难了，市场多达200家以上，主流市场十几家左右，选择一个靠谱的难，框架合作随可降价但是维护成本高。</p>
<h3 id="2-广告联盟以及wap流量渠道">2.广告联盟以及wap流量渠道</h3><p>广告联盟是很常见的一种推广方式，我也一直向圈子里面的朋友推荐这种渠道，因为我在联盟里做过一段时间，深谙其道。虽然很多人对这种渠道提出来很多质疑，比如，难以把控真假效果，量太小，占用资源太多，但是，我想说，你如果把研究如何做aso的这种精力放到研究这种小渠道的身上，我想大家也会开辟一个新渠道出来，众多的质疑以及广告联盟依然能活的这么潇洒，自然有它存在的道理。</p>
<p>接下来就我个人的一点小见解和各位看官分享一下。</p>
<p>目前比较大的几家联盟如:友盟（别以为友盟就是一个数据统计后台，其实他是做联盟的）、亿邦动力、微云 、有米、admod 、力美等，其他的一些小联盟那就更多了，市场上目前我知道的不下于100家。这么多的联盟，这么多流量，我们该怎么样的好好利用一下呢？</p>
<p>渠道推广说白了就是曝光，想尽一切办法把自己的产品展示在用户的面前，那么最好的曝光有哪些？视频最直观，其次是图片加文字，用到最多的就是图片文字，根据自己的产品不同选择投放的广告联盟的不同选择投放的网站以及位置的不同，适配相应的文字图片内容，不断试错优化。试错上两三个渠道，效果以及量级稳定后，可以选在十来家一起投放。</p>
<p>在选择类似这种小渠道的时候，千万注意多找几家，因为这种渠道骗子还挺多，一般靠谱的优质渠道，你可以提出自己想要的要求（量级、留存、活跃度、约定结算日期等），然后定价、签订合同，后付款。我们的权限比较自由，这种渠道其实也是缺一手产品，我们就像一个中介，把有量的网站主聚合在一起，再去找产品。依赖于这种圈子过活的人真的不在少数。有些大联盟用户行为数据分析很专业，比我们做的要精确得多的多。</p>
<p>费用成本，按cpc 0.3元~0.8元，cps(激活成本1.5~3元）</p>
<p>渠道优势：起量快，成本比较低廉，换量的人比较喜欢这种渠道，一般性合作后附款</p>
<p>渠道劣势：存在作弊行为，媒体维护成本高，用户质量一般。沟通监控成本高，这种方式需要监控订单来保证用户质量，操作比较复杂</p>
<h3 id="3．社会化营销渠道">3．社会化营销渠道</h3><p>除了以上提到的传统渠道，近几年来利用微博微信社交新闻媒体等社会化营销渠道推广APP也成为很热门的选择。我圈子内的朋友基本上每天都在围绕着这些渠道讨论推广方案。渠道量确实很可观，而且初期做这种渠道的许多产品夸张地说真是“一夜暴富”，因为我们产品所需有的用户基本上都在这些渠道里面，任何产品，不管你需要多么精准的用户他都隐藏在这些渠道里。说到此，那我们在此类渠道的时候，该如何有效利用?该如何规避一些问题？</p>
<p>由此，社会化渠道面临一个最常见的问题，就是无法衡量在口碑传播过中产生的真正下载量。另外，口碑营销的传播其实与产品本身有密切效果。产品是否真正有价值，能够刺激用户去使用也是很重要的一部分。但营销的价值在于放大产品某一方面的优点，或者包装一个噱头，需要产品和运营人员精心策划，有步骤有节奏的去进行营销，才能收到良好效果。        </p>
<p>渠道类别：腾讯系（广点通、智慧推）百度系（百度贴吧、百度百通、百度直通车）新浪（粉丝通、扶翼、九宫格）今日头条信息流 陌陌信息流、网易、搜狐等  </p>
<p>费用成本：每个渠道推广方式是不一样的，竞价模式，按曝光 展示 点击 下载等都有，但是基本核算成一个下载的话跨度比较大3-15元/下载。</p>
<p>渠道优势：精准化获取定向用户，用户质量比较高，品牌曝光比较好，效果可控</p>
<p>渠道劣势：在目前未能全面有效的一个统计后台分析成本，只针对于当天的数据来判断成本的话显得比较高，以至于让我们无法判别这种渠道到底是什么样的效果。</p>
<h3 id="4．厂商预装以及刷机">4．厂商预装以及刷机</h3><p>对很多有实力的大公司来说是个不错的选择，拉卡拉被联想控股，预装联想手机属于内部资源置换，如果要拓展外部厂商资源，资金不充足的话不是首选渠道。</p>
<p>费用成本：按照预装量付费价格在0.5元~1元之间，cpa按照激活付费1.5元~4元不等。</p>
<p>渠道优势：量大，平均成本不算高。</p>
<p>渠道劣势：跟进成本高，用户类型广，精准用户比例相比其他渠道偏低。</p>
<h2 id="二．怎么样投放广告？">二．怎么样投放广告？</h2><p>有一句话做渠道的人都清楚，这句话，让所有的老板无奈，甚至成为一些人的借口，这句话是：我们知道有一半广告费是在浪费，但是没人知道是哪一半。</p>
<p>那么我们如何才能让广告的效果达到最大化呢？</p>
<p>确定产品目标人群的时间以及分布，现在都在讲精准化营销，这个说法是对的，但是没有人做得到，因为你再有本事，你也不可能时刻知道每个人的行为，更何况那么多用户，所以在选择产品投放渠道的时候，我们首先要分析你的目标用户的行为喜好兴趣等等这些因素，找到他们都隐藏在哪里，做到这点以后，我们再去找到所选渠道对应的栏目位置配合相关素材文字去做精准投放。其次，最简单的才是最有效的，所投放的广告如果偏离的目标用户群体的浏览习惯，那也是失败的，更重要的是渠道推广是需要媒体传播配合的，但同时需要避免轰炸式烂广告，这样同样会玩坏用户。</p>
<p>下面我为各位分析一下，渠道推广时需要怎么样去判断一个渠道成功与否。</p>
<h3 id="1-品牌曝光">1.品牌曝光</h3><p>曝光量是广告主品牌在受众面前出现次数的体现，是产生点击、反馈的前提。大量的品牌曝光有利于加深受众对品牌产品的认识，进而提升品牌影响力。</p>
<h3 id="2-下载激活(冲榜和留存)">2.下载激活(冲榜和留存)</h3><p>下载激活主要针对专业和游戏客户，他们推广的主要需求在于其产品的冲榜以及获取更多的真实用户。利用各种推广方式使客户产品名列榜单前列,通常情况下，榜单排名决定了自然真实下载的用户。</p>
<h3 id="3-订单销量">3.订单销量</h3><p>主要针对于电商类客户，客户转化率是电商界人士最关心的一个指标，真金白银的广告费究竟起了多大效果?带来了多少订单?为达到提高订单销量的效果，广告的展示方式和展示内容需要与用户的使用习惯深度契合。</p>
<h3 id="4-促销活动">4.促销活动</h3><p>诸如教育类、汽车类客户，为提升品牌影响力，经常以培训、试驾等促销活动的形式进行推广。</p>
<p>通常情况下，广告主在冲榜的预算最多，达到50%，一般新产品上架都要先做冲榜，据运营高手透露，新品App下载量达到10万以上才能进到榜单前100，如果不做冲榜新产品很难被用户看到。</p>
<h2 id="三．总结">三．总结</h2><p>以上是柴哥介绍的app推广如何选择渠道和怎么投放渠道的两个问题，在后面我还会讲到如何做到不是很精准的精准化渠道营销，在渠道推广的行业里，不要指望着读几篇文章就去照猫画虎的去尝试，每个产品都有自己不一样的推广思维，在互联网发展瞬息万变的今天，随时都会出现新的可能，在这些可能中找到适合自己的推广方案才是最关键的，任何一款好的产品都有一个核心，所以，我认为互联网成功的秘诀是能够拿到有粘性的低成本的推广方案。</p>
<p>最后我想说一款真正好的产品，即使在没有推广的情况下活跃用户也会持续增加，更优秀的甚至暴增。尤其互联网产品更是主要以产品用户体验为导向，而不是营销为导向的。当然我不否认好的营销推广会使好的产品更快的为大众所接受。所以，好的产品是前提，推广只是为了让更多不知道却有需求的用户知道它。</p>
<p>本文为作者 @喵哆啦柴哥 投稿发布，转载请注明来源于人人都是产品经理并附带<a href="http://www.woshipm.com/operate/245479.html" target="_blank" rel="external">本文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><center><br><img src="/img/apptuiguang.jpg" alt="apptuiguang"><br></center><br>]]>
    
    </summary>
    
      <category term="广告杂谈" scheme="http://leotse90.com/tags/%E5%B9%BF%E5%91%8A%E6%9D%82%E8%B0%88/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[See You Again]]></title>
    <link href="http://leotse90.com/2016/04/14/see-you-again/"/>
    <id>http://leotse90.com/2016/04/14/see-you-again/</id>
    <published>2016-04-14T15:50:50.000Z</published>
    <updated>2016-05-04T16:31:22.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=31607266&auto=0&height=66"></iframe>

<center><br><img src="/img/kobe0.jpeg" alt="kobe0"><br><strong>Legend! Forever!</strong><br></center><br><a id="more"></a><br><br><center><br><img src="/img/kobe1.jpg" alt="kobe1"><br><strong>远去的黄金一代，远去的青春岁月。</strong><br></center>


<center><br><img src="/img/kobe2.jpg" alt="kobe2"><br><strong>我转身，全世界已经在我脚下。</strong><br></center>


<center><br><img src="/img/kobe3.jpg" alt="kobe3"><br><strong>黑曼巴，再见！</strong><br></center>]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=31607266&auto=0&height=66"></iframe>

<center><br><img src="/img/kobe0.jpeg" alt="kobe0"><br><strong>Legend! Forever!</strong><br></center><br>]]>
    
    </summary>
    
      <category term="远方与诗" scheme="http://leotse90.com/tags/%E8%BF%9C%E6%96%B9%E4%B8%8E%E8%AF%97/"/>
    
      <category term="随笔" scheme="http://leotse90.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告主要转化归因方式]]></title>
    <link href="http://leotse90.com/2016/04/09/mobile-advertising-attribution/"/>
    <id>http://leotse90.com/2016/04/09/mobile-advertising-attribution/</id>
    <published>2016-04-09T13:48:03.000Z</published>
    <updated>2016-04-12T16:01:56.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/creative_ad.jpg" alt="creative_ad"><br></center>

<a id="more"></a>
<h2 id="概述">概述</h2><p>在移动互联网广告圈子里，无论你是Publisher，或者Ad Network，还是Ad Tracker，你都有必要了解移动广告的转化归因方式。</p>
<p>了解移动归因方式，可以帮助你窥探移动广告从投放到转化中很重要的一环，那就是如何甄别广告转化的归属。我们知道主要的移动互联网广告种类有CPM、CPC、CPA，这些不同的广告类型在转化归因上大同小异，所以在介绍具体的归因方式的时候再行说明。</p>
<p>首先，一般有下面四种归因方式：  </p>
<blockquote>
<p>1.Google Install Referrer（Google 安装引荐网址）<br>2.Identifier Matching（标识符匹配）<br>3.Fingerprint Matching（指纹匹配）<br>4.Open URL with Click ID（带clickid的打开链接）</p>
</blockquote>
<p>Open URL with ClickID主要用于点击归因，并不适合于安装归因，因此不在我们的讨论范围内。接下来，我们详细讨论这几种归因方式的原理以及适用范围。</p>
<h2 id="Google_Install_Referrer">Google Install Referrer</h2><p>Google Install Referrer，我们在<a href="http://leotse90.com/2016/03/21/Mobile-Ad-GooglePlay/">移动广告之GooglePlay推广流程</a>有过介绍，这里简单说明一下，用户点击Google Play的推广URL安装的应用，GP会在该应用启动的时候发送一个Install Referrer广播告知其推广的来源，被推广的应用会上报该referrer到广告主后台，从而确定该转化的来源。</p>
<p>Google Install Referrer可以用来唯一标识广告商或者广告合作伙伴，这就是它可以用来确定转化的原因，有兴趣的话，你可以使用<a href="https://developers.google.com/analytics/devguides/collection/android/v3/campaigns#google-play-url-builder" target="_blank" rel="external">Google Play URL Builder</a>生成一个带referrer的推广URL，你可以了解一下其中每一个字段的用途（前提是你能翻墙）。下面是一个referrer的示例：<br><code>https://play.google.com/store/apps/details?id=com.test.appname&amp;referrer=af_tranid=com.test.appname_324a78c1-c345-5cba-7a76-bc88-aacb2318a101&amp;pid=clicksmob_int&amp;c=US-Android-01&amp;click_id=cA_12487526aa_278973188a866872ac981007bc8_zl&amp;af_siteid=1111&amp;advertising_id=yourgaid&amp;app-id=com.test.appname</code></p>
<p>Google Install Referrer主要适用于Google Play应用商店推广的APP，它不适用于Android上除GP以外的应用商店（这点不难理解），而且它也仅仅在APP安装的时候才有意义。</p>
<h2 id="Identifier_Matching">Identifier Matching</h2><p>Android平台上常见的广告标识符有GAID（Google广告ID，可以唯一标识一台Android设备，可重置）；GAID是一种由Google Play服务提供的唯一、用户特定可重置广告ID，它会以类似于38400000-8cf0-11bd-b23e-10b96e40000d的通用唯一标识符 (UUID) 格式公开用于访问字符串形式用户广告ID的API。如：<br><code>https://12345.api-01.com/serve?action=click&amp;publisher_id=100&amp;site_id=3000&amp;google_aid=38400000-8cf0-11bd-b23e-10b96e40000d</code><br>尽管我们最依赖广告标识符进行归因，但在某些情况下无法使用广告标识符。例如，不支持广告标识符以及用户从非 Google Android 应用商店下载的旧有版本。如果广告标识符不可用，我们还可以依赖以下设备标识符进行归因：Android ID（适用于Android设备的ANDROID ID是一个64位数字（十六进制字符串形式），在设备首次启动时随机生成，通常在设备生命周期内保持不变）、设备 ID（适用于Android设备的设备 ID 是一种采用小写格式值的唯一设备ID）、MAC地址（联网设备的MAC地址是一个网络地址，用于对设备的无线网络适配器进行唯一标识，采用以冒号分隔的大写形式，例如，“AA:BB:CC:DD:EE:FF”）。</p>
<p>iOS平台上的标识符主要就是IFA（可唯一标识一台iOS设备，但是也可以通过刷机重置）。Apple从iOS6开始引入了广告商标识符 (IFA)，它为应用提供用于为广告服务的标识符的访问权，并提供用以指示用户是否启用了Limit Ad Tracking（限制广告追踪）功能的标志。IFA 值是每台设备唯一的字母数字字符串，使用带连字符的大写形式。如：“AAAAAAAAA-BBBB-CCCC-1111-222222220000”。尽管我们最依赖广告标识符进行归因，但在某些情况下无法使用广告标识符。例如，不支持广告标识符的旧有版本。如果广告标识符不可用，我们依赖开放UDID进行归因，“开放 UDID”是iOS系统 UIDevice 类遭弃用的唯一标识符属性（又名 UDID）的简易替代者。它是一个长 40 个字符（20 个字节）的十六进制值。</p>
<p>标识符匹配的归因流程如下：<br>1.用户点击应用上的广告。一方面，用户设备会跳转到应用市场，另一方面，设备会向Tracker发送带有包含用户设备标识符的Ad Click URL；<br>2.用户点击安装广告上的应用后，应用会上报该用户设备标识符给Tracker；<br>3.Tracker对比点击时上传的用户设备标识符以及用户安装后上传的设备标识符，如果一致，就可以确定这个转化的来源。</p>
<p>Identifier Matching不仅适用于转化的归因，同样适用于点击事件、浏览事件等，它是适用范围最广的转化归因方式。</p>
<h2 id="Fingerprint_Matching">Fingerprint Matching</h2><p>要理解Fingerprint Matching转化归因，首先你得理解什么是Fingerprint，我们可以把Fingerprint理解为可以唯一标识一个用户的基本信息（尽管很多时候并不能真正唯一映射到一个确定的用户），它可以是用户的IP地址，也可以是用户设备的可用的HTTP头，这些基本信息可以用于归因分析中创建用户的点击事件的指纹。</p>
<p><strong>当一个用户安装了一个移动应用，植入在该应用的归因分析SDK就会收集该设备的指纹信息，然后上报到归因分析平台，平台会生成一个设备指纹并有序地在匹配的指纹中查找，归因分析平台会将转化算在匹配的所有指纹中最后一次带来点击上。</strong></p>
<p>默认情况下，匹配设备指纹的归因时间窗口是24小时，因此为了找到匹配，归因分析只会考虑24小时内发生的点击事件。当然也有一些广告网络和广告伙伴、媒体声称他们能将归因窗口扩展至48小时甚至72小时，但是实际上一旦超过24小时指纹匹配的统计的精度就会下降。</p>
<p>当一个用户点击一个广告跳转URL，归因分析SDK会设置其HTTP cookie，用于区分唯一点击数与Gross点击（理解为毛点击数），该cookie会在24小时后失效。<br>如果设备上没有设置cookie，归因分析SDK就会认定这个设备是一个从未记录在案的新设备，并记录这次点击为唯一点击和Gross点击；<br>如果设备上已经设置了cookie，归因分析SDK就会认为这是一个已经存在的用户（24小时内），于是只记录这次点击为一次Gross点击，而并不会记录其为唯一点击。</p>
<p>归因分析中会根据Gross点击和唯一点击去判断一个用户是新增还是已经存在。如果归因分析平台认定该用户是过去24小时已经存在的用户，那么平台就不会重新创建该用户的指纹，相反的，平台将会更新指纹的更新时间为最后一次点击的时间戳。因此，用户点击多次并不会创建额外的设备指纹，从而可以降低错误匹配数。</p>
<blockquote>
<p>关于Gross点击与唯一点击，举一个简单的例子：<br>用户A点击：广告1、广告2、广告1<br>用户B点击：广告1、广告3<br>那么：<br>广告1：2次唯一点击以及3次Gross点击；<br>广告2：1次唯一点击以及1次Gross点击；<br>广告3：1次唯一点击以及1次Gross点击。</p>
</blockquote>
<p>指纹匹配在移动应用后台中异步运行，此方法可强制打开浏览器，不会妨碍用户体验。由于使用另外的几种归因可提供1:1的准确性，而指纹匹配取决于统计概率（大约86%的统计概率），因此另外两种归因方法始终胜过指纹匹配。</p>
<h2 id="总结">总结</h2><p>以上三种转化归因方式都可以用于安装的归因，但是它们又各有差异，下图（来自网络）很好地展现了它们的适用场景以及差异：  </p>
<center><br><img src="/img/attributions_method.png" alt="attributions_method"><br></center>

<p>了解这些这三种转化归因的差异以及适用范围，可以帮助我们在实际中选取合适的转化归因方式进行归因确认。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/creative_ad.jpg" alt="creative_ad"><br></center>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何监测出Android推广渠道作弊？]]></title>
    <link href="http://leotse90.com/2016/03/31/How-to-detect-the-cheat-in-android-campaign/"/>
    <id>http://leotse90.com/2016/03/31/How-to-detect-the-cheat-in-android-campaign/</id>
    <published>2016-03-30T16:07:07.000Z</published>
    <updated>2016-03-31T01:14:13.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p><em><strong>本文整理自知乎，<a href="https://www.zhihu.com/question/22958167/answer/81144971" target="_blank" rel="external">如何监测出安卓推广渠道作弊？</a></strong></em>。<br><em><strong>文章比较系统地介绍了三个境界的防作弊手段，对于APP运营者有一定价值，同时对于广告渠道来说也有一定的意义。</strong></em></p>
<p>如何判断渠道的质量和狡猾程度,如何判断用户是否真实、是否来自墙、是否机刷or肉刷而来,是运营人员乃至整个公司最为头疼的事情,因为事关成本,而寒冬将至,成本则事关生死,不可谓不大。</p>
<p>那么我们如何识别真假用户,从而有效的管理渠道呢?从运营的角度,要是能根据上量的用户的综合价值来给渠道付费,那当然就是最佳策略。什么叫用户的综合价值,那就是该用户为公司创造出来的综合价值,价值包括但不限于:</p>
<blockquote>
<p>1) 直接利润价值:比如购买行为,产生收入和潜在的利润;<br>2) 内容价值:比如产生了积极的、优质内容,间接的创造价值等;<br>3) 传播价值:比如因为ta的传播,引发了其他用户的使用等等;<br>4) 衍生价值:停留时长或关注时长,所带来的广告收益等;</p>
</blockquote>
<p>每个App的行业不同,这四种价值侧重不同。<br>因为按照激活这个时间作为结算的时间节点对我们来说,这个时间窗口太短,对甄别用户的真假带来巨大的挑战。<br>在这个巨大的挑战面前,就分化出作弊防护的不同境界。<br><a id="more"></a></p>
<h3 id="第一个境界——事后诸葛亮,事前猪一样">第一个境界——事后诸葛亮,事前猪一样</h3><p>稍微量化一下这个境界,发现作弊的时间需要7天以上,能感知到40%左右的假量用户,其他超过半数的作假不能确保;通俗的讲,知道自己被骗了,但不知道骗了多少。他们的手段一般是这样的:</p>
<p>(一) 看留存率<br>根据长期的斗争经验,他们发现渠道刷量会选择在次日、7日、30日这些重要时间点上导入用户数据。然后发现App在次日、7日、30日这些关键时间点上的数据明显高于其他时间点。而真实的用户的留存曲线是一条平滑的指数衰减曲线,如果他们发现留存曲线存在陡升陡降的异常波动,基本上就是渠道干预了数据。</p>
<p>(二) 看用户终端信息<br>1) 低价设备排名<br>根据经验分析渠道的新增用户或者启动用户的设备排名。如果发现某款低价设备排名异常靠前,他们就视其为异常,开始报警。</p>
<p>2) 新版本操作系统的占比<br>经过渠道多年蹂躏,运营人员终于发现,很多渠道刷量工作室在操作系统版本的适配上会有延时。查看渠道用户的操作系统时,可以和全体手机网民的操作系统的分布做比较。</p>
<p>3) wifi 网络的使用情况<br>比如说2G、3G、4G的使用比例分布是否正常等等。</p>
<p>(三)看延伸信息<br>1) 注册昵称的分布和规律,很多低端的刷假量的注册昵称有很强的规律性,各位运营看官肯定遇到这样的情况;<br>2) 注册手机号码的归属地分布,这点相比各位看官也遇到过,某个渠道上来的用户手机号码不但来自某运营商的某个地市,甚至都是连号手机号码。</p>
<p>小结:该境界中的运营者严重依赖于个人经验,工具手段不专业化,操作效率低下,耗费人力物力,但发现问题时间滞后,而且稍微高级一点的作弊行为不能被发现。</p>
<h3 id="第二个境界——亡羊补牢,损失在所难免">第二个境界——亡羊补牢,损失在所难免</h3><p>在这个段位的选手,甄别出真假的时间周期大概是2-7天之间,识别出来的假量大概在40%-70%之间,通俗的讲,他们可以比较确定性的识别出很大一部分假量用户,如果商务条件比较给力的话,是可以控制损失范围的。之所以有这样的效果是因为他们采用了一些专业的手段:</p>
<p>(一) 单个指标<br>1) IP:是否为黑名单IP、是否为代理IP,跟一个巨大的黑名单库进行比对;<br>2) IMEI:是否为黑名单IP;<br>3) 手机号码:号码是否非法,是否在黑名单;</p>
<p>(二) 群体指标<br>1) IP:用户IP的地域分布是否符合先验数据的分布,地域包括国内的省份分布和海外市场的分布;<br>2) IMEI:用户IMEI号的地域分布是否符合先验数据的分布,IMEI所代表的制造商的分布是否随机;<br>3) OS:该渠道操作系统版本的分布情况是否符合一定的随机性和统计性,并与之前的先验数据进行对比判断;<br>4) 机型:机型分布是否符合先验数据,以及最新智能手机出货量的比例;<br>5) 位置信息:位置信息打开的比例,以及获取到位置信息的地域分布比例是否符合先验数据的分布,是否符合渠道承诺的地域情况,是否符合应用的实际分布情况;<br>6) 运营商:运营商的数据分布是否随机,是否符合国内运营商的正常分布,以及海外运营商的随机分布;<br>7) 网络接入方式:wifi、2G、3G、4G的分布比例是否与先验数据保持同样的趋势和数据特征;</p>
<p>(三) 信息一致性:<br>设备一致性的验证,包括:CPU、制造商、Mac地址、IMEI、机型、操作系统的一致性验证。<br>一般而言,通用的统计分析工具是实现不了上述的分布,这就需要用专业的作弊防护软件或安全软件来。<br>这个境界的运营者已经摆脱了手工处理,依赖个人经验的阶段,而是走上了算法和数据的专业化路线,但问题是每家的算法能力和数据积累参差不齐,因此在效果上各家能力差异很大,而渠道反过来猜测各个运营者的能力的强弱,来给他们掺不同比例的假量。</p>
<h3 id="第三个境界——当下即断,零损失可以期待">第三个境界——当下即断,零损失可以期待</h3><p>在这个段位的选手,甄别用户的真假所需时间从15分钟到30分钟,如果是时间窗口延伸到24小时,那么他们的把握将更大。那么他们是如何做到的呢?总结一句话就是:软硬兼施,进攻是最好的防守!</p>
<p>(一) 硬手段:<br>所谓硬手段就是在用户端的硬件上下功夫下手段,进驻在用户硬件设备上的SDK主动进行探嗅,探测硬件环境的变化、操作系统环境的异常、以及各种应用接口是否被劫持。第一时间得到用户智能设备的状态。当该用户的手机硬件及其系统环境出现异常时,立刻在后台对该用户的所有数据进行缜密的审核,1)追踪其IP及端口的状态,以及IP的历史行为;2)追踪其IMEI以及IMSI的对应关系,IMEI和IMSI基本可以理解为一把钥匙一把锁的对应,伪造一个IMEI号容易,但要想连同IMSI一同伪造,这个成本就变得奇高无比。而整个过程可以控制在15-30分钟,为跟渠道斗(si)争(bi)赢得充分时间窗口。</p>
<p>(二) 软手段:<br>在第二境界的基础上,他们通过长期的数据积累和研究发现:各个指标反馈出来的信息强弱不同,因此对所有的指标进行赋值,并让这些指标对该群用户做作弊投票,当累计值超过阀值时,宣布该用户为可疑用户。这样就可以完成了在24小时内对用户真假的补充判断。</p>
<p>要达到这个水平,不仅需要长期大量的数据积累和与时俱进的更新,还要有强大的数据处理算法和软硬通吃的技术实力。</p>
<p><strong>作者</strong>：古婆<br><strong>链接</strong>：<a href="https://www.zhihu.com/question/22958167/answer/81144971" target="_blank" rel="external">点击这里</a><br><strong>来源</strong>：知乎<br><strong>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</strong> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p><em><strong>本文整理自知乎，<a href="https://www.zhihu.com/question/22958167/answer/81144971">如何监测出安卓推广渠道作弊？</a></strong></em>。<br><em><strong>文章比较系统地介绍了三个境界的防作弊手段，对于APP运营者有一定价值，同时对于广告渠道来说也有一定的意义。</strong></em></p>
<p>如何判断渠道的质量和狡猾程度,如何判断用户是否真实、是否来自墙、是否机刷or肉刷而来,是运营人员乃至整个公司最为头疼的事情,因为事关成本,而寒冬将至,成本则事关生死,不可谓不大。</p>
<p>那么我们如何识别真假用户,从而有效的管理渠道呢?从运营的角度,要是能根据上量的用户的综合价值来给渠道付费,那当然就是最佳策略。什么叫用户的综合价值,那就是该用户为公司创造出来的综合价值,价值包括但不限于:</p>
<blockquote>
<p>1) 直接利润价值:比如购买行为,产生收入和潜在的利润;<br>2) 内容价值:比如产生了积极的、优质内容,间接的创造价值等;<br>3) 传播价值:比如因为ta的传播,引发了其他用户的使用等等;<br>4) 衍生价值:停留时长或关注时长,所带来的广告收益等;</p>
</blockquote>
<p>每个App的行业不同,这四种价值侧重不同。<br>因为按照激活这个时间作为结算的时间节点对我们来说,这个时间窗口太短,对甄别用户的真假带来巨大的挑战。<br>在这个巨大的挑战面前,就分化出作弊防护的不同境界。<br>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告之广告平台选择（Admob&Facebook）]]></title>
    <link href="http://leotse90.com/2016/03/22/Mobile-AD-Admob-Integration/"/>
    <id>http://leotse90.com/2016/03/22/Mobile-AD-Admob-Integration/</id>
    <published>2016-03-22T15:13:46.000Z</published>
    <updated>2016-03-23T00:46:22.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/facebook-money.jpeg" alt="facebook-audience-network"><br></center>

<p>现在的出海的移动互联网公司，实现变现一般都是两种途径(国内的变现途径也一样，但是不在今天的讨论范围内)：广告变现，APP内购。游戏一般依赖应用内消费（也有一些游戏通过广告进行变现），而剩下的很多非游戏类应用主要靠广告变现，比较具有代表性的有：CleanMaster、APUS、Kika等工具类产品，根据猎豹移动最新发布的2015年财报，它的海外移动营收中有95%来自于移动广告。<br><a id="more"></a><br>要实现广告变现，就需要有广告来源，一般的国内的公司出海变现需要依赖第三方广告平台，当然，也有些有实力的公司自己做广告平台。现在海外主要的广告平台有Admob、Facebook、Mopub、IronSource、DoubleClick等等，国内的像猎豹移动也正在推出自己的广告平台猎户系统，Kika也推出了自己的广告平台Koala。但是如果你只是一般的应用开发者致力于海外市场应用开发，那么推荐你主要依赖Admob与Facebook这两家进行商业变现就可以了。毕竟接广告不仅依赖于一个比较强大的商务团队，还需要具备一定的平台搭建能力。</p>
<h2 id="Admob_&amp;_Facebook_广告SDK实施">Admob &amp; Facebook 广告SDK实施</h2><p>哪怕是强如猎豹移动这种出海的先驱，它拥有自己的广告平台，但是它们的主要广告营收还是依赖于Facebook。Facebook Audience Network提供了CPC、CPI、CPM等丰富的广告资源，而且可以根据Facebook的用户的信息进行广告的精准投放，这种精准投放的前提条件也让Facebook广告填充率不够，因为它只能在安装了Facebook的机器上进行广告活动，考虑到国外Facebook的覆盖率，一般来说，Facebook的广告填充率能达到80%－90%。而Admob依靠Google，拥有海量的广告资源，而且Google Play几乎霸占了海外的应用市场份额，因此它在广告界的地位也是无可撼动。</p>
<p>要想通过Facebook和Admob进行变现，实施起来也十分方便，它们都提供了各自的广告SDK，只需要在他们的平台上申请Ad Unit ID即可轻松实现广告创收。下面是两家的实施示例代码，非常简单：<br>Admob实施代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String admobAdUnitId = <span class="string">"ca-app-pub-1301877944976160/5685349534"</span>;</span><br><span class="line">AdLoader.Builder adBuilder = <span class="keyword">new</span> AdLoader.Builder(context, admobAdUnitId);</span><br><span class="line"></span><br><span class="line">adBuilder.forAppInstallAd(<span class="keyword">new</span> NativeAppInstallAd.OnAppInstallAdLoadedListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppInstallAdLoaded</span><span class="params">(NativeAppInstallAd nativeAppInstallAd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AdLoader adLoader = adBuilder.withAdListener(<span class="keyword">new</span> AdListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdFailedToLoad</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br><span class="line"></span><br><span class="line">AdRequest adRequest = <span class="keyword">new</span> AdRequest.Builder().build();</span><br><span class="line">adLoader.loadAd(adRequest);</span><br></pre></td></tr></table></figure></p>
<p>Facebook Audience Network实施代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String facebookAdUnitId = <span class="string">"1605000876745596_1688342111425188"</span>;</span><br><span class="line"></span><br><span class="line">mFacebookNativeAd = <span class="keyword">new</span> com.facebook.ads.NativeAd(mContext, facebookAdUnitId);</span><br><span class="line"></span><br><span class="line">mFacebookNativeAd.setAdListener(<span class="keyword">new</span> AdListener() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Ad ad, AdError adError)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdLoaded</span><span class="params">(Ad ad)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ad loaded</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdClicked</span><span class="params">(Ad ad)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mFacebookNativeAd.loadAd();</span><br></pre></td></tr></table></figure></p>
<p>具体的实施可以参考它们的官网。</p>
<h2 id="Admob聚合Facebook优化">Admob聚合Facebook优化</h2><p><center><br><img src="/img/facebook-ad.jpg" alt="facebook-ad"><br></center><br>如前所说，一般你只要集成这两家的SDK就可以轻松变现，但是这也存在一些问题，比如：1.Facebook可以精准投放但是填充率不及Admob，应该怎么优化？2.两家的广告如果都能填充，如何进行抉择？</p>
<p>Admob提供了比较完善的解决方案，那就是SDK集成SDK，你可以在使用Admob SDK时集成Facebook Audience Network，并且可以在Admob后台进行设置，进行广告效果的调优。</p>
<p>Admob其实可以集成非常多的第三方广告平台，但是效果最好的要数Facebook。Admob集成的优势在于它提供了一种竞价模式。据了解，Admob的竞价有两种：</p>
<p>一种就是InMobi那种，Admob和Inmobi后台已经打通，可以互通有无，Admob知道Inmobi的实时eCPM，因此总是能返回eCPM高的广告给调用方；<br>另一种就是Facebook这种，Admob并不知道Facebook的实时eCPM，但是我们可以在Admob后台设置一个Facebook的eCPM阀值，比如我们在Admob上为Facebook的eCPM设置阀值为15，那么广告填充就会出现三种情况：  </p>
<blockquote>
<p>1）Facebook没有广告返回，直接返回Admob的广告，广告的eCPM就是Admob的平均eCPM；<br>2）Facebook有广告返回，但是Admob返回的广告eCPM大于Facebook预设的阀值，这里是15，那么返回Admob的广告，此时广告的eCPM会高于预设阀值；<br>3）Facebook有广告返回，但是Admob返回的广告eCPM小于Facebook预设的阀值，那么就会使用Facebook返回的广告，此时广告的eCPM就会是你在Facebook平台上的平均eCPM。</p>
</blockquote>
<p>由此可以看出，<strong>要想实现收益最大化，我们应该适当调高在Admob后台设置的Facebook eCPM阀值，并在Facebook后台将广告设置偏向“价格优先”。</strong>在我们的产品上，Facebook的eCPM经验阀值为15，整体收益最高。实际情况需要实施者不断观察不断调整，从而达到整体最优。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/facebook-money.jpeg" alt="facebook-audience-network"><br></center>

<p>现在的出海的移动互联网公司，实现变现一般都是两种途径(国内的变现途径也一样，但是不在今天的讨论范围内)：广告变现，APP内购。游戏一般依赖应用内消费（也有一些游戏通过广告进行变现），而剩下的很多非游戏类应用主要靠广告变现，比较具有代表性的有：CleanMaster、APUS、Kika等工具类产品，根据猎豹移动最新发布的2015年财报，它的海外移动营收中有95%来自于移动广告。<br>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动广告之GooglePlay推广流程]]></title>
    <link href="http://leotse90.com/2016/03/21/Mobile-Ad-GooglePlay/"/>
    <id>http://leotse90.com/2016/03/21/Mobile-Ad-GooglePlay/</id>
    <published>2016-03-21T15:22:01.000Z</published>
    <updated>2016-03-21T16:01:36.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/google-play.png" alt="google-play"><br></center>

<p>在进行移动应用推广的时候，大多数公司会根据不同需求选择不同的渠道进行推广。比如，国内的应用冲榜（也就是刷排名，这时候的一般的目的是进行融资前的造势）的时候，会找网盟进行推广，网盟推广的优点是刷量快、成本低；另外如果是应用推广（目的纯粹），那么会找一些比较专业的广告平台进行广告投放，海外的主要有Adwords、Admob、Facebook等等，相比于网盟，这些广告平台的成本高，但是产品的留存高。一般情况，我们在网盟上推广成本单个价格为Facebook等平台的一半，但是留存也只有后者的一半以下。<br><a id="more"></a><br>我们这里要介绍的是Google Play上的应用推广，这里的推广并不是指策略（广告素材本地化、借助于GA数据化运营等等），而是介绍了其推广的流程。</p>
<h2 id="GooglePlay推广流程">GooglePlay推广流程</h2><p>我们首先使用Google Play URL Builder生成推广链接，Google developers上会有详细的参数说明，这里不再赘述。</p>
<p>接下来重点介绍用户从点击推广链接到确认安装的流程：<br>1.<strong>用户点击推广链接</strong>：推广链接可以呈现在WEB页面或者APP的广告中，这时候，如果正常跳转，用户会跳转到Google Play的该应用下载页面；<br>2.<strong>用户下载安装应用</strong>：用户在GP上下载安装应用后，GP会发送一个广播，该广播中包含的是推广链接的相关参数；<br>3.<strong>应用上报推广数据</strong>：下载的应用会在收到2中发送的广告后，在适当的时候上报收到的推广参数；   </p>
<p>我们解读一下上述的流程，一般情况下，用户都会跳转到Google Play网页或者Google Play应用商店，国内的大部分手机都进行了“纯净”，因此可能会跳转到网页或者手机上自带的应用商店。</p>
<p>Google Play在用户安装应用后，通过Intent发送一个广播INSTALL_REFERENCE，关于INSTALL_REFERENCE，需要注意：  </p>
<blockquote>
<p>在Android 3.1（API 12）之前，INSTALL_REFERENCE在应用安装后发送；<br>Android 3.1之后，INSTALL_REFERENCE变为在应用第一次启动时发送。  </p>
</blockquote>
<p>这是因为Android 3.1以后引入了停止状态，而<strong>只有非停止状态的APP才能收到INSTALL_REFERENCE广播</strong>。<br>同时，INSTALL_REFERENCE只会发送给指定的通过推广安装的应用。从网页到应用是无法发送INSTALL_REFERENCE的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<center><br><img src="/img/google-play.png" alt="google-play"><br></center>

<p>在进行移动应用推广的时候，大多数公司会根据不同需求选择不同的渠道进行推广。比如，国内的应用冲榜（也就是刷排名，这时候的一般的目的是进行融资前的造势）的时候，会找网盟进行推广，网盟推广的优点是刷量快、成本低；另外如果是应用推广（目的纯粹），那么会找一些比较专业的广告平台进行广告投放，海外的主要有Adwords、Admob、Facebook等等，相比于网盟，这些广告平台的成本高，但是产品的留存高。一般情况，我们在网盟上推广成本单个价格为Facebook等平台的一半，但是留存也只有后者的一半以下。<br>]]>
    
    </summary>
    
      <category term="移动广告" scheme="http://leotse90.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%BF%E5%91%8A/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广告有效性原理]]></title>
    <link href="http://leotse90.com/2016/03/02/ad-effective-theory/"/>
    <id>http://leotse90.com/2016/03/02/ad-effective-theory/</id>
    <published>2016-03-01T17:00:35.000Z</published>
    <updated>2016-03-02T00:33:22.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<p>广告有效性原理用于描述广告从产生，到达用户以至于最后的转化行为的整个过程。整个模型主要包含三个阶段：选择、解释、态度。这三个名词初看起来有点难以理解，接下来会逐个解释这三个阶段。</p>
<h2 id="选择(selection)">选择(selection)</h2><p>选择主要包含两个子阶段：<strong>曝光阶段(exposure)</strong>与<strong>关注阶段(attention)</strong>。  </p>
<p>这个阶段主要是将广告带入受众的视线。所以这个阶段也可以理解为到达用户阶段。</p>
<h3 id="曝光阶段(exposure)">曝光阶段(exposure)</h3><p>广告展现出来的阶段。这一阶段拼的是广告位的曝光度，广告位对广告的效果起着决定性的作用。比如百度搜索广告，北区的曝光度比南区和东区都高，这是由产品本身决定的，如下图所示：<br><a id="more"></a></p>
<center><br><img src="/img/baidu-search-ad.png" alt="baidu-search-ad"><br></center>

<p>这张图上展示了百度搜索广告的北区广告和东区广告，我们明显可以知道北区的广告相比于东区更容易被用户浏览，更别提底部的南区广告了，这种差距不是一些技术上的优化就能抹平的。</p>
<h3 id="关注阶段(attention)">关注阶段(attention)</h3><p>如果说曝光阶段是广告进入受众视线可达到的一步，那么关注阶段则是广告被受众发现的过程。举个例子，大部分的公交站都有广告牌，比如说即将上映的电影，或者是刚推出的电子产品等，它的出现就是曝光阶段，但是只有某一天你被它吸引驻足停留，才算是进入了关注阶段。</p>
<center><br><img src="/img/bus-station-ad.jpg" alt="bus-station-ad"><br></center>

<p>如果说曝光阶段靠的是先天条件，那么关注阶段的效果就能靠后天努力了（当然先天优势依然很关键）。比如丰富的广告创意，或者符合潜在目标人群的兴趣爱好等，都能提升关注阶段的效果。</p>
<p>这个阶段，有几个重要的原则：</p>
<blockquote>
<p>1.尽量不要打断用户的任务；<br>2.明确传达向用户推送广告的原因；<br>3.内容符合用户的兴趣或需求。</p>
</blockquote>
<p>这三点原则在实际实施中很有用，尤其是CPC和CPM的广告。关于第一个原则，有一个实际的例子，笔者所在公司有一款输入法产品，曾经在用户输入某个关键字的时候弹出符合该条件的广告或内容（现在百度输入法还在这样做），但是效果不理想，反而GP上指责不断，这个idea不久就夭折了，因为用户使用输入法一般在聊天或者其他记录查询操作，如果这个时候强行打断用户插入广告，牺牲了产品体验的同时并没有提升广告效果。而第二个原则Amazon很好地贯彻了，Amazon的推荐商品下方一般都有推荐的理由，这样对用户来说，广告出现得并不突兀，反而会让人觉得这是非常合理人性化的商品推荐。</p>
<center><br><img src="/img/amazon-recommend-ad.png" alt="amazon-recommend-ad"><br></center>

<p>第三个原则可以根据用户的兴趣爱好及需求（问卷调查、数据挖掘、用户行为分析等手段），比较精准地推荐广告，这个原则要执行起来技术难度较大，但是一旦实施效果将会非常明显。</p>
<h2 id="解释(interpretation)">解释(interpretation)</h2><p>“解释”这个阶段需要解释一下，这个“解释”主要是广告投放方向广告受众讲明来意并被潜在受众理解和接受的阶段。它主要包含理解阶段(comprehension)和接受阶段(acceptance)。</p>
<h3 id="理解阶段(comprehension)">理解阶段(comprehension)</h3><p>这个阶段的主要目标是让用户明白他关注到的广告的用意，并理解广告所传达的信息。这个通俗地讲就是用户理解了这个广告是干嘛的，香烟广告观众看完要知道这个广告的产品是烟草而不是打火机，食品广告就要让用户知道这是在卖吃的。</p>
<p>这个阶段也有两个原则：</p>
<blockquote>
<p>1.广告内容要在用户能理解的具体兴趣范围内；<br>2.设定与关注程度相匹配的理解门槛。</p>
</blockquote>
<p>这两个原则恐怕也是需要解释一下的，第一个原则的前提是广告投放人群定向，而这两个原则都在指引我们在设计广告和投放广告时尽量找到它对应的潜在受众。</p>
<h3 id="接受阶段(acceptance)">接受阶段(acceptance)</h3><p>广告受众看到了，关注了，也读懂了，但是如果不被用户接受，那么也是前功尽弃。在接受阶段，除了广告的投放需要尽量精准外，还需要注意广告的形式，广告不要过度影响或妨碍用户。比如一个小孩在使用APP的时候，浏览到一则根据他兴趣推荐的最新游戏的广告，但是广告内容却是充满性暗示的美女图片，我们假设小孩还和以前一样是比较单纯的群体，那么这种广告反而会起到负面效果。</p>
<p>接受，就是合适的广告在合适的时机出现在合适的位置。</p>
<h2 id="态度(attitude)">态度(attitude)</h2><p>前面的解释阶段注重的是广告投放方向广告的受众传递信息，那么这个“态度”阶段就是广告受众向广告投放方表明自己立场的过程。</p>
<h3 id="保持阶段(retention)">保持阶段(retention)</h3><p>这个阶段主要是针对品牌广告。品牌广告商希望自己的广告能比较持久的“保持”在受众的脑海里，以期在未来较长的一段时间里都能影响用户的选择。</p>
<h3 id="决策阶段(decision)">决策阶段(decision)</h3><p>这是广告的最终目的，品牌广告希望你记住广告商并在商场选购中不假思索地选择他们的产品，游戏应用安装类广告希望你下载他们的游戏并沉浸其中，公益广告希望你能遵循教导爱国孝顺礼貌勤劳等等。</p>
<p>决策是整个广告行为的收官阶段，也是评判广告是否有效的重要指标。</p>
<blockquote>
<p>广告没有专业可言，只有成功可言。</p>
</blockquote>
<p>是的，广告的世界就是直白。没有广告主会把注意力集中在广告是否丰富专业，他们的需求只有一个：看到广告的用户行动起来！</p>
<blockquote>
<p>对于互联网广告，越靠前的阶段，其效果的改善对点击率的贡献就越大；而越靠后的阶段，其效果的改善对转化率的贡献就越大。</p>
</blockquote>
<p><strong>关于广告有效性原理，虽然看起来理论气息很浓，但是它的“曝光”绝不只是希望得到我们的“关注”，而是需要我们“理解”并“接受”它的意旨，然后能“保持”在每一个广告人的脑海中并帮助我们在工作中做出更有用的“决策”！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<p>广告有效性原理用于描述广告从产生，到达用户以至于最后的转化行为的整个过程。整个模型主要包含三个阶段：选择、解释、态度。这三个名词初看起来有点难以理解，接下来会逐个解释这三个阶段。</p>
<h2 id="选择(selection)">选择(selection)</h2><p>选择主要包含两个子阶段：<strong>曝光阶段(exposure)</strong>与<strong>关注阶段(attention)</strong>。  </p>
<p>这个阶段主要是将广告带入受众的视线。所以这个阶段也可以理解为到达用户阶段。</p>
<h3 id="曝光阶段(exposure)">曝光阶段(exposure)</h3><p>广告展现出来的阶段。这一阶段拼的是广告位的曝光度，广告位对广告的效果起着决定性的作用。比如百度搜索广告，北区的曝光度比南区和东区都高，这是由产品本身决定的，如下图所示：<br>]]>
    
    </summary>
    
      <category term="广告杂谈" scheme="http://leotse90.com/tags/%E5%B9%BF%E5%91%8A%E6%9D%82%E8%B0%88/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中线程的异常处理]]></title>
    <link href="http://leotse90.com/2016/03/01/Java-exception-thread/"/>
    <id>http://leotse90.com/2016/03/01/Java-exception-thread/</id>
    <published>2016-02-29T16:47:23.000Z</published>
    <updated>2016-02-29T16:52:15.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="异常处理">异常处理</h2><p>异常，在程序出现的非正常状态；异常处理机制，就是程序语言针对这些异常状态采取的处理措施。当程序出现异常的时候，程序会暂停运行，并且程序的控制权会转交给异常处理器。</p>
<p>在Java中，我们有一套比较完善的异常处理机制。下面是Java中异常的一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception1 exception1)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception1 throws</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 exception2)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception2 throws</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// do this no matter what happened</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常主要分类">异常主要分类</h3><p>在Java中（Android一样），异常的基类是<code>Throwable</code>，而我们平时所看到的<code>Error</code>以及<code>Exception</code>都继承自<code>Throwable</code>。<br><a id="more"></a></p>
<center><br><img src="/img/java-exception.jpg" alt="java-exception"><br></center>

<p>而<code>Error</code>指的是Java在运行时系统中的内部错误或者资源不够等情况，问题一般较严重；对于<code>Error</code>，程序除了尽快全身而退外，其他什么都做不了。程序也不应该抛出<code>Error</code>对象，它一般是由JVM抛出；<br>相较于<code>Error</code>，<code>Exception</code>就温顺多了，我们一般情况下可以在代码中预测<code>Exception</code>的发生并对症下药，提前编写好异常处理的代码。</p>
<p><code>Exception</code>包括运行时异常（<code>RuntimeException</code>）以及非运行时异常，运行时异常主要包括类型转换异常、数组越界、空指针等；</p>
<blockquote>
<p>运行时异常，都是程序员的错。</p>
</blockquote>
<p><strong>非运行时异常</strong>，又叫编译异常，一般是外部错误，这些并不是程序本身的问题，而是在环境外部出现的异常，最常见的就是<code>IOException</code>，当程序想要读取或者写入一个不存在文件时，就会抛出<code>IOException</code>。从程序语法角度讲<strong>非运行时异常是必须处理的异常，否则程序就不能编译通过</strong>。</p>
<p><strong>运行时异常</strong>：都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException</code>(空指针异常)、<code>IndexOutOfBoundsException</code>(下标越界异常)等，程序中可以选择catch处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<strong>运行时异常的特点是Java编译器不会检查它</strong>，也就是说，当程序中可能出现这类异常，即使没有用try catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<p><strong><code>Error</code>和<code>RuntimeException</code>及其子类统称为unchecked异常，而其他称为checked异常（要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过）。<code>Exception</code>能被程序本身可以处理，<code>Error</code>是无法处理。</strong>。</p>
<center><br><img src="/img/java-exception2.jpg" alt="java-exception"><br></center>

<h3 id="异常处理流程">异常处理流程</h3><p>Java中，异常的主要处理流程如下：<br>1.代码块遇到异常，当前代码块停止运行，程序也随之暂停运行，程序控制权转移给异常处理器；<br>2.异常处理器开始搜索有没有能够处理当前异常的处理器，如果有，则执行处理器中的代码；如果没有，则抛出异常给当前代码块的调用方；<br>3.接收到抛出异常的代码块会重新经历以上1，2的步骤，如果没有合适的处理器，继续往上层抛出异常；<br>4.如果异常抛到程序入口仍然没有处理，则将异常抛给JVM；</p>
<center><br><img src="/img/exception-flow.jpg" alt="exception-flow"><br></center>

<h2 id="线程的异常处理">线程的异常处理</h2><p>1.线程可以抛出异常<br>这是一个基本事实，我们可以在线程中抛出一个异常，当前线程会中断，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Sub thread is running..."</span>);</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sub thread is running...</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-0"</span> </span><br><span class="line">java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">	at com<span class="class">.leotse</span><span class="class">.thread</span><span class="class">.MyThread</span>$<span class="number">1</span>.<span class="function"><span class="title">run</span><span class="params">(MyThread.java:<span class="number">10</span>)</span></span></span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是，我们不能直接在Override的run方法声明时直接抛出异常，如<code>public void run() throws Exception{...}</code>，Java会提示你<code>Exception is not compatible with throws clause in Runnable.run()</code>。</p>
<p>2.主线程能否捕捉子线程的异常<br>首先，我们需要明确一点，线程的run()方法定义了子线程的边界，也就是说，一个线程中的逻辑再怎么运行也不能超越其run()方法。这就明确了</p>
<blockquote>
<p>线程代码不能抛出任何checked异常，所有的线程中的checked异常都只能被线程本身消化掉。线程本身就是被看作独立的执行片断，它应该对自己负责，所以由它来消化所有的checked异常是很正常的。</p>
</blockquote>
<p>上面说的一直是checked异常，那么unchecked异常是不是不一样？对于unchecked异常中的<code>Error</code>我们显然无能为力，但是对于另外一部分－<code>RuntimeException</code>我们能否处理？我们看下面一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"Sub thread is running..."</span>);</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Sub thread throws an exception..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Main thread is running..."</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果Main thread能捕捉到子线程的运行时异常（前面讲过，属于unchecked异常），那么<code>Sub thread throws an exception...</code>就会被打印出来（即能被catch住），运行结果如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sub thread is running..<span class="class">.Exception</span> <span class="keyword">in</span> thread <span class="string">"Thread-0"</span> </span><br><span class="line">Main thread is running...</span><br><span class="line">java<span class="class">.lang</span><span class="class">.RuntimeException</span></span><br><span class="line">	at com<span class="class">.leotse</span><span class="class">.thread</span><span class="class">.MyThread</span>$<span class="number">1</span>.<span class="function"><span class="title">run</span><span class="params">(MyThread.java:<span class="number">12</span>)</span></span></span><br><span class="line">	at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果显示有点乱，但是我们仍然可以看到，<code>Sub thread throws an exception...</code>这句话并没有打印出来，因此说明在这里我们的MainThread并没有捕捉到子线程抛出的unchecked异常。</p>
<blockquote>
<p>线程方法的异常只能自己来处理。</p>
</blockquote>
<p>更多关于异常的知识：<br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/" target="_blank" rel="external">Java 异常处理的误区和经验总结</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="异常处理">异常处理</h2><p>异常，在程序出现的非正常状态；异常处理机制，就是程序语言针对这些异常状态采取的处理措施。当程序出现异常的时候，程序会暂停运行，并且程序的控制权会转交给异常处理器。</p>
<p>在Java中，我们有一套比较完善的异常处理机制。下面是Java中异常的一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception1 exception1)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception1 throws</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 exception2)&#123;</span><br><span class="line">    <span class="comment">// do something when Exception2 throws</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// do this no matter what happened</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常主要分类">异常主要分类</h3><p>在Java中（Android一样），异常的基类是<code>Throwable</code>，而我们平时所看到的<code>Error</code>以及<code>Exception</code>都继承自<code>Throwable</code>。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对不起，我是一名广告人]]></title>
    <link href="http://leotse90.com/2016/02/14/I-am-Adman/"/>
    <id>http://leotse90.com/2016/02/14/I-am-Adman/</id>
    <published>2016-02-14T15:23:22.000Z</published>
    <updated>2016-02-15T05:49:59.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<blockquote>
<p>不做总统就做广告人。<br>I am Adman.</p>
</blockquote>
<p><center><br><img src="/img/protect-yourself.jpg" alt="protect-yourself"><br></center><br><a id="more"></a></p>
<h2 id="广告开发也是广告人">广告开发也是广告人</h2><p>Adman，坊间称之为广告人，一般指的是那些为甲方客户产品进行广告营销策划与设计的专业人士。他们的主要工作内容是在接到用户的需求后，分析用户的产品，为之实现行之有效的推广创意，从而促进用户产品的销量（这类广告最为常见，CPA广告等等），或提高用户品牌的知名度（主要有品牌广告），又或者达到用户所需要宣传的效果（比如公益广告）。</p>
<p>那么，作为一名非纯正的publisher的互联网公司广告团队中一名开发人员，何以敢称自己为一名广告人呢？</p>
<p>不只是广告的搬运工。你看我现在每天的主要工作是将服务端的广告数据分发到客户端并追踪广告效果，说得不给面子一点，就是一名广告创意的搬运工，默默地将别人设计的广告创意从广告主或者ADX等来源搬运到用户的手机应用里。但是我不服！手握着无数同行们精心设计的成果，将其最终展现在潜在的用户面前，这俨然是广告创意从降世到大展拳脚中非常关键的一环，我不仅仅是搬运工，无论多么劲爆、多么attractive的广告创意（广告人视角），都必须被市场检验才能算得上真正的牛X。伟大的革命导师教导我们：<strong>一切不被用户接受的广告创意都是纸老虎！</strong></p>
<p>直接面向用户。当时，用户的手指离我的广告创意只有0.01公分，四分之一秒后这位用户将深深地爱上我，“你的手指从我的身上划过去吧”。广告人一直都说广告的创意往往不是来自于灵光乍现而是来源于生活，来源于群众。而我们广告开发所做的一切就是要这些广告创意回到群众中去，特别是回到那些需要广告的群众中去，在广告行业里，我们坚持贯彻<strong>从群众中来，到群众中去</strong>的方针。</p>
<p>数据，数据，数据。与其说现在是移动互联网时代，不如说现在是移动数据时代。多少大佬叫嚣着21世纪最重要的财富是数据。在广告行业里，数据的重要性也是毋庸置疑的，我们可以通过广告数据分析广告创意的效果，我们可以通过数据调整广告投放的策略，我们还可以通过数据更精准地投放广告。数据可以为广告插上翅膀，而这些数据怎么来？怎么分析？分析后怎么调整怎么投放？这些就又回到我们广告开发的老本行了。</p>
<p>这三点理由已经足够说明，广告人的人口组成里还有我们这些任劳任怨、面朝电脑背朝天的广告开发们！</p>
<h2 id="做广告，就要大大方方的做">做广告，就要大大方方的做</h2><p>广告为什么会在很多用户心中称为与老鼠、蟑螂并称新时代“三害”？一个主要原因是广告的滥投。打开电视是广告，网上看电影前面强制看75s广告、打开一个网页也是各种设计诡异点击关闭却打开满屏飘忽不定神出鬼没的广告，好不容易没经住广告上的美人计诱惑点进去结果是个诈骗网站，玩个手机APP也弹出一堆广告，就算你走到大街上，你还是躲不过一张张塞过来的小卡片广告。广告貌似无处不在，它潜伏在我们的周围，时不时就冒出来抢占我们的注意力，破坏我们的美丽心情。这种广告当然神烦，它们的背后黑手当然是广告人。但是少林寺还有成昆呢，武当派还有宋青书呢，哪个名门正派没有出过人渣，请相信，这些个让我们避之不及的小广告也是部分未能得道的低等广告人的拙劣手笔。</p>
<p>不得不承认，现在国内的广告行业很乱，而这个乱的根本原因就是“钱”！<br>国内的互联网产品大多奉行“先用免费馅饼圈地，然后关门磨刀宰客”的发展策略，因此变现的途径主要就围绕着服务收费和广告变现来展开，服务收费并不是每个人都可以做的，但是广告变现就相对来说实现起来简单很多，只要我胆量够大，只要PM没有反对，那么我就敢在用户视线的每一次光临都塞进去一个广告，更何况国内是GP的法外之地。用户体验算什么，他们的心里都有这样一本帐，假如我们产品有100w用户，我们多增加一个广告位带来的收入是6w刀，损失的用户是2w人，然后我们可以再花5w刀买2w的用户（数据纯属捏造，如有雷同，那是扯淡），这样一轮下来你看我们用户数还是100w，但是我们的收入增加了1w刀。这样看起来，这笔买卖很划算。但是朋友们，帐不是这么算的，这么做生意简直就是杀鸡取卵！觉得这笔买卖划算的可能是过于乐观了：</p>
<blockquote>
<p>1.广告位数量和广告收入不是简单的线性关系；<br>2.花银子购买的用户忠诚度和自然增长的用户忠诚度完全不是一个level。</p>
</blockquote>
<p>先说广告位数量和广告收入不是简单的线性关系。经济学中有一条很著名的拉弗曲线（Laffer Curve），它描述了税率和税收之间的关系，这条曲线表明并不是税率越高，税收就越多，事实上，它是一个先增长后下降的曲线，因为税率过高会降低人们到工作积极性，从而对税收有了负作用。广告位数量和广告收入之间的关系也类似，它不是简单的线性相关，广告收入会先随着广告位的增加而上升，然后过了转折点后会开始下降，这是因为用户体验也加速变差了，用户都吓跑了，一个极端的例子是满屏幕都是广告的网站你会进第二次么？（一些小电影网站需要另当别论，因为相较于人们从稀缺资源中获得的感官刺激，这点注意力损耗不算什么。）</p>
<p><center><br><img src="/img/Laffer_Curve.jpg" alt="Laffer Curve"><br></center><br>然后就是用户的忠诚度问题，对于很多互联网公司，特别是移动互联网公司，花钱买量已经是非常正常的事情了，据称国内某专业的海外市场工具公司每天花几十万dollar在买量上。但是一般情况下，买量的作用在于制造产品或者应用十分受欢迎的假象或者增加投资人的信心。<br>如果我们在变现过程中，期望通过先损害用户体验赚钱然后花钱买量的这样的路子，那么这就和我们当年的“先发展，再治理”战略方针是“同一个世界，同一个梦想”了。怎么理解这个忠诚度呢？打个比方，你在中关村大街上只要扫码下载就送充电宝下载的APP和你自己去通过探索等主观意愿去获取的APP，你更倾向于卸载哪个？前面的那个例子中，如果这100w用户全部按照暴力变现－买量的方式置换一遍，我们是可以收获50w的收入，但是我们在讨论用户的时候，要知道还有一个指标叫做留存率，这个留存率直接对应着用户的忠诚度。100w优质用户＝100w劣质用户＋50w刀？这个就看你怎么算了，如果只是想捞一笔就跑，那您请尽兴！</p>
<p>因此，我们很多同行都在干着杀鸡取卵的事，他们坚信做广告就是要伤害用户体验，所以为了他们幻想的利益最大化，索性连碧莲都不要了，能塞广告的地方一个也不放过，广告尽量做得隐蔽，能有多流氓就有多流氓，这里点名表扬WPS的弹窗广告（写博客的时候刚好碰上），整个广告弹窗你就压根找不到关闭的地方，而且它就牢牢占据你屏幕右下方不会自动离去。我承认，广告变现与用户体验确实很难两全，但是很难不代表不能，你看有那么多的广告人在努力让广告变得更加被大众所接受，朋友圈广告就是一个很好的例子，现在的朋友圈广告已经在一定程度上成为了话题，Youtube上的广告可以让用户选择是否观看，最近我的女朋友也十分喜欢宜家的“如果没有厨房，也许你不必早起”这则广告。一定程度上说明广告可以被用户欣然接受，只要我们给他们看到的是他们想看到的。</p>
<p><center><br><img src="/img/FedEx.jpg" alt="FedEx"><br></center><br>如果你真的觉得在用户体验和广告变现中太难权衡，那么，起码你得大大方方地做吧！真小人和伪君子，后者更被人唾骂，更何况是虚伪的小人！是广告就告诉用户这是广告，想看可以看不想看可以绕道，而不是要想尽办法伪装自己然后骗取用户的点击。Google的Admob在这上面真的可以说是我辈楷模，为了提升广告效果建议使用原生广告，但是你必须让用户知情这是一枚广告。</p>
<p><strong>做广告，就要大大方方的做</strong>。这是一位广告界前辈说过的话。如果我们现在真的没有能力去做出完美的广告，那么我们可以选择去提升自己的能力，或者多思考多尝试少去伤害用户，最不济也得做到大大方方做广告吧。</p>
<p><em>（2016年情人节于长沙－北京的天空里）</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<blockquote>
<p>不做总统就做广告人。<br>I am Adman.</p>
</blockquote>
<p><center><br><img src="/img/protect-yourself.jpg" alt="protect-yourself"><br></center><br>]]>
    
    </summary>
    
      <category term="广告杂谈" scheme="http://leotse90.com/tags/%E5%B9%BF%E5%91%8A%E6%9D%82%E8%B0%88/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VAST3.0视频广告规范介绍]]></title>
    <link href="http://leotse90.com/2016/01/29/VAST3.0/"/>
    <id>http://leotse90.com/2016/01/29/VAST3.0/</id>
    <published>2016-01-28T16:23:22.000Z</published>
    <updated>2016-01-28T16:40:50.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>说到VAST，就不得不提到<a href="http://www.iab.com" target="_blank" rel="external">IAB</a>，全称为Interactive Advertising Bureau，我们称之为互联网广告署，它的主要职责是制定网络业务流程的开发标准以及行业准则，并对网络广告收入进行跟踪。</p>
<p>我们今天要介绍的就是IAB的六个主要部分之一——VAST（Video Ad Serving Template）。它是互联网视频广告的统一标准，采用XML格式。随着在线视频内容的广告越来越普遍，人们也越来越关注互联网视频广告的商业化，在VAST出台之前，视频广告并没有统一的广告协议，行业乱象促使需要有人站出来制定一个通用的标准，这时候IAB开始出来行使它的职责，它为在线互联网视频广告制定了一套统一的、可扩展的广告协议。VAST消除了视频广告的技术壁垒，在VAST3.0之前，已经有两个较为普遍的版本，但是现在通用、流行的就是我们说的3.0版本，3.0版本保证了对2.0的兼容。</p>
<p>VAST协议主要包含以下三部分：</p>
<blockquote>
<p>视频广告的内容（creatives）<br>视频广告的跟踪事件及其追踪链接<br>视频广告的wrapper</p>
</blockquote>
<a id="more"></a>
<p>在VAST3.0中，保证了支持以下五种类型的广告：</p>
<blockquote>
<p>线性广告<br>非线性的广告<br>可跳过线性广告<br>伴随线性广告<br>广告荚</p>
</blockquote>
<p>其中，可跳过的线性广告以及广告荚是3.0新增的两种格式。</p>
<h2 id="专业术语">专业术语</h2><p>我们接下来要简单介绍一下VAST中主要的专业术语。</p>
<h3 id="VAST_Tag">VAST Tag</h3><p>VAST标签，获取VAST的URI。通过访问VAST tag可以connect到ad server，从而获取到VAST的response。   </p>
<h3 id="Video_Ad">Video Ad</h3><p>视频广告，这是VAST的主角。它主要指的是视频流（in-stream video）。</p>
<h3 id="Primary_Ad_Server">Primary Ad Server</h3><p>主广告服务器，视频播放器请求广告内容的第一个广告服务器。主广告服务器通常是由publisher的广告服务器。<br>从主广告服务器返回的数据不一定是我们所需的广告视频，还有可能是另一个广告服务器的地址，也就是下面介绍的二级广告服务器。</p>
<h3 id="Secondary_Ad_Server">Secondary Ad Server</h3><p>二级广告服务器，如果主广告服务器返回的不是视频广告的内容，而是一个重定向，指向另一个广告服务器，而这一级的广告服务器也不一定是最后一跳，也就是说还有可能有三级广告服务器、四级广告服务器，以此类推。但是最后一跳的广告服务器一定会提供包含视频广告信息的VAST响应。</p>
<h3 id="Wrapper">Wrapper</h3><p>封装。如果VAST的响应返回的是一个Wrapper，那么就意味着我们需要访问Wrapper中提供的URI访问下一级广告服务器。</p>
<h3 id="Clickthrough">Clickthrough</h3><p>点击。当用户点击广告creatives时所打开的页面。</p>
<h3 id="InLine_Ad">InLine Ad</h3><p>线内广告。指的是包含视频广告所需信息的VAST响应，当VAST的线内广告收到响应后，无需调用其他所需要的广告服务器。</p>
<p>接下来介绍的是VAST3.0支持的广告：</p>
<h3 id="Linear_Ad">Linear Ad</h3><p>线性广告。这种类型的广告我们平时接触很多，当我们在网上看电影的时候我们常常会在播放电影之前（pre-roll）、播放之后（post-roll）出现广告，更有甚者，电影中间（mid-roll）也有可能插播广告。<br>线性广告的形式多种多样，它可以是视频、rich media或者只是一张静止的图像。</p>
<p>可跳过线性广告属于比较特殊的线性广告，也就是用户可以根据需要选择是否看完广告，国外的Youtube的广告一般是这种，用户可以在观看5s后选择是否继续观看广告。</p>
<h3 id="Nonlinear_Ad">Nonlinear Ad</h3><p>非线性广告。依旧属于视频流广告，它也和视频的内容一起显示，但是与线性广告不同的是，非线性广告通常覆盖视频播放器的底部或顶部的五分之一。<br>非线性广告的形式也是多种多样，包含文本、图像等等。</p>
<h3 id="Companion_Ad">Companion Ad</h3><p>伴随广告。这种广告区别于前两者，它出现在视频播放器之外，一般是横幅广告或者富媒体广告。</p>
<p>下图展示了以上四种广告：<br><img src="/img/ads-vast.png" alt="ads-vast"></p>
<h3 id="Ad_Pod">Ad Pod</h3><p>广告荚。大多数视频网站前面的视频广告都是这种形式，包含一系列的线性视频广告。<br><img src="/img/ad-pods.png" alt="ad-pod"></p>
<h2 id="VAST3-0_工作原理">VAST3.0 工作原理</h2><p>常见的情况是直接从主广告服务器上获取视频广告信息。IAB给出这个流程的示意图：<br><img src="/img/master-ad-server-vast.png" alt="master-ad-server-vast"><br>从这个图上我们可以很清楚地看到请求VAST的流程，Ad server直接向视频播放器返回所需的InLine响应，视频播放器在解析了ad server的响应后，打开视频广告，并向ad server发跟踪链接。</p>
<p>另一种情况就是从多级广告服务器上获取视频广告信息，我们以二级广告服务器为例：<br><img src="/img/multi-ad-server-vast.png" alt="multi-ad-server-vast"><br>主广告服务器返回的是Wrapper，也就是视频播放器还需要继续请求二级广告服务器，然后获取到需要的视频创意。这里需要注意的是，跟踪事件需要发送给主广告服务器以及二级广告服务器。</p>
<h2 id="VAST3-0_响应示例">VAST3.0 响应示例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">VAST</span> <span class="attribute">version</span>=<span class="value">”3.0”</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">Ad</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">InLine</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">AdSystem</span>&gt;</span>My Ad Server<span class="tag">&lt;/<span class="title">AdSystem</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">AdTitle</span>&gt;</span>Car Company<span class="tag">&lt;/<span class="title">AdTitle</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">Impression</span>&gt;</span>...<span class="tag">&lt;/<span class="title">Impression</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">Creatives</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">Creative</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="title">Linear</span>&gt;</span>...<span class="tag">&lt;/<span class="title">Linear</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="title">Creative</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">Creative</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="title">CompanionAds</span>&gt;</span>...<span class="tag">&lt;/<span class="title">CompanionAds</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="title">Creative</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">Creatives</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">InLine</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">Ad</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">VAST</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>参考阅读</strong>：<br><a href="http://www.iab.com/guidelines/digital-video-ad-serving-template-vast-3-0/" target="_blank" rel="external">Digital Video Ad Serving Template (VAST) 3.0</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="概述">概述</h2><p>说到VAST，就不得不提到<a href="http://www.iab.com">IAB</a>，全称为Interactive Advertising Bureau，我们称之为互联网广告署，它的主要职责是制定网络业务流程的开发标准以及行业准则，并对网络广告收入进行跟踪。</p>
<p>我们今天要介绍的就是IAB的六个主要部分之一——VAST（Video Ad Serving Template）。它是互联网视频广告的统一标准，采用XML格式。随着在线视频内容的广告越来越普遍，人们也越来越关注互联网视频广告的商业化，在VAST出台之前，视频广告并没有统一的广告协议，行业乱象促使需要有人站出来制定一个通用的标准，这时候IAB开始出来行使它的职责，它为在线互联网视频广告制定了一套统一的、可扩展的广告协议。VAST消除了视频广告的技术壁垒，在VAST3.0之前，已经有两个较为普遍的版本，但是现在通用、流行的就是我们说的3.0版本，3.0版本保证了对2.0的兼容。</p>
<p>VAST协议主要包含以下三部分：</p>
<blockquote>
<p>视频广告的内容（creatives）<br>视频广告的跟踪事件及其追踪链接<br>视频广告的wrapper</p>
</blockquote>]]>
    
    </summary>
    
      <category term="VAST" scheme="http://leotse90.com/tags/VAST/"/>
    
      <category term="计算广告" scheme="http://leotse90.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[劣质诗人]]></title>
    <link href="http://leotse90.com/2016/01/21/%E5%8A%A3%E8%B4%A8%E8%AF%97%E4%BA%BA/"/>
    <id>http://leotse90.com/2016/01/21/劣质诗人/</id>
    <published>2016-01-21T14:35:24.000Z</published>
    <updated>2016-01-21T15:09:31.000Z</updated>
    <content type="html"><![CDATA[<center><br><img src="/img/brick.jpg" alt="brick"><br></center><br><a id="more"></a><br><center><br>我试着<br>一<br>字<br>一<br>行<br>置换一件<br>诗人的伪装<br></center>]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="/img/brick.jpg" alt="brick"><br></center><br>]]>
    
    </summary>
    
      <category term="远方与诗" scheme="http://leotse90.com/tags/%E8%BF%9C%E6%96%B9%E4%B8%8E%E8%AF%97/"/>
    
      <category term="随笔" scheme="http://leotse90.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[这座城市的孤儿]]></title>
    <link href="http://leotse90.com/2016/01/20/%E8%BF%99%E5%BA%A7%E5%9F%8E%E5%B8%82%E7%9A%84%E5%AD%A4%E5%84%BF/"/>
    <id>http://leotse90.com/2016/01/20/这座城市的孤儿/</id>
    <published>2016-01-19T16:01:02.000Z</published>
    <updated>2016-01-21T14:34:59.000Z</updated>
    <content type="html"><![CDATA[<center><br><img src="/img/orphan.jpg" alt="orphan"><br></center><br><a id="more"></a><br><center><br>你指着北方<br>看，北京<br>我沿着你划出的弧线<br>看到一群<br>小心翼翼的陌生人<br>他们用尽全力呼气<br>把天空变成<br>披上雾的毛玻璃<br>擦了又擦<br>也看不到远方</center>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="/img/orphan.jpg" alt="orphan"><br></center><br>]]>
    
    </summary>
    
      <category term="远方与诗" scheme="http://leotse90.com/tags/%E8%BF%9C%E6%96%B9%E4%B8%8E%E8%AF%97/"/>
    
      <category term="随笔" scheme="http://leotse90.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android中的Bitmap]]></title>
    <link href="http://leotse90.com/2016/01/19/Android-Bitmap/"/>
    <id>http://leotse90.com/2016/01/19/Android-Bitmap/</id>
    <published>2016-01-18T16:10:12.000Z</published>
    <updated>2016-04-12T15:40:18.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Bitmap简介">Bitmap简介</h2><p>Bitmap，我们称之为位图文件，它的扩展名一般是.bmp，有时也可以是.dip。位图由点（像素）组成，其可以理解为一个像素矩阵，矩阵中的每一个点表示对应位置上像素的颜色，每个点可以由多种颜色组成，包括2，4，8，16，24，32位色彩。一张1200x628分辨率的32位真彩图片，所占的存储空间为：1200x628x32/(8x1024)＝2944KB。由于位图的构造，使得其图像效果很好好，它是非压缩格式的，但是这也导致它需要占用较大的存储空间，这让位图变得不太适合在网络上传输。</p>
<center><br><img src="/img/bitmap-example.bmp" alt="Bitmap example"><br></center>

<a id="more"></a>
<p>由于Bitmap的应用比较广泛，因此Android中常常使用到Bitmap。但是在使用Bitmap的时候，我们常常需要考虑到其占用内存较大的事实，因此关注Bitmap的OOM异常成为我们使用Bitmap的必修课。我们主要需要注意以下几个方面：</p>
<blockquote>
<p>1.Android系统资源有限；<br>2.Bitmap很能吃内存；<br>3.应用的UI一般加载多张Bitmap，这样会一下消耗很多内存。</p>
</blockquote>
<h2 id="Bitmap的处理">Bitmap的处理</h2><h3 id="Bitmap的加载优化">Bitmap的加载优化</h3><p>考虑我们前面讲到的Bitmap很耗内存，我们在加载Bitmap的时候就需要时时注意内存情况。在选择图片时，我们就需要知道找到一张合适的图片比一张效果好的图片更加合理（除非你的应用对图片质量要求很高，比如壁纸类应用）。这里介绍Android中的Bitmap的处理类：<code>BitmapFactory</code>。</p>
<p><code>BitmapFactory</code>提供了多种decode图片的方法，比如：<code>decodeByteArray()</code>，<code>decodeFile()</code>，<code>decodeResource()</code>等等，这些方法方便我们从不同的来源创建Bitmap，这些方法都可以通过<code>BitmapFactory.Options</code>来指定decode选项，设置<code>inJustDecodeBounds</code>属性为true可以在decode时避免分配内存，它会返回一个空的Bitmap，但是我们可以获取到Bitmap的outWidth, outHeight与outMimeType。我们这样就可以在构造Bitmap之前读图片的尺寸与类型。为了避免OOM，我们在一开始就可以检查Bitmap图片的尺寸。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkBitmap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BitmapFactory.Options mOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    mOptions.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(getImgResource(), R.id.mImage, mOptions);</span><br><span class="line">    <span class="keyword">int</span> mImgHeight = mOptions.outHeight;</span><br><span class="line">    <span class="keyword">int</span> mImgWidth = mOptions.outWidth;</span><br><span class="line">    String mImgType = mOptions.outMimeType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resources <span class="title">getImgResource</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在获取了Bitmap的尺寸后，就能很灵活地决定是否需要加载完整的Bitmap图片，如果我们在评估以下几项后决定是否需要加载一个缩小版本的图片：</p>
<blockquote>
<p>1.加载完整的Bitmap需要耗费的内存；<br>2.加载这张Bitmap是否会增加其他相关的内存占用；<br>3.放置这张图片的的控件尺寸是否合适；<br>4.屏幕大小以及设备的屏幕密度；</p>
</blockquote>
<p>在评估后如果觉得没有必要加载完整的图片就可以考虑加载缩小版的Bitmap。我们需要告诉Bitmap的解码器我们打算加载缩小版的Bitmap，这时可以在<code>BitmapFactory.Options</code>中设置<code>inSampleSize</code>的值，例如, 一个分辨率为2048x1536的图片，如果设置<code>inSampleSize</code>为4，那么会产出一个大约512x384大小的Bitmap。加载这张缩小的图片仅仅使用大概0.75MB的内存，如果是加载完整尺寸的图片，那么大概需要花费12MB（前提都是Bitmap的配置是 ARGB_8888）。下面有一段根据目标图片大小来计算Sample图片大小的代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(</span><br><span class="line">            BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw height and width of image</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span></span><br><span class="line">        <span class="comment">// height and width larger than the requested height and width.</span></span><br><span class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt; reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;</span><br><span class="line">            inSampleSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Note</strong>: 设置inSampleSize为2的幂是因为解码器最终还是会对非2的幂的数进行向下处理，获取到最靠近2的幂的数。详情参考<code>inSampleSize</code>的文档。<br>为了使用该方法，首先需要设置<code>inJustDecodeBounds</code>为true, 把options的值传递过来，然后设置<code>inSampleSize</code>的值并设置 <code>inJustDecodeBounds</code>为false，之后重新调用相关的解码方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId,</span><br><span class="line">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First decode with inJustDecodeBounds=true to check dimensions</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate inSampleSize</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode bitmap with inSampleSize set</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用上面这个方法可以简单地加载一张任意大小的图片。如下面的代码样例显示了一个接近100x100像素的缩略图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mImageView.setImageBitmap(</span><br><span class="line">    decodeSampledBitmapFromResource(getImgResources(), R.id.mImage, <span class="number">100</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure></p>
<p>类似的，我们也可以通过替换合适的<code>BitmapFactory</code>解码方法来实现一个类似的方法从其他的数据源解析Bitmap。</p>
<h3 id="Bitmap的内存管理与缓存">Bitmap的内存管理与缓存</h3><p>在Android的演变进程中，管理Bitmap内存也发生了改变。在Android 2.2及以前的版本，当GC的时候，应用的线程会被暂停，在Android2.3开始，新增了并发GC机制，<strong>这意味着在一个Bitmap不再被引用之后，它所占用的内存会被立即回收。</strong><br>在Android2.3.3及之前，一个Bitmap的像素级是存放在Native空间里，这些数据与Bitmap本身是隔离的，Bitmap本身被存放在Dalvik堆中，我们无法预测在Native内存中的像素级数据何时会被释放，这意味着程序容易超过它的内存限制并且崩溃。自Android 3.0开始， 像素级数据则是与Bitmap本身一起存放在Dalvik堆中。</p>
<p>好在我们现在Android的主流版本在Android4.0以上，因此Bitmap在不被引用后就会被回收。</p>
<blockquote>
<p>在过去，一种比较流行的内存缓存实现方法是使用软引用（SoftReference）或弱引用（WeakReference）对Bitmap进行缓存，然而我们并不推荐这样的做法。从Android 2.3开始，垃圾回收机制变得更加频繁，这使得释放软（弱）引用的频率也随之增高，导致使用引用的效率降低很多。而且在Android 3.0之前，备份的Bitmap会存放在Native Memory中，它不是以可预知的方式被释放的，这样可能导致程序超出它的内存限制而崩溃。</p>
</blockquote>
<h3 id="Bitmap的线程操作">Bitmap的线程操作</h3><p>我们可以通过<code>BitmapFactory</code>的解码方法来获取Bitmap，但是当图片来源于网络或者其他非内存来源时，我们就需要考虑由此带来的线程问题，毕竟我们在UI线程上不适合干这件事，那么我们可以考虑使用<code>AsyncTask</code>：加载Bitmap的类继承<code>AsyncTask</code>，并重载<code>doInBackground()</code>以及<code>onPostExecute()</code>方法。开始异步加载Bitmap，只需要创建一个新的任务并执行它即可。</p>
<blockquote>
<p>为ImageView使用WeakReference确保了AsyncTask所引用的资源可以被垃圾回收器回收。由于当任务结束时不能确保ImageView仍然存在，因此我们必须在onPostExecute()里面对引用进行检查。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference imageViewReference;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapWorkerTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a WeakReference to ensure the ImageView can be garbage collected</span></span><br><span class="line">        imageViewReference = <span class="keyword">new</span> WeakReference(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode image in background.</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        data = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> decodeSampledBitmapFromResource(getResources(), data, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once complete, see if ImageView is still around and set bitmap.</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageViewReference != <span class="keyword">null</span> &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ImageView imageView = imageViewReference.get();</span><br><span class="line">            <span class="keyword">if</span> (imageView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以按照这样异步加载Bitmap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(imageView);</span><br><span class="line">    task.execute(resId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们就Android中的Bitmap进行比较全面的介绍，当然可以参考官网了解更多有关<a href="http://developer.android.com/reference/android/graphics/Bitmap.html" target="_blank" rel="external">Bitmap</a>的信息。</p>
<p>(整理自网络)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Bitmap简介">Bitmap简介</h2><p>Bitmap，我们称之为位图文件，它的扩展名一般是.bmp，有时也可以是.dip。位图由点（像素）组成，其可以理解为一个像素矩阵，矩阵中的每一个点表示对应位置上像素的颜色，每个点可以由多种颜色组成，包括2，4，8，16，24，32位色彩。一张1200x628分辨率的32位真彩图片，所占的存储空间为：1200x628x32/(8x1024)＝2944KB。由于位图的构造，使得其图像效果很好好，它是非压缩格式的，但是这也导致它需要占用较大的存储空间，这让位图变得不太适合在网络上传输。</p>
<center><br><img src="/img/bitmap-example.bmp" alt="Bitmap example"><br></center>]]>
    
    </summary>
    
      <category term="Android" scheme="http://leotse90.com/tags/Android/"/>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发(三)]]></title>
    <link href="http://leotse90.com/2016/01/12/Java-concurrency3/"/>
    <id>http://leotse90.com/2016/01/12/Java-concurrency3/</id>
    <published>2016-01-11T16:15:21.000Z</published>
    <updated>2016-01-11T16:16:10.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="返回值">返回值</h2><p>我们知道，可以通过创建Runnable来创建任务，但是我们却不能通过这种方式返回值。Java因此提供了另一个接口来达到返回一个值的目的，这个接口就是Callable。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法中返回的值的类型，我们通过ExecutorService.submit()来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leotse.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CallableTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"This is task "</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService eService = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i ++)&#123;</span><br><span class="line">			results.add(eService.submit(<span class="keyword">new</span> CallableTask(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Future&lt;String&gt; r : results)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(r.get());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				eService.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这个例子向我们展示了Callable的用法。Callable中的call()相当于Runnable中的run()方法。<br>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。可以通过get方法获取执行结果，get()方法会阻塞直到任务返回结果。  </p>
<p>我们在这里对比一下Callable与Runnable的一些主要区别：</p>
<blockquote>
<p>1.Callable接口提供了call()方法，Runnable接口提供了run()方法；<br>2.call()有返回值，run()方法没有返回值；<br>3.call()可以抛出受检查的异常，run()则不能抛出受检查的异常。</p>
</blockquote>
<h2 id="线程休眠">线程休眠</h2><p>有时候，我们在程序中，需要线程等待一段时间，我们可以通过sleep()方法通知Thread暂停指定的时间。线程的休眠相对比较简单，还是来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SleepTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Task "</span> + id + <span class="string">", currentTimeMillis is "</span> + System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepTask(i));</span><br><span class="line">			t.start();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task <span class="number">0</span>, currentTimeMillis is <span class="number">1452526404372</span></span><br><span class="line">Task <span class="number">1</span>, currentTimeMillis is <span class="number">1452526406373</span></span><br><span class="line">Task <span class="number">2</span>, currentTimeMillis is <span class="number">1452526408373</span></span><br><span class="line">Task <span class="number">3</span>, currentTimeMillis is <span class="number">1452526410374</span></span><br><span class="line">Task <span class="number">4</span>, currentTimeMillis is <span class="number">1452526412375</span></span><br></pre></td></tr></table></figure></p>
<p>这样的时间比较难以辨认，你可以使用Date类打印标准化时间，以便更加直观看到sleep()的效果。</p>
<h2 id="线程的优先级">线程的优先级</h2><p>我们在并发程序中启动了多个线程，但是这些线程并不一定在重要程度上一样，我们用线程的<strong>优先级</strong>来定义线程的重要程序。线程的优先级意味着不同级别的线程占用CPU的概率不同，优先级低的线程不会不执行。一般来说，程序中的优先级都以默认的优先级来运行，线程的优先级可以通过getPriority()方法来获取。但是一般不建议控制线程的优先级，因为调度器的行为并不可控。</p>
<h2 id="线程让步">线程让步</h2><p>我们在上一篇<a href="http://leotse90.com/2016/01/07/Java-concurrency2/">博客</a>中介绍Thread的时候提到了yield()方法，该方法的作用是告诉当前线程：嘿，你已经用了CPU一段时间了，是时候让出CPU了。但是这只是一种建议，而不是一种保证。一般来说，对于任何重要的控制或在调整应用时，都不能指望yield()方法能达成我们的目的。</p>
<h2 id="后台线程">后台线程</h2><p>如果在应用中，我们需要进行网络请求，或者我们需要执行一些不太重要的事情，这些任务就可以放在后台线程中。后台线程（Daemon）并不是程序中不可或缺的部分，所以如果程序中所有的非后台线程都已经结束，那么程序就已经执行结束，同时会kill掉所有的后台线程。换言之，只要有任何非后台线程还在运行状态，程序就不会结束。</p>
<p>如果要指定一个线程为Daemon线程，只需调用setDaemon()方法即可，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>当程序中最后一个非后台线程终止运行，后台线程就会突然终止，因此一旦main()退出，JVM就会立即关闭所有的后台进程。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="返回值">返回值</h2><p>我们知道，可以通过创建Runnable来创建任务，但是我们却不能通过这种方式返回值。Java因此提供了另一个接口来达到返回一个值的目的，这个接口就是Callable。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法中返回的值的类型，我们通过ExecutorService.submit()来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leotse.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CallableTask</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"This is task "</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService eService = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i ++)&#123;</span><br><span class="line">			results.add(eService.submit(<span class="keyword">new</span> CallableTask(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Future&lt;String&gt; r : results)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(r.get());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				eService.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发(二)]]></title>
    <link href="http://leotse90.com/2016/01/07/Java-concurrency2/"/>
    <id>http://leotse90.com/2016/01/07/Java-concurrency2/</id>
    <published>2016-01-06T16:26:33.000Z</published>
    <updated>2016-01-09T17:22:00.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="Java的线程机制">Java的线程机制</h2><p>我们在上一篇<a href="http://leotse90.com/2016/01/06/Java-concurrency1/">博客</a>中，提到最理想的实现并发编程的方式就是使用进程，但是Java中我们使用线程进行多任务处理，原因在上一篇博客中也已经提及。</p>
<p>在Java中，每一个线程都会对应一个任务，这些任务构成了一个并发的程序。    在底层看来，每一个线程都觉得自己独占了CPU，虽然事实上它们只是在某一个时间切片上占有了CPU。CPU会轮流给每一个线程分配时间，这些细节一般不需要我们去了解。</p>
<h3 id="Runnable接口">Runnable接口</h3><p>我们知道，Java中的并发程序是由任务构成，那么Java中怎么声明一个任务呢？Java为我们提供了一个Runnable接口，凡是实现了Runnable接口的类皆可以称之为一个任务。下面的实例展示了Java中如何声明任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I am a task"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我们看到这里有一个run()方法，我们将打算在这个任务中执行的业务逻辑都放在run()方法中。我们另行编写一个测试类用来执行这个Task。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyRunnable task = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">		task.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行的结果如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am <span class="tag">a</span> task</span><br></pre></td></tr></table></figure></p>
<p>这样看来，觉得Runnable和普通的Java类没有什么区别。这里只是在main()线程中执行了这个任务。如果我们希望这个任务和一个线程对应起来，应该怎么做呢？我们需要显式地将任务绑定到一个线程上。这就需要我们用到Thread类。</p>
<h3 id="Thread类">Thread类</h3><p>在Java中，一个Thread类的对象就是一个Java程序的执行线程。JVM允许一个程序有多个线程。每一个线程都有其优先级，高优先级的线程会先于低优先级的线程执行，想必这个很容易理解。每一个线程都可以被声明为一个后台线程。如果一个运行的线程中创建了一个新的Thread对象，那么这个新的Thread对象的初始优先级和创建它的线程一样，如果创建它的线程是一个后台线程，那么这个新的Thread对象也是一个后台线程。</p>
<p>当JVM启动时，通常会有一个非后台线程运行，这就是我们熟知的main线程，JVM会一直执行程序中的线程直到发生了下列情况：<br>1）Runtime类的exit()方法被调用，并且安全管理器允许这个退出操作执行；<br>2）所有的线程都是非后台进程，而且都已经停止运行；或者获取了run()方法调用的返回值；又或者run()抛出了一个异常。</p>
<p>我们在上面提到需要显示将一个任务和一个线程绑定在一起。常用的方法就是在创建一个Thread对象的时候将任务作为构造器的参数。我们将前面的MyRunnable类改造一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threadCount = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.threadCount = count;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Thread "</span> + threadCount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们编写另一个类MyThreadDemo来创建任务并执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">			MyRunnable task = <span class="keyword">new</span> MyRunnable(i);</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者我们可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(i)).start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们创建了5个任务，并把它们分别和一个Thread对象进行绑定，然后执行这些线程，得到结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span></span><br><span class="line">Thread <span class="number">4</span></span><br><span class="line">Thread <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>由于线程调度机制是非确定性的，所以每次执行的结果都可能会不同。</p>
<p>在Thread类中，我们需要关注以下一些主要的方法：<br><strong>yield()</strong>:该方法会建议调度器当前进程将要让出自己对处理器的使用，但是调度器可以选择是否需要接受这个建议。一般不建议使用这个方法，但是如果在debug或测试的时候还是可以使用的。</p>
<p><strong>sleep()</strong>:这个方法可以短暂中断当前执行线程。我们可以指定当前执行线程的休眠时间；</p>
<p><strong>start()</strong>:开始执行一个线程，当调用这个方法时，JVM会执行这个线程的run()方法。调用这个方法的结果就是两个线程并发执行：从这个start()方法调用返回的线程，执行run()方法的线程。需要注意的是，我们不能多次启动同一个线程，而且一个线程一旦执行结束就不能重启；阅读Thread的源码可知，start()本身是一个同步方法，且里面调用了本地方法start0()方法启动一个线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is not invoked for the main method thread or "system"</span><br><span class="line">     * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">     * to this method in the future may have to also be added to the VM.</span><br><span class="line">     *</span><br><span class="line">     * A zero status value corresponds to state "NEW".</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span><br><span class="line">     * so that it can be added to the group's list of threads</span><br><span class="line">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span><br><span class="line">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>exit()</strong>:系统调用这个方法以期让一个线程在其真正退出运行前进行资源的清理工作；</p>
<p><strong>interrupt()</strong>:中断当前线程。但是在实际编程中，我们在使用它时需要特别注意，你可以看看这篇<a href="http://www.blogjava.net/jinfeng_wang/archive/2008/04/27/196477.html" target="_blank" rel="external">博客</a></p>
<blockquote>
<p>许多程序员都建议使用runnable，因为直接继承Thread类会增加类的层次。</p>
</blockquote>
<p>这些都是Java的线程机制中比较基础的，还有其他的诸如Executor以及优先级等其他概念，我们将在下一次介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="Java的线程机制">Java的线程机制</h2><p>我们在上一篇<a href="http://leotse90.com/2016/01/06/Java-concurrency1/">博客</a>中，提到最理想的实现并发编程的方式就是使用进程，但是Java中我们使用线程进行多任务处理，原因在上一篇博客中也已经提及。</p>
<p>在Java中，每一个线程都会对应一个任务，这些任务构成了一个并发的程序。    在底层看来，每一个线程都觉得自己独占了CPU，虽然事实上它们只是在某一个时间切片上占有了CPU。CPU会轮流给每一个线程分配时间，这些细节一般不需要我们去了解。</p>
<h3 id="Runnable接口">Runnable接口</h3><p>我们知道，Java中的并发程序是由任务构成，那么Java中怎么声明一个任务呢？Java为我们提供了一个Runnable接口，凡是实现了Runnable接口的类皆可以称之为一个任务。下面的实例展示了Java中如何声明任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I am a task"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发(一)]]></title>
    <link href="http://leotse90.com/2016/01/06/Java-concurrency1/"/>
    <id>http://leotse90.com/2016/01/06/Java-concurrency1/</id>
    <published>2016-01-05T16:30:15.000Z</published>
    <updated>2016-01-06T16:28:01.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="并发，并发，并发">并发，并发，并发</h2><p>有顺序编程，就有并发编程。事实上，几乎我们所有的程序都可以通过顺序编程来完成，只是你必须忍受一些非常情况。<br>并发说起来很奇怪，它具有可论证的确定性，但是实际上却具有不可确定性。它的不可确定性是因为你没有办法预知在实际情况下会发生事情导致工作失败，而且你也没有办法通过编写代码进行完备的测试。<br>虽然实际应用中，并发很难做到完全掌握，但是这不能成为我们不作为的理由。</p>
<blockquote>
<p>如果视而不见，你就会遭其反噬。</p>
</blockquote>
<p>作为一名骄傲的程序员，并发编程是基础，也是必备知识。</p>
<h2 id="为什么需要并发">为什么需要并发</h2><p>这是一个老生常谈的问题，但是我们不能规避这个问题，要想深入理解一件事物，就必须弄清楚它的来龙去脉。<br><a id="more"></a><br>我们设定我们现在在做饭，我们需要做的事情list如下：<br>1）淘洗大米；<br>2）插电做饭；<br>3）洗好紫菜；<br>4）打鸡蛋；<br>5）洗净豌豆并剥开；<br>6）牛肉切丁；<br>…</p>
<p>是的，我们想来一顿米饭＋紫菜蛋汤＋豌豆牛肉粒的穷人版商务套餐。我们可以有很多种方法完成这顿午餐。其中有两种常见可行的方案：<br>1.完全按照顺序来，即1) -&gt; 2) -&gt; 3) -&gt; 4) -&gt; 5) -&gt; 6)，也就是每次都需要等待上一个步骤完成再进行下一步；<br>2.我们将时间打碎，在完成1) -&gt; 2)之后，无需等待2）完成，即不用等到生米煮成熟饭，就开始着手洗紫菜、打鸡蛋，然后在煲汤的同时，开始准备豌豆和牛肉。</p>
<p>很明显，除了死心眼，大家都会选择第2种方案或者其他类似的方案。第1种方案就是我们所说的顺序编程，而第二种方案就是并发编程。</p>
<blockquote>
<p>通常来说，并发是提高运行在单核上的程序的性能。</p>
</blockquote>
<p>为什么是提供单核上程序的性能呢？<br>如果只有一个核即处理器，我们来回切换工作，反而会增加上下文切换的损耗，怎么会是提高性能呢？如果和上述的例子结合起来就不难发现，如果有些事情需要等待，但是这个等待的时间间隙我们可以做一些并不依赖于正在处理的事情的其他业务，比如做菜并不依赖煮饭（除非你用同一口锅），洗豌豆并不依赖于煲汤。这样我们的时间就被充分利用起来了。用行话来说，就是<strong>阻塞</strong>。如果程序中的某个任务因为该程序控制范围外的某些条件而导致不能继续执行，那么我们就说这个任务或者线程阻塞了。如果没有引入并发，那么线程将一直阻塞，直至这些条件发生改变。</p>
<blockquote>
<p>某种程度上讲，没有阻塞，就没有并发。（单核）</p>
</blockquote>
<p>最简单直接的方式就是使用进程。<br>多任务操作系统会周期性将CPU从一个进程切换到另一个进程，虽然会有切换带来的耗时，但是对用户来说基本可以当作同时在运行多个进程。而且操作系统会帮我们将这些进程隔离开来，每个进程都有自己的一亩三分地，使得它们变得相互独立。这对并发编程来说，似乎非常理想，不会出现争夺公共资源的情况，每个任务都在自己的地址空间中做着自己的事情，进程们也根本不需要相互通信。但是进程通常都有数量限制以及开销上的限制，因此在实际编程中并不常见直接将进程作为并发的实现方式。</p>
<blockquote>
<p>函数型语言被设计为可以将并发任务彼此隔离，其中每个函数的调用都不会产生任何副作用，因此可以当作独立的任务来驱动。</p>
</blockquote>
<p>在Java中，我们常常用到的是在顺序编程的基础上使用比进程更小粒度的线程来实现并发。编写Java并发程序的一个最基本的困难是如何协调不同线程驱动的任务之间对一些公共资源（如IO、内存）的使用。</p>
<p>使用并发的另一个目的是改进代码设计。我们前面提到，我们可以使用顺序编程完成几乎所有程序，但是这会使得我们的程序变得复杂，使用并发可以使得我们的程序结构更加清晰简化。</p>
<p>我们假设我们的程序由很多的部件的组成，每一个部件都可以独立运作，那么理想情况就是每一个部件都对应一个线程，但是实际上我们的多线程系统一般都会限制线程的数量，而且这个数字不会太大，因此我们往往我们不能达到理想情况下的每一个部件都对应一个线程。在Java中，线程机制是抢占式的，也就是说，系统可能周期性中断线程，然后切换到另一个线程，从而让每个线程都有运行的时间片。我们可以通过协作多线程来解决这个问题。在协作式系统中，每个任务都是可控的，即可以通过编程人员的控制自动放弃控制，相对于抢占式线程机制，协作式线程机制一方面上下文切换的开销小，另一方面同时执行的线程数量理论上没有限制。</p>
<p>当然，并发是有代价的，那就是我们需要额外花费上下文切换的代价，但是这个代价不算高昂，特别是和它所带来的收益进行比较。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="并发，并发，并发">并发，并发，并发</h2><p>有顺序编程，就有并发编程。事实上，几乎我们所有的程序都可以通过顺序编程来完成，只是你必须忍受一些非常情况。<br>并发说起来很奇怪，它具有可论证的确定性，但是实际上却具有不可确定性。它的不可确定性是因为你没有办法预知在实际情况下会发生事情导致工作失败，而且你也没有办法通过编写代码进行完备的测试。<br>虽然实际应用中，并发很难做到完全掌握，但是这不能成为我们不作为的理由。</p>
<blockquote>
<p>如果视而不见，你就会遭其反噬。</p>
</blockquote>
<p>作为一名骄傲的程序员，并发编程是基础，也是必备知识。</p>
<h2 id="为什么需要并发">为什么需要并发</h2><p>这是一个老生常谈的问题，但是我们不能规避这个问题，要想深入理解一件事物，就必须弄清楚它的来龙去脉。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://leotse90.com/tags/Java/"/>
    
      <category term="并发" scheme="http://leotse90.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[企业计算的终结]]></title>
    <link href="http://leotse90.com/2015/12/17/%E4%BC%81%E4%B8%9A%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%88%E7%BB%93/"/>
    <id>http://leotse90.com/2015/12/17/企业计算的终结/</id>
    <published>2015-12-17T14:25:21.000Z</published>
    <updated>2015-12-17T14:54:42.000Z</updated>
    <content type="html"><![CDATA[<p><em>作者：尼古拉斯·卡尔</em><br><em>翻译：黄思路</em><br><em>文章来源：《斯隆管理评论》</em></p>
<p><em>这是在36kr上看到的一篇文章，对于文中有关信息技术发展的理解感触颇深，于是kiang到了这里(<a href="http://36kr.com/p/5041175.html" target="_blank" rel="external">原文</a>)。</em></p>
<blockquote>
<p>花费数百万美元打造内部数据中心后，企业往往会发现面临着快速淘汰这些数据库的窘境。IT 正从一种企业资产转变为一种服务购买。</p>
</blockquote>
<p>20 世纪早期，有一些之前的几十年里无法想象的事情陆续发生：制造厂商开始关闭、拆除水轮设备、蒸汽机和发电机。要知道，从工业时代开始，电力就是任何产业得以运作的必要前提，工厂作坊除了维持独立发电站来使运作机器以外别无选择。新世纪的到来带来了一种新的可能，许多新兴发电商开始通过建立中央电厂和使用电网给远距离外的客户输送电能。制造商本身不需要再维持独立发电站的运营，他们可以从这些新兴发电商那里购买需要的用电。</p>
<p>几乎过了整整一个世纪后，历史再次重演。过去50年中最重要的一项商业成就——信息技术——正在经历类似的转变。信息技术曾以电脑、软件和其他各式各样的形式作为公司的一种资产，而现在，它正在转化为一种从效用供应商那里购买的服务。商业界很少有公司真正意识到这个转变的重大意义和深远影响。至今，关于效应计算的讨论也仅仅是停留在信息技术供应商的市场标语里，如同那些含义模糊的各类名词，“自动系统”、“服务及虚拟化”、“服务型架构” 等等。其实这些充满官腔的言词不仅没有着向大众照亮这一转变的未来，更使人们对于它的理解变得非常模糊。<br><a id="more"></a><br>当下最盛行的一种观点也非常保守。这种观点认为现有的信息技术供应和应用模型会持续下去，并且企业数据中心仍然会是这种模型的核心。然而，这样的看法非常短浅，而且极具危险性。传统模型的经济基础已经动摇，并且在未来很难幸存。<strong>如同早期电力供应的转变警示的那样，信息技术从分散资产向集中效应服务的转变有着重大意义</strong>。这将颠覆战略、运营的早先设想，改变产业经济，扰乱市场，以及给每一位用户和供应商带来艰巨的挑战。信息技术的商业化应用历史总被描述为伴随惊人的飞跃，但是我们眼下的这场大变革是史上未见的——哪怕是个人电脑或是因特网的问世也无法与之相提并论。</p>
<h2 id="从资产到花费">从资产到花费</h2><p>信息技术如同之前的蒸汽和电力，被经济学家称为通用技术的一种。通用技术被大大小小的公司用来处理纷繁复杂的各类事务，给商业和社会带来深远的变化。在供应稳定的前提下，通用技术的广泛应用为规模经济的发展提供了巨大潜力。不过这类经济需要一段很长的时间才能被完全认识、全面开发。在通用技术发展的早期阶段，技术标准远未完善，配置网络也非常局限，很难得以集中发展。因此通用技术的供应根据不同需要相匹配，发展模式非常分散。个体公司必须采购各种使用这种技术需要的配置，组装、搭建好之后想办法使这套系统运转起来，并专门雇佣专家进行保养和维修。</p>
<p><strong>这样的分散式供应其实非常的浪费资源：它对各家公司来说意味着大量的投资和高昂的成本，并在技术和劳动力方面导致沉重的多余开支和极高的产能过剩。</strong>这种状况对于技术配置提供商来说无疑是有利的，因为他们可以从这种过度投资中获益颇丰，然而这种模式最终还是不可持续的。随着通用技术的发展，集中输送也具备了可能，大型的公共服务供应商开始取代私人供应商。尽管公司可能需要数年的时间弃置他们专有的供应业务和这背后的沉没成本，与大型供应商合作所带来的成本节约还是更具吸引力，对那些大型企业来说也是无法拒绝的诱惑。放弃旧模式也就成为了一种打造竞争力的必然做法。</p>
<p>电力供应的演变就是印证这一过程的一个明确案例。19世纪80年代，商业供电才刚开始，很多小型供电商在城市迅速发展，他们中的很多都是小规模个体运营，使用燃煤发电机生产容量非常有限的电力。由于他们的电力是直流电，不能被输送的很远，这个服务距离也就被限制在一英里之内。运营的高成本使得他们向客户征收高昂的费用，因此他们的客户大多都是财力雄厚的商场、写字楼、业主和市政机构，这些客户需要电力的目的主要是用以维持照明系统。</p>
<p>仅依靠这些小型发电站对于大型工业发展来说并非长久之计。为了满足大量的电力需求，大型工业企业必须建立自己的发电站。他们与电力提供商，比如通用电气和西屋电气签订协约，从他们那里获取发电设备和专业人员配备，雇佣电气工程师和相关专家操作、维护这一套复杂的系统，使之融入生产链的运作中。在电气化早期发展的阶段，私人发电商很快占据了主导地位。到1902年，在美国境内大约有50000家私人发电厂。1907年，这些工厂已经在生产整个国家使用的电力中的60%。</p>
<p>和这些大厂商的情况不同，像城市印刷厂这样的小型工业企业选取的是完全不同的路径。他们无法承担安装发电机和配备维修人员的费用，因而只能依靠附近的集中发电站，即使这意味着要付一笔不菲的费用，还要忍受频繁的电力中断。那时候，这些小厂商的感受就像是在电气化竞赛中被甩后一截而不得不采用看上去低人一等的供应模式，以此维持电力带来的生产率的提高。事实上，人们当时并没有想到这些小型企业其实是一种大趋势的先行者，很快的，他们强大的竞争对手也会意识到从外部供应商那里购买电力带来的明显优势，从而选择与他们一样的路。</p>
<p>这种转变的发生是以一系列的科技进步为背景的。第一，巨型热涡轮机的发展给规模经济提供了更大的潜力。第二，交变电流使电力输送的距离更远，扩大了中央电站可以服务的客户规模。第三，换流器的发明可以转换电流的不同形式，也就使得旧设备可以适应新系统的运作。最后，具备交流电下工作能力的电动机的发明使工厂可以利用新兴电网来运行机器。早在二十世纪初，所有技术元素就已经就位，向制造厂商提供集中化的电力供应，淘汰它们老化的、独立的发电机。</p>
<p><strong>单有技术进步也是不够的。现状的彻底改变也需要商业视野。能够把握技术、市场和经济趋势的综合体的人可以领先创造全新的供应模式</strong>——这个人就是一位名为塞缪尔·英萨尔的英国会计。对电力深有研究的英萨尔在 1880年移民纽约，很快成为托马斯·爱迪生最为信任的顾问，帮助这位发明家扩大商业帝国。不过英萨尔最伟大的成就是在他离开爱迪生之后，1892年 他辞去工作搬去了芝加哥，在那里担任一家拥有三个发电站和不超过5000名客户的小型独立发电公司的总裁。在不到25年的时间里，他将这家小公司打造成为世界上最大的企业之一——名为联邦爱迪生的大型垄断企业。</p>
<p>英萨尔最先意识到，通过新技术的资本化来巩固发电量，集中的公用事业可以满足任何大型工厂的电力需求。并且公用事业的规模经济加上用户群体中用电需求的扩散可以帮助他们获得更高的产能利用率，进而提供比私有的分量表发电便宜很多的电力。洞悉事态发展的英赛尔当机立断买下了芝加哥所有的小型发电公司，并且在自己的发电站中安置了5000千瓦的大型发电机。同样重要的行动还包括，英赛尔首先推出电能计量和可变定价，大幅削减对大客户的报价，以此稳固这些客源。最后，他详细制定了一套市场方案，使制造商确信，关闭原先的独立发电机转而从自己的公司购买电力才是明智之举。</p>
<p>随着芝加哥各大厂商朝自己的公司蜂拥而至，英赛尔的预见变成了现实。1908年 一位来自 Electrical World and Engieneer 的记者写道：“尽管在芝加哥还存在无数个体运作的发电厂，他们现在经历着的是前所未有的来自集中发电站的压迫…联邦爱迪生公司拥有的很多发电机以前都是属于芝加哥一些大型独立厂商的。” 质变的临界点已经到来。尽管很多厂商可能还是会在未来几年选择独立发电，私人发电向公共发电的转折已经开始。在1907年 到1920年间公共发电占了全美总量的40%-70%，到了1930年，这个比例已经上升到 80.8%。</p>
<p>将电力由一项复杂资产转化为一种常规的可变开支，这种观点的转变帮助厂商节约成本，腾出资本用于更有价值的生产目标。同时，他们可以精简员工，减少技术过时和故障的风险，企业管理人员也因此可以避免对重大隐患的时刻担忧。曾经无法想象的公共电力的广泛使用已经不可逆转的发生，私人发电站也被时代淘汰。</p>
<h2 id="信息技术转型开始">信息技术转型开始</h2><p>当然，历史的类比总是有其局限性，信息技术和电力技术有太多重大区别。比如，信息技术所包涵的软件程序是人类智慧的产品，受到知识产权法的保护。不过，信息技术和电力技术之间也有很多相同之处——而当代的观察者很容易忽视这些相似点。今天，人们把电看做一种 “简易” 的效用，毫无新鲜感的电流会遵循安全的、设计好的途径通过埋在墙壁里的插座。已经见惯了无数和电有关的工具，从家用台灯到装配线上的机床，电已经变得如此平常，以至于我们不再把它看作为一种了不起的基础科技——它们经历了独特又熟悉的生命演变。不过，事实并非总是如此。</p>
<p>电气化刚开始时，电是一种极其复杂、不可预知并且还远未被完全掌控的力量，它可以改变任何它触碰到的东西。借用现代的术语，电的应用层当时只停留在发电机、电线和电流本身。人们需要研究清楚如何将电力应用到具体运营中，也就由此衍生出各种根本性的改变、长期实践、业务流程和组织架构。随着科技的进步，人们不得不经常与老化、过时的设备作斗争——所谓的 “遗产系统（传统系统）” 往往会阻碍进步的发展。</p>
<p>作为一种商业资源或输入的信息技术科技，今天看来与上世纪电力技术发展的开端颇为相似。公司企业从供应商那里购买各类设备，包括电脑、储存硬盘、网络交换机以及各种软件，然后将所有这些融合到一套复杂的、内部的信息处理系统或者数据库中。他们聘请专门的工作人员维护这套系统，还经常需要外部顾问来解决尤其棘手的问题。公司的执行层工作常常会因为这受到牵制，影响真正的业务表现——以汽车行业为例，为了维持公司的独立信息基础设施运行顺畅，汽车制造和销售都需要极尽所能最大化利润。</p>
<p>成千上万的独立数据中心使用的其实是基本类似的硬件系统和软件程序，而这些数据中心已经给很多个体公司带来了严重的危害，对整体经济来说也是如此。信息技术资产的过度建设导致极低程度的资本利用率。最近的一次对六家企业数据库的研究表明，超过 1000 台服务器仅仅发挥了 10%-35%的处理能力。台式电脑的表现就更加糟糕，以 IBM 为例，平均产能利用率只有 5%。总部位于康涅狄格州斯坦福德的 Gartner 公司通过研究发现，大约 50%-60%的公司数据存储容量处于被浪费的状态。产能过剩的状态也不仅限于硬件。由于软件程序具有极高的扩展性，也就是说，它们可以在极少甚至没有增量成本的前提下服务更多的用户，因而在数千个不同的网站安装完全一样或类似的软件会导致急剧的经营管理失当，不管是在前期支出还是在现行成本费用方面。各家公司对大同小异的 IT 部门的复制也会导致对劳动力的过度投资。2003年 的一项调查显示，美国各家公司 IT 部门平均预算的 60%都被用于常规支持和功能性维护。</p>
<h2 id="个人电脑">个人电脑</h2><p>如果说有什么可以代表现今企业IT状况的话，那无疑是个人电脑。个人电脑不仅占据了现代公司的每一张办公桌，更是典型的企业计算总体状况的缩影：零散、多余、并且越来越疏于利用。</p>
<p>个人电脑的发明是一个伟大的成就，是现近代商业史上一项最重要的发明。它使计算能力扩散到个人，激发创新，提高个人生产力，并且无疑加速了网络的发展，包括因特网和 World Wide Web。然而强大的、高容量的网络的发展也使台式电脑的必要性越来越低；计算资源可以不论距离、越来越多的被提供给用户。当个人电脑的容量达到最大时，用户的需求却并没有保持一致的扩张。人们仅仅使用计算马力中极小部分，现代电脑的多GB硬盘容量也往往要不是空的，要不就被塞满无价值的文件。</p>
<p>有人争论说个人电脑现在反正非常便宜，也就无所谓有没有被浪费了。然而这种说法并没有考虑到维护、更新大量个人电脑和相关软件所产生的庞大开支，也忽视了个人电脑常常是现代公司最大安全隐患这一事实——黑客入口和诉讼证据储存库。</p>
<p>上世纪90年代后期，Oracel 首席执行官拉里艾里森因为声称个人电脑会成为 “一种可笑的设备” 而广受批评，他认为个人电脑将被瘦客户机所取代——连接中央主机的终端以及其他精简设备。艾里森的论断的时机也许并不正确，但并不代表这个论断也不正确。随着效用计算的发展，现代公司保留台式电脑的倾向将越来越弱。在家里，个人电脑也许是计算的引擎，但是在商业里，它却无足轻重，并且越来越不必要。</p>
<p>当产能过剩与冗余功能相结合，向集中供应的转变也就具备了成熟的条件。然而公司持续在维护甚至扩大个体数据中心上进行大量投资，这是为什么？就和 20世纪早期制造厂商依旧安装个体发电机的原因一样：缺少可靠、大规模的效用模型。而这种模型现在正在产生和发展。效用计算的初级形态正在增值，很多公司也在加快对他们的投资。有些公司使用由像 IBM、惠普公司和数据信息系统等供应商所提供的紧急硬件支持来维护自己的大数据中心，有些则采用远程软件商提供的应用程序。包括采购、运输管理、财务、客户服务、销售团队管理以及其它各种功能在内的这些程序项目已经充分表明，即使是非常复杂的应用也可以通过服务提供的方式由因特网获取。</p>
<h2 id="开拓者">开拓者</h2><p>小型公司在转向公共电力提供这方面打了先头。由于缺少建立独立发电站的资金，他们除了从外部供应商那里购买电力之外并没有什么其他选择。早起采用效应计算的公司中最激进的也属于资本受限的一类组织：中小型企业，政府机构和非营利组织。</p>
<p>例如，宾夕法尼亚联邦早在十年前就开始向效用计算的方式转移。经过几年的策划，该州于1999年秋天开始关闭17个政府组织所运营的数据中心，并巩固由优利系统公司领衔的供应商联盟提供的硬件和软件设施。类似的，纽约的林肯艺术中心也采用了效应模式。他们不再维持原先售票系统的应用程序和服务器，而是使用 IBM 提供和维护的硬件，只需要每个月缴纳一笔资费。</p>
<p>一些大企业开始在更大规模上接纳效用计算的方式。澳洲航空公司从 2004年 开始卸载他们的数据中心，将数百个服务器和大型计算机迁移到新供应商提供的设备。现在该公司只需要根据实际的计算容量使用量来支付相应的资费。澳洲航空公司甚至将业务中最核心的预定和票务系统外包给总部位于西班牙马德里的技术提供商 Amadeus 全球旅游分销。据澳航首席信息官菲奥娜贝尔福称，公司数据中心预算中用于固定成本的百分比已经从 70%降到了 30%，正是因为向效用供给的转变。</p>
<p>很多其他的大公司正在建立内部的 “效用” 供给，提供整个公司的计算资源。他们巩固了以往的分散计算、数据储存和网络硬件，实施更严格的软件标准，并利用包括虚拟化、网络服务在内的新技术给业务部门和企业公司提供最量身定做的服务。DHL近期整合了旗下八个北美数据中心，将它们融入位于亚利桑那的统一处理器中。从事化学和药物行业的拜耳美国将也将其信息技术运营加以集中，将42个数据中心整合为两处，并减半了服务器数量——这样做带来成本节约高达一亿美元。这也代表随着规模效用的出现，我们将向更广阔的信息技术资源整合又迈近一步。</p>
<p>早期的发展进程没有展示出的，是一个真正效用模型的充分程度和力量。当代很多零碎的效用服务以对传统数据中心重新打造的方式存在；个体公司必须将效用服务与他们过去的软件硬件联系起来。确实，很多公司不得不放弃极具吸引力的效用服务或是在外包过程中遇到很多问题，因为对传统系统的整合是非常困难的。只有在外包商满足公司所有的IT要求，包括数据处理、储存、应用时，真正的效用计算才能发生。效用模型要求的，是对传统上保留在零散内部数据中心的资产的所属权权被转移给效用提供商，并由他们加以巩固。</p>
<p>这个过程需要很多年才能完全展开，但是技术积木已经在开始累积搭建。三大进步——虚拟化、网格计算和 Web 服务尤为重要，尽管他们的重要性经常由于和他们联系在一起的晦涩术语被模糊化。这三大技术扮演的角色有点类似于早期的电流转换器，当然是以不同的表现形式呈现：他们使之前互不相容的部分构建、融合成一个大而紧密的系统。虚拟化技术消除了不同计算平台之间的差异，使应用程序可以在不同的操作系统中运行。网格计算允许大量的硬件部分，比如服务器和磁盘驱动有效的发挥作用，汇集它们的能力并自动分配去执行不同的任务。Web 服务将应用程序的互动标准化，将他们变成可轻易拆卸、组装的模块。</p>
<p>单个来看，每一种技术都非常有趣，但是将他们组合在一起是一件真正具有革命性的事情。利用高容量的光纤通信网络，人们可以将零散、笨重的一套硬、软件组件整合为一个单个、灵活性的基础设施，并且可以被无数家公司以不同的方式采用。随着某个系统服务的用户增多，这个系统的需求负荷也变得更平衡，它的产能利用率得以提高，规模经济也在扩大。考虑到技术的不断演变和进步也伴随着相关新兴技术的出现，将信息技术作为一种效用提供的能力只会不断提高，并且这么做所带来的经济刺激也会不断增长。</p>
<p><strong>效用计算的最大障碍并不是技术，而是态度。</strong>如同向集中电力的模式转变，最大的障碍在于传统操作、过去的投资、和以这两者为基础建立的根深蒂固的管理预设。大公司只有在信息技术效用的可靠性、稳定性和好处明确建立起来之后，才敢对他们的数据中心下手改革。为了让这样的变革发生，当代的 “塞缪尔英萨尔” 需要具备如何运营信息技术效用的清晰视野，同时还必须有使其发生的经济实力和想象力。就像他的前辈那样，这样的视野会打造出高效的、大规模的信息技术工厂，与成熟的计量和计价系统相结合，为不同客户提供优越灵活的、量身定做的全套服务。同时，他也会用极具说服力的营销方案向企业高管证明，集中化管理之前零散的资源不仅可以节约成本、解放资本，更可以提高安全性，加强灵活性和减少风险。简而言之，这个人将会创造一个产业。</p>
<h2 id="新产业的形状">新产业的形状</h2><p>新产业具体会以什么样子呈现还未可知，但是我们可以大概预见其轮廓。它将会有主要的三部分，最中心的部分是信息技术效用本身——大型企业将在中央系统中维护核心计算资源，并将它们输送给终端用户。效用模型的运作需要大批不同的部件提供商——电脑、储存、网络设备、操作和效用软件、应用程序等。最后，大型网络运营商将负责超大容量的数据线路。并且，肯定会有有能力的公司同时负责这些门类中一种以上的供应项目。</p>
<p>这种效用模型最激动人心之处在于它的独特——也正是这些独特让信息技术非常适合向效用服务发展。如果是电力技术，只有基本的发电功能可以集中化，因为它的应用是通过发电机物理性传送到电灯泡等电力设备的，也就是说他们必须用于用户本地供应。然而信息技术的应用是以软件为主要形式，可以由提供商远程操作。就算是为客户定制的应用也可以被安置在供应商处。终端用户只需要维护各种输入和输出设备，比如监控器、打印机、键盘、扫描仪、移动设备、传感器等需要用来接收、传送和操作数据，以及重新配置服务的相关仪器。尽管有些客户会倾向于本地运行程序，效用提供商还是可以拥有和操作大部分硬件和软件，放大他们的规模优势。</p>
<p>哪些公司会成为新兴的效用供应商？目前至少有四类可能。首先是致力于企业计算硬件的传统大型制造商，比如IBM, 惠普公司, 太阳微系统公司等。他们有非常丰富的设置、运营商业系统的经验，并且毫无意外的，他们已经开始非常积极的转向效用提供商的角色定位。太阳微系统公司不仅以单位计费出租处理储存容量，还在网上拍卖计算能力。第二类是专业性的托管运营商，比如休斯顿的VeriCenter和弗吉尼亚MCI的Digex服务，他们现在依然给中小型公司运营整体数据中心。这些在挣扎在网络泡沫崩溃后的专门性公司也开始模仿电气化早期原先作为中央发电站的运营商的做法。第三类是类似谷歌和亚马逊的因特网创新公司，他们建立的广泛成熟的计算网络理论上可以被调整以适应更多用途。最后一类是我们现在还不怎么了解的创业公司，他们有研发灵活策略的潜力。因为效用行业规模驱动和资本密集的特点，规模和重点对于成功来说非常关键。任何公司都难以做到保持领先的同时实现其他商业目标。</p>
<p><strong>目前看来，效用计算系统似乎符合哈佛商学院克莱顿克里斯滕森定义的颠覆式创新模式：首先占领低端市场，然后脱颖而出，最终成为占据主导地位的供应模式。</strong>因此，它有可能对现在很多大型部件提供商构成极大地危险，包括微软、戴尔、甲骨文、SAP 等通过对企业的世界销售大获成功的公司。效用模型将供应商与终端客户隔离，迫使他们向、或是通过大型集中效用的方式销售产品和服务，这也会带来更大的议价能力。大部分被广泛使用的部件，从电脑、操作系统到复杂的自动化业务流程的 “企业应用”，在未来都会作为便宜常见的商品而被购买。</p>
<p>当然，当下领先的部件供应商拥有庞大的市场能力和管理技能，他们也有时间根据效用模型的发展调整策略，有些可能会向前融入这种有过成功先例的效用模式。当厂商开始从购买电力时，两家最大的提供商，包括提供发电机和相关部件的通用电气和西屋电气当即买下很多电力公司的股份，大力扩大业务规模。早在 1895年，通用电气就在全美和欧洲投资了超过五千九百万美元的电力设施。</p>
<p>不过这样的先例也向我们警示了整合买卖双方行为的风险。美国的电力业务越来越被集中在少数公司手里，政府顾忌到垄断公司对这种关键性资源的掌控，因而对行业设置了更严格的限制。信息技术行业的组成部分更多样化，但是少数公司对基础设施的独断控制的可能性也是存在的。垄断不仅会导致对终端用户的高额收费，也会减缓创新速度，带来其他各种危害。可见，保持一种提供商和效用商之间的良性竞争对于未来数年健康、繁荣的信息基础产业是至关重要的。</p>
<h2 id="从未来回望">从未来回望</h2><p>任何对于未来的预测，尤其是涉及到科技进步速度和方向的预测，都具有投机性，我们现在面对的状况也不例外。然而，如果说技术进步总是无法预测的，那么经济和市场能力总是以一种有规律且有一致性的方式引导商业发展。商业的历史告诉我们，重复投资和分散能力对集中供应提供了强有力的刺激。计算能力和网络进步也允许信息技术以一种愈发“虚拟化”的方式发展，而基础技术资产和用户获取、转译和处理信息点的距离也可以越来越远。考虑到这种发展趋势，信息技术企业激进的变革将不可避免。</p>
<p>有时，最大的产业变革似乎让人不可思议，即使它确确实实在发生。现在当我们回望过去的电力行业，我们看到的是一段以清晰、明确的逻辑所展开的演变过程。不难辨别，个体公司修建和维护专有发电厂的行为是一种过渡性现象，一种人为的必须，并没有太大经济意义。从当下的立场来看，电力的效用化是必然结果。现在看上去毫无疑问的事情对于当时的工厂厂主、管理人员来说都是非常牵强、甚至可笑荒唐的，因为对于他们来说，维护独立电能是已经延续了数十年的传统做法。</p>
<p>想象一下，未来的人在回望一百年之后、现在的我们，他们会看到什么？难道独立数据中心不也正是一种过渡性现象吗？——和当年的独立发电厂一样的一种权宜之计。难道信息技术效用的发展不正是一种自然、必然的趋势吗？并且，难道现在的企业计算方式本质上来说不正是毫无逻辑却又注定如此吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>作者：尼古拉斯·卡尔</em><br><em>翻译：黄思路</em><br><em>文章来源：《斯隆管理评论》</em></p>
<p><em>这是在36kr上看到的一篇文章，对于文中有关信息技术发展的理解感触颇深，于是kiang到了这里(<a href="http://36kr.com/p/5041175.html">原文</a>)。</em></p>
<blockquote>
<p>花费数百万美元打造内部数据中心后，企业往往会发现面临着快速淘汰这些数据库的窘境。IT 正从一种企业资产转变为一种服务购买。</p>
</blockquote>
<p>20 世纪早期，有一些之前的几十年里无法想象的事情陆续发生：制造厂商开始关闭、拆除水轮设备、蒸汽机和发电机。要知道，从工业时代开始，电力就是任何产业得以运作的必要前提，工厂作坊除了维持独立发电站来使运作机器以外别无选择。新世纪的到来带来了一种新的可能，许多新兴发电商开始通过建立中央电厂和使用电网给远距离外的客户输送电能。制造商本身不需要再维持独立发电站的运营，他们可以从这些新兴发电商那里购买需要的用电。</p>
<p>几乎过了整整一个世纪后，历史再次重演。过去50年中最重要的一项商业成就——信息技术——正在经历类似的转变。信息技术曾以电脑、软件和其他各式各样的形式作为公司的一种资产，而现在，它正在转化为一种从效用供应商那里购买的服务。商业界很少有公司真正意识到这个转变的重大意义和深远影响。至今，关于效应计算的讨论也仅仅是停留在信息技术供应商的市场标语里，如同那些含义模糊的各类名词，“自动系统”、“服务及虚拟化”、“服务型架构” 等等。其实这些充满官腔的言词不仅没有着向大众照亮这一转变的未来，更使人们对于它的理解变得非常模糊。<br>]]>
    
    </summary>
    
      <category term="IT" scheme="http://leotse90.com/tags/IT/"/>
    
      <category term="互联网" scheme="http://leotse90.com/categories/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES之当你更新Document，你在更新些什么？]]></title>
    <link href="http://leotse90.com/2015/11/24/ES%E4%B9%8B%E5%BD%93%E4%BD%A0%E6%9B%B4%E6%96%B0Document%E4%BD%A0%E5%9C%A8%E6%9B%B4%E6%96%B0%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <id>http://leotse90.com/2015/11/24/ES之当你更新Document你在更新些什么/</id>
    <published>2015-11-24T14:59:13.000Z</published>
    <updated>2015-11-25T00:10:48.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="怎么更新ElasticSearch中的Document？">怎么更新ElasticSearch中的Document？</h2><p>在ES中更新数据的场景有很多，比如我们要修改一个用户的年龄、爱好，又或者我们需要实时同步MySQL中的数据到ES中。我们都有修改已经存在的Document的需求。ES本身提供了两种方法让我们修改一个Document的数据，我们假设我们想要修改的内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="built_in">test</span>/customer/<span class="number">1</span>/_<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想将yolovon女神的年龄修改到真实年龄18岁。我们可以进行以下两种方法：<br>1.使用PUT，就像我们插入数据时那样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/customer/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_index"</span>: <span class="string">"test"</span>,</span><br><span class="line">   <span class="string">"_type"</span>: <span class="string">"customer"</span>,</span><br><span class="line">   <span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这里需要注意的是，我们必须将所有的字段全部输入一次，如果你只在PUT的body里输入我们要更新的字段（比如在这里我们只传入age的值），那么新的Document的就会变成我们后面PUT进去的样子（即只有age一个字段）。<br>另外，我们可以看到这里的返回信息有用以标示该document唯一性的<code>_index</code>，<code>_type</code>，<code>_id</code>，以及<code>_version</code>表明该document的更新版本，<code>created</code>表明这个不是新建的而是已经存在的document。</p>
<p>2.使用POST，update模式更新Document：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test/customer/<span class="number">1</span>/_<span class="keyword">update</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"doc"</span>: &#123;</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会看到这样的结果：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">_index</span>": <span class="value"><span class="string">"test"</span></span>,</span><br><span class="line">   "<span class="attribute">_type</span>": <span class="value"><span class="string">"customer"</span></span>,</span><br><span class="line">   "<span class="attribute">_id</span>": <span class="value"><span class="string">"1"</span></span>,</span><br><span class="line">   "<span class="attribute">_version</span>": <span class="value"><span class="number">3</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候，我们的document也变为了：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">name</span>": <span class="value"><span class="string">"yolovon"</span></span>,</span><br><span class="line">   "<span class="attribute">age</span>": <span class="value"><span class="number">20</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>age</code>已经变成了20。而且在这里，我们只针对需要修改的<code>age</code>字段进行操作，而其他字段并不需要关心。</p>
<h2 id="更新操作都干了些什么？">更新操作都干了些什么？</h2><p>那么，在更新的时候到底发生了什么？上面的两种更新策略又有什么区别？  </p>
<p>我们知道，在Elasticsearch中，document是不可变的。  </p>
<blockquote>
<p>Documents in Elasticsearch are immutable; we cannot change them. Instead, if we need to update an existing document, we reindex or replace it.</p>
</blockquote>
<p>这样一来，我们在更新Document时到底是怎么实现的？  </p>
<p><strong>在ES中，不管我们用以上哪种方式进行更新document，它都不是真正地对原来的document进行操作。而是先将原来的document标记为删除状态，然后重新新增一个document（也就是我们看到的新的document），实际上，原来的document并没有立即消失，只是你已经不能访问它了，ES稍后会在后台真正地删除原来的document。</strong></p>
<p>不管我们用那种方式进行更新，ES都会按照以下的步骤进行更新：</p>
<blockquote>
<p>1.查询出旧的document；<br>2.修改document中的字段；<br>3.删除旧的document；<br>4.重新索引一个新的document。</p>
</blockquote>
<p>但是两者还是有区别的，当使用<code>PUT</code>一个完整的document时，它需要请求两次，一次<code>get</code>请求和一次<code>index</code>请求，而使用<code>POST</code>进行<code>_update</code>操作的时候只需要一次<code>_udpate</code>请求即可。</p>
<p>因此我们在使用的时候，尽量避免使用<code>PUT</code>进行document的更新，特别是当我们需要批量地修改ES数据时。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="怎么更新ElasticSearch中的Document？">怎么更新ElasticSearch中的Document？</h2><p>在ES中更新数据的场景有很多，比如我们要修改一个用户的年龄、爱好，又或者我们需要实时同步MySQL中的数据到ES中。我们都有修改已经存在的Document的需求。ES本身提供了两种方法让我们修改一个Document的数据，我们假设我们想要修改的内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="built_in">test</span>/customer/<span class="number">1</span>/_<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">   <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想将yolovon女神的年龄修改到真实年龄18岁。我们可以进行以下两种方法：<br>1.使用PUT，就像我们插入数据时那样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/customer/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"yolovon"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_index"</span>: <span class="string">"test"</span>,</span><br><span class="line">   <span class="string">"_type"</span>: <span class="string">"customer"</span>,</span><br><span class="line">   <span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ElasticSearch与MySQL数据同步]]></title>
    <link href="http://leotse90.com/2015/11/11/ElasticSearch%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://leotse90.com/2015/11/11/ElasticSearch与MySQL数据同步以及修改表结构/</id>
    <published>2015-11-11T14:12:23.000Z</published>
    <updated>2015-11-12T00:31:38.000Z</updated>
    <content type="html"><![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES与MySQL的数据同步">ES与MySQL的数据同步</h2><p>如果你需要进行ES与MySQL的数据同步，亦即将MySQL中的数据导入到ES中，并保持同步，一般来看，有以下几种方法：<br>1.自己动手写一个同步的模块。实时tail处理MySQL的binlog，将数据库的新增、修改或删除这些操作同步在ES上执行。这种方案可行，但是实现起来代价大；</p>
<p>2.<a href="https://github.com/siddontang/go-mysql-elasticsearch" target="_blank" rel="external">go-mysql-elasticsearch</a>。这是Git上的一个开源项目，差不多是第一种方案的一个实现版本。这个插件支持实时同步MySQL与ES的新增、修改以及删除操作。但是缺点是使用起来不够灵活，它的作者给出了它的以下缺点：</p>
<blockquote>
<p>-binlog row image must be full for MySQL, you may lost some field data if you update PK data in MySQL with minimal or noblob binlog row image. MariaDB only supports full row image.<br>-Can not alter table format at runtime.<br>-<code>mysqldump</code> must exist in the same node with go-mysql-elasticsearch, if not, go-mysql-elasticsearch will try to sync binlog only.  </p>
</blockquote>
<a id="more"></a>
<p>这三点比较重要的缺点影响我使用这种方案，特别是不能运行时修改表结构。对于很多在线业务来说是比较难以接受的。</p>
<p>3.<a href="https://github.com/jprante/elasticsearch-jdbc" target="_blank" rel="external">elasticsearch-river-jdbc</a>。这种方案是1、2的结合体。可以较为灵活地进行数据同步，比如可以在同步的时候指定需要同步的字段以及筛选条件。这也是比较流行的解决方案，但是它也有一个比较致命的缺点，那就是删除操作不能同步（物理删除）！</p>
<p>如果你的系统对删除操作频繁，而且都是物理删除，并且能接受不能运行时修改表结构等条件，那么使用go-mysql-elasticsearch将是非常不错的选择；如果你的表结构改变得相对频繁，而且不用对表进行物理删除（比如用逻辑删除取而代之），那么你可以选择elasticsearch-river-jdbc。如果你对这两者都不满意，而且觉得自己的编码能力还不错，那么完全可以自己定制一个满足自己需求的插件。</p>
<h2 id="elasticsearch-river-jdbc使用">elasticsearch-river-jdbc使用</h2><p>我们这里选择使用elasticsearch-river-jdbc作为我们同步ES与MySQL的插件。我们这里简单介绍一下elasticsearch-river-jdbc的安装与使用：<br>1.确保ES的集群的每个Node都能访问MySQL数据库；  </p>
<p>2.安装River：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;./bin/plugin --install river-jdbc --url  <span class="symbol">http:</span>/<span class="regexp">/xbib.org/repository</span><span class="regexp">/org/xbib</span><span class="regexp">/elasticsearch/plugin</span><span class="regexp">/elasticsearch-river-jdbc/</span><span class="number">1.5</span>.<span class="number">0.5</span>/elasticsearch-river-jdbc-<span class="number">1.5</span>.<span class="number">0.5</span>-plugin.zip</span><br></pre></td></tr></table></figure></p>
<p>3.下载mysql-connector-java-5.1.30-bin.jar并将其保存在{$ES_HOME}/plugins/jdbc/目录下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="symbol">http:</span>/<span class="regexp">/cdn.mysql.com/</span><span class="regexp">/Downloads/</span><span class="constant">Connector</span>-<span class="constant">J</span>/mysql-connector-java-<span class="number">5.1</span>.<span class="number">37</span>.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>如果是ES集群，你需要在每一个Node上执行这一步。</p>
<p>4.创建一个JDBC river<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;curl -XPUT <span class="string">'localhost:9200/_river/my_jdbc_river/_meta'</span> -d <span class="string">'&#123;</span><br><span class="line">     "</span>type<span class="string">" : "</span>jdbc<span class="string">",</span><br><span class="line">     "</span>jdbc<span class="string">" : &#123;</span><br><span class="line">         "</span>driver<span class="string">" : "</span><span class="transposed_variable">com.</span><span class="transposed_variable">mysql.</span><span class="transposed_variable">jdbc.</span>Driver<span class="string">",</span><br><span class="line">         "</span>url<span class="string">" : "</span>jdbc:mysql:<span class="comment">//localhost:3306/test",</span></span><br><span class="line">         <span class="string">"user"</span> : <span class="string">"root"</span>,</span><br><span class="line">         <span class="string">"password"</span> : <span class="string">"123456"</span>,</span><br><span class="line">         <span class="string">"sql"</span> : <span class="string">"select * from test.student;"</span>,</span><br><span class="line">         <span class="string">"interval"</span> : <span class="string">"30"</span>,</span><br><span class="line">         <span class="string">"index"</span> : <span class="string">"test"</span>,</span><br><span class="line">         <span class="string">"type"</span> : <span class="string">"student"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;’</span><br></pre></td></tr></table></figure></p>
<p> 5.你可以查看ES是否已经同步了这些数据：<br> <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -XGET <span class="comment">'localhost:9200/test/student/_search?pretty&amp;q=*'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改表结构后的数据同步">修改表结构后的数据同步</h2><p>如果你需要修改正在与ES进行数据同步的表的结构，你有以下三种方案（亲测可行）：<br><strong>方案一</strong>：创建JDBC river的时候使用sql语句：<code>select * from table_name;</code><br>乍一看，这种方法很坑。但是确实适合那些喜欢简单粗暴的coder。但是这种方案的场景比较苛刻：   </p>
<blockquote>
<p>MySQL中表在创建时id命名为_id，这是因为_id是ES中每一条document的唯一标识；如果不这样干，你会发现每一次同步ES的type中都会增加MySQL表中条目数个Document；<br>MySQL表所有的字段对ES都是有效的、必要的；</p>
</blockquote>
<p><strong>方案二</strong>.方案一的改进版，使用sql语句：<code>select *, id as _id from table_name;</code><br>这个方案在你需要在ES中存储MySQL中表所有字段的时候变得比较有效。</p>
<p><strong>方案三</strong>：使用elasticsearch的alias。具体的操作比较简单，可以参照<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html" target="_blank" rel="external">官网的介绍</a>。</p>
<p>前两种方案有点取巧，第三种方案才是正道。</p>
<p>如果你愿意，完全建议自己定制一套解决方案。由于业务需要，本人最近也在开始写这样的插件。我会在这个博客里保持更新。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>by:leotse</em></p>
<h2 id="ES与MySQL的数据同步">ES与MySQL的数据同步</h2><p>如果你需要进行ES与MySQL的数据同步，亦即将MySQL中的数据导入到ES中，并保持同步，一般来看，有以下几种方法：<br>1.自己动手写一个同步的模块。实时tail处理MySQL的binlog，将数据库的新增、修改或删除这些操作同步在ES上执行。这种方案可行，但是实现起来代价大；</p>
<p>2.<a href="https://github.com/siddontang/go-mysql-elasticsearch">go-mysql-elasticsearch</a>。这是Git上的一个开源项目，差不多是第一种方案的一个实现版本。这个插件支持实时同步MySQL与ES的新增、修改以及删除操作。但是缺点是使用起来不够灵活，它的作者给出了它的以下缺点：</p>
<blockquote>
<p>-binlog row image must be full for MySQL, you may lost some field data if you update PK data in MySQL with minimal or noblob binlog row image. MariaDB only supports full row image.<br>-Can not alter table format at runtime.<br>-<code>mysqldump</code> must exist in the same node with go-mysql-elasticsearch, if not, go-mysql-elasticsearch will try to sync binlog only.  </p>
</blockquote>]]>
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://leotse90.com/tags/ElasticSearch/"/>
    
      <category term="MySQL" scheme="http://leotse90.com/tags/MySQL/"/>
    
      <category term="技术" scheme="http://leotse90.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
