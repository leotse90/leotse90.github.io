
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Scorpio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Leo Tse">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Scorpio">
<meta property="og:url" content="http://leotse90.com/index.html">
<meta property="og:site_name" content="Scorpio">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scorpio">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Scorpio" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Scorpio" title="Scorpio"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Scorpio">Scorpio</a></h1>
				<h2 class="blog-motto">You only live once!</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:leotse90.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/29/MooseFS概览/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Leo Tse" target="_blank" itemprop="author">Leo Tse</a>
		
  <p class="article-time">
    <time datetime="2015-09-29T07:53:49.000Z" itemprop="datePublished"> 发表于 2015-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="MooseFS概览">MooseFS概览</h1><h2 id="Intro">Intro</h2><p><a href="http://www.moosefs.org/" target="_blank" rel="external">MooseFS</a>，是一种容错的网络分布式文件系统。它提供了FUSE接口的客户端，挂载后和读写本地磁盘上的文件无异，是替代NFS的理想选择。<br>用户访问MooseFs系统中不同机器上的数据没有差异，对用户来说，只有一个源。</p>
<h2 id="Architecture">Architecture</h2><p>MooseFS主要由四部分组成：</p>
<h3 id="Master_Server（元数据服务器）">Master Server（元数据服务器）</h3><p>管理整个MooseFS系统的单点，保存了MooseFS中每个文件的元数据，包括文件的大小、属性、文件位置等等；我们的元数据信息同时保存在Master的内存和磁盘里。</p>
<h3 id="Metalogger_Server（元数据日志服务器）">Metalogger Server（元数据日志服务器）</h3><p>存储元数据服务器的变更日志，用以恢复Master Server，它也会周期性下载MasterServer的元数据文件，服务器数量不定。我们也可以在Master Server宕掉后使用Metalogger Server作为我们的MasterServer；</p>
<h3 id="Chunk_Server（数据存储服务器）">Chunk Server（数据存储服务器）</h3><p>用于存储系统中的数据。如果我们指定数据需要备份（我们一般都会这么做），那么ChunkServer之间就会通过算法完成数据的备份工作；</p>
<h3 id="Client（客户端）">Client（客户端）</h3><p>所有通过mfsmount进程和Master进行交互的机器，都可以叫做MooseFS的客户端。对客户端来说，所有的ChunkServer就像一台普通的NFS服务器一样在为它提供强大的数据存取服务；</p>
<p>笔者从MooseFS的官网上kiang了两张图，分别是MooseFS读数据和写数据的，大家闭上眼睛，用心感受下：  </p>
<p><img src="http://www.moosefs.org/tl_files/mfs_folder/read862.png" alt="MooseFS Read Process"><br><img src="http://www.moosefs.org/tl_files/mfs_folder/write862.png" alt="MooseFS Write Process"></p>
<p>我们从图上可以很清晰地看到整个读写过程。  </p>
<h2 id="Uses">Uses</h2><p>1.大规模高并发的数据存储与访问（大文件、小文件皆可）；<br>2.大规模的数据处理；</p>
<h2 id="Features">Features</h2><h3 id="Advantages">Advantages</h3><p>1）简单易用。安装、部署以及配置都相对简单容易；<br>2）高可靠性：MooseFS采用数据备份的方式确保我们的数据安全可靠；<br>3）可伸缩性：我们可以在不停服务的情况下，新增或者删除MooseFS中的服务器；<br>4）支持POSIX访问，支持FUSE；<br>5）可移植性：适用于任何实现FUSE的系统，包括但不限于Linux、FreeBSD、OpenSolaris以及MacOS X；<br>6）MooseFS提供了快照功能，可以对整个文件甚至在正在写入的文件创建文件的快照；<br>7）提供类似JVM的GC机制；<br>8）提供web GUI监控接口；<br>9）随机读写的效率较高，海量小文件读写效率高；<br>10）发展比较成熟，文档全面；  </p>
<h3 id="Disadvantages">Disadvantages</h3><p>1）MooseFS客户端程序使用FUSE编写加载MooseFS磁盘的命令；因此我们需要确保我们系统内置或者安装了FUSE；<br>2）存在单点故障。MooseFS只有一个Metadata Server，因此MDS的性能就会成为MooseFS性能的瓶颈；<br>3）故障恢复需手动恢复;<br>4）MooseFS的Master是单线程的程序，并不能发挥多核CPU的优势，由于大部分的处理逻辑都是内存操作，因此并不会存在太大的问题，但一旦涉及到磁盘I/O就有可能导致阻塞，严重的话整个集群会瘫痪掉，因此不建议把Master放在虚拟机中。<a href="http://tech.uc.cn/?tag=moosefs" target="_blank" rel="external">MooseFS之虚拟机惹的祸</a></p>
<h2 id="Conclusion">Conclusion</h2><p>当前，MooseFS在国际国内都拥有了大量的用户，正是由于这些用户基础，也推动了MooseFS继续发展。<br>虽然MooseFS仍然存在单点故障这样的瓶颈，但是它的简单易用以及高可靠性，仍然让它成为我们DFS方案的不错的选择。</p>
<h2 id="Others">Others</h2><p>MooseFS官网解答了我们一些常见的问题：<a href="http://www.moosefs.org/moosefs-faq.html" target="_blank" rel="external">FAQ</a></p>
<p><strong>NFS</strong>：Network File System。一种用于分散式系统的协议。通过网络让不同的机器、不同的操作系统分享彼此个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在Unix系统间实现磁盘文件共享的一种方法。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/29/【译】Python中yield关键字用法/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Leo Tse" target="_blank" itemprop="author">Leo Tse</a>
		
  <p class="article-time">
    <time datetime="2015-09-29T07:53:21.000Z" itemprop="datePublished"> 发表于 2015-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="【译】Python中yield关键字用法">【译】Python中yield关键字用法</h1><p>译：LeoTse</p>
<p>本文译自stackoverflow <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="external">What does the yield keyword do in Python?</a></p>
<h2 id="引子">引子</h2><p>这一切始于一位童鞋在Stack Overflow上问的问题：</p>
<p>Python中的yield关键字是用来干嘛的？它都干了些什么？</p>
<p>例如，我试图理解下面这段代码：</p>
<p><code>def node._get_child_candidates(self, distance, min_dist, max_dist):</code><br><code>if self._leftchild and distance - max_dist &lt; self._median:</code><br><code>yield self._leftchild</code><br><code>if self._rightchild and distance + max_dist &gt;= self._median:</code><br><code>yield self._rightchild</code>  </p>
<p>下面是调用代码：</p>
<p><code>result, candidates = list(), [self]</code><br><code>while candidates:</code><br><code>node = candidates.pop()</code><br><code>distance = node._get_dist(obj)</code><br><code>if distance &lt;= max_dist and distance &gt;= min_dist:</code><br><code>result.extend(node._values)</code><br><code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code><br><code>return result</code>  </p>
<p>当_get_child_candidates函数被调用时发生了什么？返回了一个list？返回了单个元素？还是它再次被调用了？后面的调用什么时候停止呢？</p>
<p>下面是这个问题的精华回复：</p>
<h2 id="yield关键字用法">yield关键字用法</h2><p>要想理解yield关键字，首先你得理解什么是<strong>生成器</strong>。而在这之前我们先得了解迭代。  </p>
<h3 id="迭代">迭代</h3><p>当你创建了一个list，你就可以逐个元素去读取这个list，这就叫做迭代：</p>
<p><code>&gt;&gt;&gt; mylist = [1, 2, 3]</code><br><code>&gt;&gt;&gt; for i in mylist:</code><br><code>...    print(i)</code><br><code>1</code><br><code>2</code><br><code>3</code>  </p>
<p>mylist就是可迭代的。当你使用list表达式，你就创建了一个list，亦即创建了一个迭代器：  </p>
<p><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]</code><br><code>&gt;&gt;&gt; for i in mylist:</code><br><code>...    print(i)</code><br><code>0</code><br><code>1</code><br><code>4</code>  </p>
<p>Python中所有你可以用到”for…in…”表达式的地方都是可迭代的：list，string，files等等。迭代器的优点是你可以读你所需，但是你需要在内存中存储（这些迭代器中的）所有的值，而当我们拥有大量数据时我们并不希望这样做。</p>
<h3 id="生成器">生成器</h3><p>生成器亦即迭代器，但是生成器只能迭代一次。因为它并不会将所有的数据存在内存中，而是实时生成我们所需的数据：</p>
<p><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))</code><br><code>&gt;&gt;&gt; for i in mygenerator:</code><br><code>...    print(i)</code><br><code>0</code><br><code>1</code><br><code>4</code>  </p>
<p>这个和你用元组()取代列表[]道理一样。但是，你不能指望<code>for i in mygenerator</code>运行第二次，因为生成器只能被使用一次：它（首先）计算得到0，然后会遗忘0并计算得出1，最终得到4（并遗忘1），以此类推。</p>
<h3 id="yield关键字">yield关键字</h3><p>Yield关键字和return的用法一样，只是（用到yield的）函数将会返回一个生成器。</p>
<p><code>&gt;&gt;&gt; def createGenerator():</code><br><code>...    mylist = range(3)</code><br><code>...    for i in mylist:</code><br><code>...        yield i*i</code><br><code>...</code><br><code>&gt;&gt;&gt; mygenerator = createGenerator() # create a generator</code><br><code>&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!</code><br><code>&lt;generator object createGenerator at 0xb7555c34&gt;</code><br><code>&gt;&gt;&gt; for i in mygenerator:</code><br><code>...     print(i)</code><br><code>0</code><br><code>1</code><br><code>4</code>  </p>
<p>这个例子不是太好。但是当你发现你的函数要返回大量只需读一次的数据时你会体会到它（yield）的好处。</p>
<p>要想掌握yield关键字，你必须知道：当你调用这个函数时，函数体里的代码并没有执行，它只是<strong>返回一个生成器对象</strong>，这看起来有点难以理解。</p>
<p>接着，每次你用到这个生成器的时候你的代码都会运行一次。</p>
<p>现在最难的部分来了：</p>
<p>当你第一次调用函数返回的生成器时，它将会运行函数中的代码直到执行到yield，然后它将返回这个循环产生的第一个值。接下来，每一次调用都将执行函数中的这个循环一次，并返回下一个值，直到没有值可以返回为止。</p>
<p>生成器会在函数执行但是没有遇到yield的情况下置空，这可能是因为循环结束了，或者是不再满足”if/else”条件。</p>
<h3 id="问题中的代码解释">问题中的代码解释</h3><p><strong>生成器</strong>：</p>
<p><code># 在这里你创建了node对象的一个返回生成器的函数</code><br><code>def node._get_child_candidates(self, distance, min_dist, max_dist):</code><br><code>`  # 下面这段代码将会在每次你使用这个生成器时被调用：` </code><br><code># 如果node对象仍然有一个左child</code><br><code># 而且distance满足条件，则返回下一个左child</code><br><code>if self._leftchild and distance - max_dist &lt; self._median:</code><br><code>yield self._leftchild</code><br><code>`  # 如果node对象仍然有一个右child`  
`  # 而且distance满足条件，则返回下一个右child`  
`  if self._rightchild and distance + max_dist &gt;= self._median:`  
`      yield self._rightchild` </code><br><code># 如果这个函数运行到这里了，意味着这个生成器可以看成空的了。</code><br><code># 亦即：再也没有符合条件的左右child了</code>  </p>
<p><strong>调用方</strong>：</p>
<p><code># 创建一个空的list和一个包含当前对象引用的list</code><br><code>result, candidates = list(), [self]</code><br><code>`# 循环处理candidates (最初只有一个元素)`  
`while candidates:` </code><br><code># 获取最后一个candidate将其移除</code><br><code>node = candidates.pop()</code><br><code>`    # 获取obj和candidate之间的距离`  
`    distance = node._get_dist(obj)` </code><br><code># 如果距离合适，保存结果在result中</code><br><code>if distance &lt;= max_dist and distance &gt;= min_dist:</code><br><code>result.extend(node._values)</code><br><code>`    # 将candidate的子节点保存在candidates中`  
`    # 该循环会一直循环直到遍历了所有的子节点。`  
`    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))` </code><br><code>return result</code>  </p>
<p>这段代码包含了以下几个很有意思的地方：</p>
<p>1）这个循环在遍历一个list，而这个list会在遍历的过程中增大。虽然存在变成无限循环的风险，但是这仍不失为遍历嵌套数据的好方法。在这里，candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))方法获取了这个生成器的所有元素，但是<code>while</code>在产生新的生成器，它们就会继续生产新的元素，直到换了一个节点。</p>
<p>2）extend()方法是list的一个用于将迭代器的元素追加在list中。<br>一般地，我们传一个list给它：</p>
<p><code>&gt;&gt;&gt; a = [1, 2]</code><br><code>&gt;&gt;&gt; b = [3, 4]</code><br><code>&gt;&gt;&gt; a.extend(b)</code><br><code>&gt;&gt;&gt; print(a)</code><br><code>[1, 2, 3, 4]</code>  </p>
<p>但是在你给出的代码里，它获取了一个生成器，它有如下几个好处：<br>a.你不需要两次读取这些元素；<br>b.如果你有很多子节点，你不需要把它们都保存在内存中；<br>这个方法很管用，因为Python不关心你传入的参数是不是一个list。Python只关心参数是否是可迭代的如字符串、list、元组以及生成器。这叫做<a href="http://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">鸭子类型</a>，这也是Python为何如此赞的一个原因。但是这些都不在我们的讨论范围内。</p>
<p>你可以到此结束，也可以接着看下面生成器的一些高级用法：</p>
<h3 id="控制生成器">控制生成器</h3><p><code>&gt;&gt;&gt; class Bank(): # let&#39;s create a bank, building ATMs</code><br><code>...    crisis = False</code><br><code>...    def create_atm(self):</code><br><code>...        while not self.crisis:</code><br><code>...            yield &quot;$100&quot;</code><br><code>&gt;&gt;&gt; hsbc = Bank() # when everything&#39;s ok the ATM gives you as much as you want</code><br><code>&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()</code><br><code>&gt;&gt;&gt; print(corner_street_atm.next())</code><br><code>$100</code><br><code>&gt;&gt;&gt; print(corner_street_atm.next())</code><br><code>$100</code><br><code>&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])</code><br><code>[&#39;$100&#39;, &#39;$100&#39;, &#39;$100&#39;, &#39;$100&#39;, &#39;$100&#39;]</code><br><code>&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!</code><br><code>&gt;&gt;&gt; print(corner_street_atm.next())</code><br><code>&lt;type &#39;exceptions.StopIteration&#39;&gt;</code><br><code>&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it&#39;s even true for new ATMs</code><br><code>&gt;&gt;&gt; print(wall_street_atm.next())</code><br><code>&lt;type &#39;exceptions.StopIteration&#39;&gt;</code><br><code>&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty</code><br><code>&gt;&gt;&gt; print(corner_street_atm.next())</code><br><code>&lt;type &#39;exceptions.StopIteration&#39;&gt;</code><br><code>&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business</code><br><code>&gt;&gt;&gt; for cash in brand_new_atm:</code><br><code>...    print cash</code><br><code>$100</code><br><code>$100</code><br><code>$100</code><br><code>$100</code><br><code>$100</code><br><code>$100</code><br><code>$100</code><br><code>$100</code><br><code>$100</code><br><code>...</code>  </p>
<p>如果想要控制对资源的访问，这将非常受用。</p>
<h3 id="itertools，你上佳的朋友">itertools，你上佳的朋友</h3><p>itertools模块包含了操纵迭代的一些特殊的函数。你是不是曾经想过复制一个生产器？串联两个生成器？抑或在线性时间内将嵌套list中的元素分组？或者不依赖创建新list的情况下map/zip？</p>
<p>那么，你只要导入itertools模块就行了。</p>
<p>想要看个例子？让我们看看四匹马到达终点的可能顺序：</p>
<p><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]</code><br><code>&gt;&gt;&gt; races = itertools.permutations(horses)</code><br><code>&gt;&gt;&gt; print(races)</code><br><code>&lt;itertools.permutations object at 0xb754f1dc&gt;</code><br><code>&gt;&gt;&gt; print(list(itertools.permutations(horses)))</code><br><code>[(1, 2, 3, 4),</code><br><code>(1, 2, 4, 3),</code><br><code>(1, 3, 2, 4),</code><br><code>(1, 3, 4, 2),</code><br><code>(1, 4, 2, 3),</code><br><code>(1, 4, 3, 2),</code><br><code>(2, 1, 3, 4),</code><br><code>(2, 1, 4, 3),</code><br><code>(2, 3, 1, 4),</code><br><code>(2, 3, 4, 1),</code><br><code>(2, 4, 1, 3),</code><br><code>(2, 4, 3, 1),</code><br><code>(3, 1, 2, 4),</code><br><code>(3, 1, 4, 2),</code><br><code>(3, 2, 1, 4),</code><br><code>(3, 2, 4, 1),</code><br><code>(3, 4, 1, 2),</code><br><code>(3, 4, 2, 1),</code><br><code>(4, 1, 2, 3),</code><br><code>(4, 1, 3, 2),</code><br><code>(4, 2, 1, 3),</code><br><code>(4, 2, 3, 1),</code><br><code>(4, 3, 1, 2),</code><br><code>(4, 3, 2, 1)]</code>  </p>
<h3 id="理解迭代的内部机制">理解迭代的内部机制</h3><p>迭代是实现迭代（实现了__iter__()函数）和迭代器（实现了__next__()函数）的过程。你可以从可迭代对象上获取一个迭代器，而迭代器是你可以迭代的对象。</p>
<p>想要了解更多，你可以看看这篇<a href="http://effbot.org/zone/python-for-statement.htm" target="_blank" rel="external">文章</a>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/29/改变FastDFS中某个机器的分组/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Leo Tse" target="_blank" itemprop="author">Leo Tse</a>
		
  <p class="article-time">
    <time datetime="2015-09-29T07:53:05.000Z" itemprop="datePublished"> 发表于 2015-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="改变FastDFS中某个机器的分组">改变FastDFS中某个机器的分组</h1><p><em>By：LeoTse</em></p>
<p>我们假设有FastDFS集群A，B，C，D三台机器，其中A为Tracker。BCD都为Storage，它们同属group1，现在想要将C机器重新建一个group2，应该怎么操作呢？  </p>
<p><em>step1：停止C机器上的FastDFS服务</em><br><code>/usr/bin/stop.sh /usr/bin/fdfs_storaged /etc/fdfs/storage.conf</code></p>
<p><em>step2：将C从FastDFS集群的group1中删除</em><br><code>/usr/bin/fdfs_monitor /usr/bin/client.conf delete group1 C_ip_addr</code></p>
<p><em>step3：修改C机器的storage.conf配置</em><br><code># the name of the group this storage server belongs to</code><br><code>#</code><br><code># comment or remove this item for fetching from tracker server,</code><br><code># in this case, use_storage_id must set to true in tracker.conf,</code><br><code># and storage_ids.conf must be configed correctly.</code><br><code>group_name=group2</code>  </p>
<p>将group_name改为group2。</p>
<p>注意：如果Tracker为指定store_lookup方式，即tracker.conf配置中：<br><code># the method of selecting group to upload files</code><br><code># 0: round robin</code><br><code># 1: specify group</code><br><code># 2: load balance, select the max free space group to upload file</code><br><code>store_lookup=2</code>    </p>
<p><code># which group to upload file</code><br><code># when store_lookup set to 1, must set store_group to the group name</code><br><code>store_group=group1</code>    </p>
<p>如果store_lookup=1，则需要将其修改为0或者2，酌情选择。如果store_lookup不是1，则store_group会忽略。</p>
<p><em>step4：删除base_path下的data目录</em><br>这个时候要看我们是否需要删除C机器已经存储的文件。如果我们不再需要C机器上保存的文件，则可以删除base_path下data目录，重新启动FastDFS服务时会新建data目录；如果我们不想删除C机器上现有的文件，则可以删除除了存储目录以外的其他目录和文件：fdfs_storaged.pid文件、storage_stat.dat文件、.data_init_flag文件以及sync目录。</p>
<p><em>step5：重启C机器的FastDFS服务</em><br><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf</code>  </p>
<p>（如果我们想要卸载FastDFS，直接删除base_path下的data目录即可。）</p>
<p>至此，我们对集群重新分组完成。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/29/SSH免密码登录设置/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Leo Tse" target="_blank" itemprop="author">Leo Tse</a>
		
  <p class="article-time">
    <time datetime="2015-09-29T07:52:54.000Z" itemprop="datePublished"> 发表于 2015-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="SSH免密码登录设置">SSH免密码登录设置</h1><p><strong>整理：LeoTse</strong></p>
<h2 id="SSH免密码登录设置-1">SSH免密码登录设置</h2><p>准备工作：<br>两台机器S1，S2。IP分别为IP1，IP2，用户名为user。<br>我们想从S1免密码登录S2机器。以下为SSH设置的步骤：</p>
<p>Step1：生产key。在S1上输入：<br><code>ssh-keygen -t rsa</code><br>然后一直enter，直到结束。</p>
<p>Step2: 我们进入到~/.ssh目录，然后将生成的key通过scp复制到S2的.ssh目录（我们首先要确保目录存在）：<br><code>cd ~/.ssh</code><br><code>scp ~/.ssh/id_rsa.pub user@IP2:/home/user/.ssh/IP2</code><br>截至目前，S1上的配置已经完成。</p>
<p>Step3：接下来我们登录S2机器。进入.ssh目录，确保authorized_keys文件存在：<br><code>cd ~/.ssh</code><br><code>cat IP2 &gt;&gt; authorized_keys</code><br>SSH免登录已经设置完毕，如果是普通用户，继续往下看。</p>
<h2 id="普通用户">普通用户</h2><p>对于普通用户authorized_keys的权限必须限定为600，否则普通用户无法实现无密钥访问，而ROOT用户按照默认即可实现无密码访问：<br><code>sudo chmod 600 authorized_keys</code>  </p>
<h2 id="免密码登录验证">免密码登录验证</h2><p>我们在S1上直接ssh连接S2机器，看能否免密码登录：<br><code>ssh IP2</code><br>如果可以直接登录上去，则说明已经设置成功。</p>
<p>另，如果要设置S1和S2互相免密码登录，以上步骤在S1和S2都执行一次就好了！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="leotse90" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/leotse90" target="_blank" title="Leotse&#39;s Github">Leotse&#39;s Github</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> You know I&#39;m hoping you&#39;ll sing along . <br/>
			Though it&#39;s not your favorite song.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/proleo" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/leotse90" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="Leo Tse">Leo Tse</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fe6d1f421bbc9962127a50488f9ed37d1' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
